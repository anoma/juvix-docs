<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>Juvix Docs</title><description>The official documentation for Juvix</description><link>https://docs.juvix.org/pull-136/</link><atom:link href="https://docs.juvix.org/pull-136/feed_rss_created.xml" rel="self" type="application/rss+xml" /><managingEditor>The Juvix Team</managingEditor><docs>https://github.com/anoma/juvix</docs><language>en</language> <pubDate>Mon, 23 Dec 2024 17:16:42 -0000</pubDate> <lastBuildDate>Mon, 23 Dec 2024 17:16:42 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.17.1</generator> <image> <url>None</url> <title>Juvix Docs</title><link>https://docs.juvix.org/pull-136/</link> </image> <item> <title>Iterator syntax</title> <author>≈Åukasz Czajka</author> <category>iterators</category> <category>language</category> <category>syntax</category> <description>&lt;h1&gt;Iterator syntax&lt;/h1&gt;&lt;p&gt;A common pattern in functional programming is the traversal of data structures,particularly lists, in a specified order accumulating some values. If you&#39;veused languages like Haskell or OCaml, you must have come across the &#34;fold left&#34;(&lt;code&gt;foldl&lt;/code&gt;) and &#34;fold right&#34; (&lt;code&gt;foldr&lt;/code&gt;) higher-order functions which implement thispattern. These functions are also [available in Juvix][juvix-folds]. In thisblog post, I describe an iterator syntax I designed for Juvix which allowsexpressing folds (and maps, filters and more) in a readable manner.&lt;/p&gt;</description><link>https://docs.juvix.org/pull-136/blog/iterators.html</link> <pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><source url="https://docs.juvix.org/pull-136/feed_rss_created.xml">Juvix Docs</source><guid isPermaLink="true">https://docs.juvix.org/pull-136/blog/iterators.html</guid> <enclosure url="https://docs.juvix.org/pull-136/assets/images/social/blog.png" type="image/png" length="33981" /> </item> <item> <title>Stay Positive</title> <author>Jonathan Cubides</author> <category>inductive-types</category> <category>type-system</category> <category>type-system</category> <description>&lt;h1&gt;Stay Positive&lt;/h1&gt;&lt;p&gt;Let us explore the concept of strictly positive inductive data types, a critical requirement within the Juvix framework for classifying a data type as well-typed.&lt;/p&gt;&lt;p&gt;An &lt;strong&gt;inductive type&lt;/strong&gt; is considered &lt;em&gt;strictly positive&lt;/em&gt; if it either:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Does not appear within the argument types of its constructors, or&lt;/li&gt;&lt;li&gt;Appears strictly positively within the argument types of its constructors.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;A name is considered strictly positive for an inductive type if it never appearsin a negative position within the argument types of its constructors. The term&lt;em&gt;negative position&lt;/em&gt; denotes instances located to the left of an arrow in a typeconstructor argument.&lt;/p&gt;</description><link>https://docs.juvix.org/pull-136/blog/strictly-positive-data-types.html</link> <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate><source url="https://docs.juvix.org/pull-136/feed_rss_created.xml">Juvix Docs</source><guid isPermaLink="true">https://docs.juvix.org/pull-136/blog/strictly-positive-data-types.html</guid> <enclosure url="https://docs.juvix.org/pull-136/assets/images/social/blog.png" type="image/png" length="35895" /> </item> </channel></rss>