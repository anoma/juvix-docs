{"version": "https://jsonfeed.org/version/1", "title": "Juvix Docs", "home_page_url": "https://docs.juvix.org/latest/", "feed_url": "https://docs.juvix.org/latest/feed_json_created.json", "description": "The official documentation for Juvix", "icon": null, "authors": [{"name": "The Juvix Team"}], "language": "en", "items": [{"id": "https://docs.juvix.org/latest/latest/blog/geb-backend.html", "url": "https://docs.juvix.org/latest/latest/blog/geb-backend.html", "title": "Compiling to VampIR through Geb", "content_html": "<h1>Compiling to VampIR through Geb</h1>\n<p><a href=\"https://docs.juvix.org/latest/blog/vampir-circuits/\">Before</a>, we discussed the\nstandard normalization approach to compiling Juvix programs to VampIR. An\nalternative backend is provided by the Geb project currently implemented in Lisp\nshowcasing a categorical view of the needed translations.</p>\n<p>The post will be devoted to discussing the core ideas of Geb, the practical\nsteps to take in order to use the corresponding pipeline, as well as the current\nlimitations the backend faces.</p>", "image": "https://docs.juvix.org/latest/assets/images/social/blog/posts/geb-backend.png", "date_published": "2023-09-19T00:00:00+00:00", "authors": [{"name": "artem"}], "tags": ["circuits", "geb", "vampir", "vampir"]}, {"id": "https://docs.juvix.org/latest/latest/blog/vampir-circuits.html", "url": "https://docs.juvix.org/latest/latest/blog/vampir-circuits.html", "title": "Compiling Juvix programs to arithmetic circuits via Vamp-IR", "content_html": "<h1>Compiling Juvix programs to arithmetic circuits via Vamp-IR</h1>\n<p>Since version 0.3.5, the Juvix compiler supports the <code>vampir</code> target which generates [Vamp-IR][vampir-book] input files that can be compiled to various proof systems based on arithmetic circuits, like Plonk or Halo 2. Vamp-IR is a proof-system-agnostic language for writing arithmetic circuits.</p>\n<p>In this post, we will not be discussing the details of Vamp-IR or the circuit computation model. Instead, we will describe how high-level functional Juvix programs can be compiled to circuits, what the common pitfalls and current limitations are. The reader is assumed to have at least basic familiarity with [Vamp-IR][vampir-book].</p>", "image": "https://docs.juvix.org/latest/assets/images/social/blog/posts/vampir-circuits.png", "date_published": "2023-06-15T00:00:00+00:00", "authors": [{"name": "lukasz"}], "tags": ["circuits", "vampir", "vampir"]}, {"id": "https://docs.juvix.org/latest/latest/blog/iterators.html", "url": "https://docs.juvix.org/latest/latest/blog/iterators.html", "title": "Iterator syntax", "content_html": "<h1>Iterator syntax</h1>\n<p>A common pattern in functional programming is the traversal of data structures,\nparticularly lists, in a specified order accumulating some values. If you've\nused languages like Haskell or OCaml, you must have come across the \"fold left\"\n(<code>foldl</code>) and \"fold right\" (<code>foldr</code>) higher-order functions which implement this\npattern. These functions are also [available in Juvix][juvix-folds]. In this\nblog post, I describe an iterator syntax I designed for Juvix which allows\nexpressing folds (and maps, filters and more) in a readable manner.</p>", "image": "https://docs.juvix.org/latest/assets/images/social/blog/posts/iterators.png", "date_published": "2023-06-08T00:00:00+00:00", "authors": [{"name": "lukasz"}], "tags": ["iterators", "language", "syntax"]}, {"id": "https://docs.juvix.org/latest/latest/blog/ethprague.html", "url": "https://docs.juvix.org/latest/latest/blog/ethprague.html", "title": "Join Juvix Team at ETHPrague", "content_html": "<h1>Join Juvix Team at ETHPrague</h1>\n<p>The Juvix team is excited to announce our participation in [ETHPrague\n2023][ethprague], an Ethereum-focused event happening in Prague, Czech Republic,\nfrom June 8-11.</p>\n<p>Join us for an immersive experience where you can learn about the current state\nof the Juvix language, explore and create real-world applications built with\nJuvix, and engage in discussions about the future possibilities and exciting\nplans we have in store.</p>\n<h2>The event</h2>\n<p>ETHPrague is a premier blockchain event that brings together the global Ethereum\ncommunity to discuss the future of Ethereum, blockchain technology, and new\nconcepts. It provides a platform for knowledge sharing, networking, and\ncollaboration among enthusiasts, experts, and visionaries.</p>\n<p>The event features an impressive lineup of speakers, including the esteemed\nVitalik Buterin. With engaging panels, workshops, and even a hackathon,\nETHPrague offers abundant opportunities to learn, network, and connect with\nexceptional individuals and communities.</p>\n<p>The event will take place from June 8th to June 11th in the beautiful city of\nPrague, Czech Republic. For more information, please visit the [official event\nwebpage][ethprague].</p>\n<p>Make sure to mark your calendar for the following key sessions:</p>\n<ul>\n<li>Talk by <strong>Veronika Romashkina</strong>: On <em>Saturday, June 10th, from 14:10 - 14:30</em>\n  at the <em>Institute of Cryptoanarchy</em>, Veronika, Developer Relations at Heliax,\n  will present a talk titled <strong>\"Juvix: Toward a Functional Programming Language\n  for Decentralized Applications and Beyond.\"</strong></li>\n<li>Workshop by <strong>Paul Cadman</strong>: Also on <em>Saturday, June 10th, from 16:20 - 17:20</em>\n  at the <em>Paper Hub</em>, Paul, Compiler Engineer at Heliax, will host a workshop\n  titled <strong>\"Discovering Juvix: The High-Level Functional Programming Language\n  for Building Next-Generation dApps.\"</strong></li>\n</ul>", "image": "https://docs.juvix.org/latest/assets/images/social/blog/posts/ethprague.png", "date_published": "2023-06-07T00:00:00+00:00", "authors": [{"name": "veronika"}], "tags": ["ETHPrague", "Workshop", "conference"]}, {"id": "https://docs.juvix.org/latest/latest/blog/strictly-positive-data-types.html", "url": "https://docs.juvix.org/latest/latest/blog/strictly-positive-data-types.html", "title": "Stay Positive", "content_html": "<h1>Stay Positive</h1>\n<p>Let us explore the concept of strictly positive inductive data types, a critical requirement within the Juvix framework for classifying a data type as well-typed.</p>\n<p>An <strong>inductive type</strong> is considered <em>strictly positive</em> if it either:</p>\n<ol>\n<li>Does not appear within the argument types of its constructors, or</li>\n<li>Appears strictly positively within the argument types of its constructors.</li>\n</ol>\n<p>A name is considered strictly positive for an inductive type if it never appears\nin a negative position within the argument types of its constructors. The term\n<em>negative position</em> denotes instances located to the left of an arrow in a type\nconstructor argument.</p>", "image": "https://docs.juvix.org/latest/assets/images/social/blog/posts/strictly-positive-data-types.png", "date_published": "2022-07-25T00:00:00+00:00", "authors": [{"name": "jonathan"}], "tags": ["inductive-types", "type-system", "type-system"]}]}