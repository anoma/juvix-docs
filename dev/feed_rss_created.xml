<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"> <channel><title>Juvix Docs</title><description>The Official Documentation for Juvix</description><link>https://docs.juvix.org/</link><atom:link href="https://docs.juvix.org/feed_rss_created.xml" rel="self" type="application/rss+xml" /><managingEditor>The Juvix Team</managingEditor><docs>https://github.com/anoma/juvix</docs><language>en-None</language> <pubDate>Sat, 16 Sep 2023 23:12:25 -0000</pubDate> <lastBuildDate>Sat, 16 Sep 2023 23:12:25 -0000</lastBuildDate> <ttl>1440</ttl> <generator>MkDocs RSS plugin - v1.8.0</generator> <item> <title>Compiling Juvix programs to arithmetic circuits via Vamp-IR</title> <author>lukasz</author> <category>circuits</category> <category>vampir</category> <category>vampir</category> <description>&lt;h1&gt;Compiling Juvix programs to arithmetic circuits via Vamp-IR&lt;/h1&gt;&lt;p&gt;Since version 0.3.5, the Juvix compiler supports the &lt;code&gt;vampir&lt;/code&gt; target which generates [Vamp-IR][vampir-book] input files that can be compiled to various proof systems based on arithmetic circuits, like Plonk or Halo 2. Vamp-IR is a proof-system-agnostic language for writing arithmetic circuits.&lt;/p&gt;&lt;p&gt;In this post, we will not be discussing the details of Vamp-IR or the circuit computation model. Instead, we will describe how high-level functional Juvix programs can be compiled to circuits, what the common pitfalls and current limitations are. The reader is assumed to have at least basic familiarity with [Vamp-IR][vampir-book].&lt;/p&gt;</description><link>https://docs.juvix.org/latest/blog/vampir-circuits/</link> <pubDate>Thu, 15 Jun 2023 00:00:00 +0000</pubDate><source url="https://docs.juvix.org/feed_rss_created.xml">Juvix Docs</source><guid isPermaLink="true">https://docs.juvix.org/latest/blog/vampir-circuits/</guid> </item> <item> <title>Iterator syntax</title> <author>lukasz</author> <category>iterators</category> <category>language</category> <category>syntax</category> <description>&lt;h1&gt;Iterator syntax&lt;/h1&gt;&lt;p&gt;A common pattern in functional programming is the traversal of data structures,particularly lists, in a specified order accumulating some values. If you&#39;veused languages like Haskell or OCaml, you must have come across the &#34;fold left&#34;(&lt;code&gt;foldl&lt;/code&gt;) and &#34;fold right&#34; (&lt;code&gt;foldr&lt;/code&gt;) higher-order functions which implement thispattern. These functions are also [available in Juvix][juvix-folds]. In thisblog post, I describe an iterator syntax I designed for Juvix which allowsexpressing folds (and maps, filters and more) in a readable manner.&lt;/p&gt;</description><link>https://docs.juvix.org/latest/blog/iterators/</link> <pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><source url="https://docs.juvix.org/feed_rss_created.xml">Juvix Docs</source><guid isPermaLink="true">https://docs.juvix.org/latest/blog/iterators/</guid> </item> <item> <title>Join Juvix Team at ETHPrague</title> <author>veronika</author> <category>ETHPrague</category> <category>Workshop</category> <category>conference</category> <description>&lt;h1&gt;Join Juvix Team at ETHPrague&lt;/h1&gt;&lt;p&gt;The Juvix team is excited to announce our participation in [ETHPrague2023][ethprague], an Ethereum-focused event happening in Prague, Czech Republic,from June 8-11.&lt;/p&gt;&lt;p&gt;Join us for an immersive experience where you can learn about the current stateof the Juvix language, explore and create real-world applications built withJuvix, and engage in discussions about the future possibilities and excitingplans we have in store.&lt;/p&gt;&lt;h2&gt;The event&lt;/h2&gt;&lt;p&gt;ETHPrague is a premier blockchain event that brings together the global Ethereumcommunity to discuss the future of Ethereum, blockchain technology, and newconcepts. It provides a platform for knowledge sharing, networking, andcollaboration among enthusiasts, experts, and visionaries.&lt;/p&gt;&lt;p&gt;The event features an impressive lineup of speakers, including the esteemedVitalik Buterin. With engaging panels, workshops, and even a hackathon,ETHPrague offers abundant opportunities to learn, network, and connect withexceptional individuals and communities.&lt;/p&gt;&lt;p&gt;The event will take place from June 8th to June 11th in the beautiful city ofPrague, Czech Republic. For more information, please visit the [official eventwebpage][ethprague].&lt;/p&gt;&lt;p&gt;Make sure to mark your calendar for the following key sessions:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Talk by &lt;strong&gt;Veronika Romashkina&lt;/strong&gt;: On &lt;em&gt;Saturday, June 10th, from 14:10 - 14:30&lt;/em&gt; at the &lt;em&gt;Institute of Cryptoanarchy&lt;/em&gt;, Veronika, Developer Relations at Heliax, will present a talk titled &lt;strong&gt;&#34;Juvix: Toward a Functional Programming Language for Decentralized Applications and Beyond.&#34;&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;Workshop by &lt;strong&gt;Paul Cadman&lt;/strong&gt;: Also on &lt;em&gt;Saturday, June 10th, from 16:20 - 17:20&lt;/em&gt; at the &lt;em&gt;Paper Hub&lt;/em&gt;, Paul, Compiler Engineer at Heliax, will host a workshop titled &lt;strong&gt;&#34;Discovering Juvix: The High-Level Functional Programming Language for Building Next-Generation dApps.&#34;&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://docs.juvix.org/latest/blog/ethprague/</link> <pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate><source url="https://docs.juvix.org/feed_rss_created.xml">Juvix Docs</source><guid isPermaLink="true">https://docs.juvix.org/latest/blog/ethprague/</guid> </item> <item> <title>Stay Positive with Your Data Types</title> <author>jonathan</author> <category>inductive-types</category> <category>type-system</category> <category>type-system</category> <description>&lt;h1&gt;Stay Positive with Your Data Types&lt;/h1&gt;&lt;p&gt;In this discussion, we will explore the concept of strictly positive inductive data types, a critical requirement within the Juvix framework for classifying a data type as well-typed.&lt;/p&gt;&lt;p&gt;An &lt;strong&gt;inductive type&lt;/strong&gt; is considered &lt;em&gt;strictly positive&lt;/em&gt; if it either:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Does not appear within the argument types of its constructors, or&lt;/li&gt;&lt;li&gt;Appears strictly positively within the argument types of its constructors.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;A name is considered strictly positive for an inductive type if it never appearsin a negative position within the argument types of its constructors. The term&lt;em&gt;negative position&lt;/em&gt; denotes instances located to the left of an arrow in a typeconstructor argument.&lt;/p&gt;</description><link>https://docs.juvix.org/latest/blog/strictly-positive-data-types/</link> <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate><source url="https://docs.juvix.org/feed_rss_created.xml">Juvix Docs</source><guid isPermaLink="true">https://docs.juvix.org/latest/blog/strictly-positive-data-types/</guid> </item> </channel></rss>