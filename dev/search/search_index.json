{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stemmer","stopWordFilter","trimmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Juvix a language for intent-centric and declarative decentralized applications","text":"<p>Install Juvix on your machine</p> <p>  Try Juvix now on Codespaces</p> <p>Juvix is an open-source functional language with static typing and strict semantics. It is the programming language for the Anoma's blockchain. The primary purpose of this language is to encode Anoma's intents, enabling private and transparent execution through Taiga on the Anoma blockchain.</p> <p>Juvix, initially designed for Anoma, provides features typical of any high-level programming language with many more on the horizon. It can compile programs into native executable, WASM, and arithmetic circuits using VampIR or Geb, facilitating zero-knowledge proofs.</p> <p>Stay tuned for Juvix updates! Follow us on  Twitter and join our  Discord community.</p> Taiga SimulatorTransaction lifecycle <p>How to write intents in Juvix to validate transactions in Anoma is further elaborated in both the Taiga Simulator repository and the Juvix Workshop.</p> <pre><code>sequenceDiagram\n    UserWallet -&gt;&gt;Taiga API: use intent to create ptxs\n    Taiga API  --&gt;&gt;UserWallet: returns ptxs\n    UserWallet  -&gt;&gt;Solvers: send a ptxs\n    Solvers   -&gt;&gt;Solvers: match/broadcast ptxs\n    Solvers  --&gt;&gt;Taiga API: create helper ptxs\n    Taiga API  --&gt;&gt;Solvers: gives helper ptxs\n    Solvers   -&gt;&gt;Taiga API: create a tx\n    Taiga API  --&gt;&gt;Solvers: returns a finalized tx\n    Solvers  -&gt;&gt;Finaliser : submit finalized transaction\n        Finaliser -&gt;&gt; Taiga API: verify the finalized transaction\n    Taiga API -&gt;&gt; Finaliser: return the result (valid/invalid)\n    Finaliser --&gt;&gt; Blockchain: commit a (balanced) tx\n    Blockchain -&gt;&gt; Blockchain: run consensus Typhon alg.\n    Blockchain -&gt;&gt; Taiga API: verify the transaction\n    Taiga API --&gt;&gt; Blockchain: return the result (valid/invalid)</code></pre> <ul> <li> <p> How-to guides</p> <p>Learn how to install Juvix on macOS or Linux, as well as compile and    document your Juvix projects.</p> <p> Quick start </p> <p> How-to guides </p> </li> <li> <p> Tutorials</p> <p>Master the essentials of Juvix through a series of tailored examples, tutorials and technical explanations.</p> <p> Learn Juvix in 5 minutes</p> </li> </ul> <ul> <li> <p> Talks and Workshops</p> <p>A collection of talks and workshop videos showcasing Juvix. Gain valuable insights and inspiration from our presentations at various conferences.</p> <p> Juvix videos</p> </li> <li> <p> Reference</p> <p>Explore the Language reference, milestone examples, and tooling documentation!</p> <p> Reference</p> </li> <li> <p> Blog</p> <p>Check out our blog to discover new features in the upcoming release, along with helpful examples and more. And, don't forget to join us on Discord.</p> <p> Blog</p> <p> Join us</p> </li> <li> <p> Open Source, GPL3.0</p> <p>Juvix is licensed under GPL3 and available on GitHub.</p> <p> License</p> </li> </ul>"},{"location":"#a-brief-of-what-juvix-is-about","title":"... a brief of what Juvix is about","text":""},{"location":"#intents-in-juvix-for-anomas-dapps","title":"Intents in Juvix for Anoma's dApps","text":"<p>What is an intent? An intent, in essence, is a high-level description, a message sent by programs to indicate changes of a desired state.</p> <p>Take for instance, Alice's intent. Her intent is to trade either two units of resource <code>B</code> or one unit of resource <code>A</code> for a unit of <code>Dolphin</code>. Bob, on the other hand, is willing to exchange one unit of resource <code>A</code> for 1 <code>Dolphin</code>. How can we write these intents in Juvix? The conditions for Alice's intent is presented in Juvix on the right, a logic function that validates the transaction.</p> <p>See here the full Juvix code for this example.</p> Two-party exchange <pre><code>flowchart LR\n    A((Alice)) -- \"Intent 1:\\ntrade 1 A or 2 B for 1 Dolphin\" ---&gt; B[Taiga]\n    X((Bob)) -- \"Intent 2:\\ntrade 1 Dolphin for 1 A\" ---&gt; B\n    B --&gt; P[Pool]\n    S((Solver)) &lt;----&gt; P\n    P -- \"Intent solving\" --&gt; Z(\"Finalized\\nTransaction\")\n    Z --&gt; O[(Anoma)]</code></pre>"},{"location":"#anomataiga-simulator","title":"<code>anoma/taiga-simulator</code>","text":"Partial transactionsAlice IntentLogics <pre><code>module Alice;\n  -- Alice is willing to exchange either 2 B or 1 A for 1 Dolphin.\n  partialTransaction : PartialTx :=\n    mkPartialTx\n      (consumedPair := A.mkResource 1, B.mkResource 2;\n      createdPair := AliceIntent.mkResource 1, dummyResource);\nend;\n\nmodule Bob;\n  partialTransaction : PartialTx :=\n    mkPartialTx\n      (consumedPair := Dolphin.mkResource 1, dummyResource;\n      createdPair := A.mkResource 1, dummyResource);\nend;\n\nmodule Solver;\n  partialTransaction : PartialTx :=\n    mkPartialTx\n      (consumedPair := AliceIntent.mkResource 1, dummyResource;\n      createdPair := Dolphin.mkResource 1, B.mkResource 2);\nend;</code></pre> <pre><code>module AliceIntent;\n  logicFunction : ResourceKind -&gt; PartialTx -&gt; Bool\n    | kind tx :=\n      let\n        createdRs : List Resource := createdResources tx;\n        createdHashes : List LogicHash :=\n          map Resource.logicHash createdRs;\n      in isCreated kind\n        || (quantityOfDenom Dolphin.denomination createdRs == 1\n          &amp;&amp; quantityOfDenom A.denomination createdRs == 1)\n        || quantityOfDenom Dolphin.denomination createdRs == 1\n        &amp;&amp; quantityOfDenom B.denomination createdRs == 2;\n\n  --- This will be computed from the logic function\n  logicHash : LogicHash := 1;\n\n  staticData : ByteString := 3 :: nil;\n\n  denomination : Denomination := 1 :: staticData;\n\n  mkResource (n : Int) : Resource :=\n    mkResource'\n      (logicHash := logicHash;\n      staticData := staticData;\n      dynamicData := nil;\n      quantity := n);\nend;</code></pre> <pre><code>logicFunctions : Map LogicHash LogicFunction :=\n  mkLogicFunctionMap\n    ((AliceIntent.logicHash, AliceIntent.logicFunction) :: nil);</code></pre> <pre><code>twoPartyExchange : Test :=\n    let\n        txs : List PartialTx :=\n        Alice.partialTransaction\n            :: Bob.partialTransaction\n            :: Solver.partialTransaction\n            :: nil;\n    in testCase\n        \"two party exchange\"\n        (assertTrue\n        \"expected two-party exchange transactions to validate\"\n        (checkTransaction logicFunctions txs));</code></pre>"},{"location":"#arithmetic-circuits-zero-knowledge-proofs","title":"Arithmetic Circuits / Zero-knowledge Proofs","text":"<p>An arithmetic circuit is an algebraic representation, essentially expressing a system of polynomial equations in a universal, canonical form that model the computation of a program. Arithmetic circuits are used in zero-knowledge proofs and Juvix can compile programs into these representations via our in-house compiler VampIR.</p> <pre><code>flowchart LR\n    A[Juvix file]  -- Juvix --&gt; B[VampIR circuit]\n    B -- VampIR --&gt; C[PLONK or Halo2 circuit]</code></pre> <pre><code>juvix compile -t vampir Hash.juvix</code></pre> <p>The VampIR file can then be compiled to a PLONK circuit:</p> <pre><code>vamp-ir plonk setup -m 14 -o input.pp\nvamp-ir plonk compile -u input.pp -s Hash.pir -o c.plonk</code></pre> <p>A zero-knowledge proof that <code>hash 1367</code> is equal to <code>3</code> can then be generated from the circuit:</p> <pre><code>vamp-ir plonk prove -u input.pp \\\n                    -c c.plonk \\\n                    -o proof.plonk -i Hash.json</code></pre> <p>This proof can then be verified:</p> <pre><code>vamp-ir plonk verify -u input.pp -c c.plonk -p proof.plonk</code></pre>"},{"location":"#anomajuvix-workshop","title":"<code>anoma/juvix-workshop</code>","text":"Hash.juvixHash.json <pre><code>module Hash;\n\nimport Stdlib.Prelude open;\nimport Stdlib.Data.Nat.Ord open;\n\n{-# unroll: 30 #-}\nterminating\npower' (acc a b : Nat) : Nat :=\n  let\n    acc' : Nat := if (mod b 2 == 0) acc (acc * a);\n  in if (b == 0) acc (power' acc' (a * a) (div b 2));\n\npower : Nat \u2192 Nat := power' 1 2;\n\nhash' : Nat -&gt; Nat -&gt; Nat\n  | (suc n@(suc (suc m))) x :=\n    if\n      (x &lt; power n)\n      (hash' n x)\n      (mod (div (x * x) (power m)) (power 6))\n  | _ x := x * x;\n\nhash : Nat -&gt; Nat := hash' 16;\n\nmain : Nat -&gt; Nat := hash;</code></pre> <pre><code>{\n    \"in\": \"1367\",\n    \"out\": \"3\"\n}</code></pre> <p>Note</p> <p>For further details, refer to Compiling Juvix programs to arithmetic circuits via Vamp-IR.</p>"},{"location":"#juvix-is-growing-fast","title":"Juvix is growing fast!","text":""},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v052","title":"v0.5.2","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add <code>juvix dependencies update</code> command #2419 (paulcadman)</li> <li>Add Juvix package lockfile support #2334</li> <li>Add <code>Partial</code> trait #2409 (lukaszcz)</li> <li>Fix for crash with wildcard used in type definition #2405 (janmasrovira)</li> <li>Improve closure calls in the runtime #2396 (lukaszcz)</li> <li>Allow open statements in let expressions #2395 (janmasrovira)</li> <li>Fix delay instance resolution #2393 (lukaszcz)</li> <li>Support functions in instance parameters #2385 (lukaszcz)</li> <li>Do not call <code>git fetch</code> on git dependency if ref already exists in clone #2379 (paulcadman)</li> <li>Improve inlining #2377 (lukaszcz)</li> <li>Record creation syntax with function definitions #2369 (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Fix record creation error message location #2424 (lukaszcz)</li> <li>Fix bug in instance termination checking #2423 (lukaszcz)</li> <li>Reinstate the project .hlint.yaml #2420 (paulcadman)</li> <li>Remove package.yaml entry for PNG assets #2418 (paulcadman)</li> <li>Update benchmarks #2415 (lukaszcz)</li> <li>Fix minor: case and error message #2407 (jonaprieto)</li> <li>Fix tara url svg #2406 (jonaprieto)</li> <li>Update pre-commit to check JSON formatting #2400 (jonaprieto)</li> <li>Simplify README #2399 (jonaprieto)</li> <li>Remove unused files #2398 (jonaprieto)</li> <li>Minor changes to midsquare #2397 (jonaprieto)</li> <li>Add fixity <code>none</code> and make aliases inherit fixity #2391 (lukaszcz)</li> <li>Add nodes with no edges to the dependency graph #2390 (janmasrovira)</li> <li>Remove function clause from <code>Internal</code> #2389 (janmasrovira)</li> <li>Add package lockfile support #2388 (paulcadman)</li> <li>Fix case formatting #2387 (lukaszcz)</li> <li>Instance holes #2384 (lukaszcz)</li> <li>Update standard library list functions to use traits #2382 (lukaszcz)</li> <li>Avoid serialization of _packageFile field in juvix.yaml #2381 (paulcadman)</li> <li>Avoid the <code>-Os</code> option when generating WebAssembly #2378 (lukaszcz)</li> <li>Error on local instances #2376 (lukaszcz)</li> <li>Error for an instance subsumed by other instances #2375 (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<p>Full Changelog</p> <p>Merged pull requests:</p> <ul> <li>Fix bug in isTrait #2368 (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v050","title":"v0.5.0","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add new case syntax #2353 (paulcadman)</li> <li>VampIR range checks and error handling #2344 (lukaszcz)</li> <li>Traits #2320 (lukaszcz)</li> <li>Aliasing #2301 (janmasrovira)</li> <li>External package dependencies #2272 (paulcadman)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update stdlib submodule to current stdlib main #2364 (paulcadman)</li> <li>Add newlines at end of JSON files #2360 (lukaszcz)</li> <li>Update the standard library to use the trait framework #2359 (lukaszcz)</li> <li>Remove duplicated implicit pattern check from scoper #2357 (paulcadman)</li> <li>Fix instance import #2350 (lukaszcz)</li> <li>Small refactor for traits #2345 (janmasrovira)</li> <li>Allow named arguments in type synonyms #2343 (janmasrovira)</li> <li>Improve formatting of single-constructor types and records #2342 (janmasrovira)</li> <li>Add Internet effect #2337 (janmasrovira)</li> <li>Global offline flag #2335 (paulcadman)</li> <li>New fixity/iterator syntax #2332 (janmasrovira)</li> <li>Add fixity face #2328 (janmasrovira)</li> <li>Generate html documentation for alias and fixity definitions #2327 (janmasrovira)</li> <li>Generate documentation for local modules in the html backend #2326 (janmasrovira)</li> <li>Generate function signatures in the html backend #2325 (janmasrovira)</li> <li>Add macchiato html theme #2323 (janmasrovira)</li> <li>Show all available html themes in the CLI automatically #2322 (janmasrovira)</li> <li>Add css colors <code>ju-comment</code> and <code>ju-judoc</code> #2321 (janmasrovira)</li> <li>Report termination errors after typechecking #2318 (janmasrovira)</li> <li>Install wasmer binary from Github releases #2317 (paulcadman)</li> <li>Fix record update formatting #2315 (lukaszcz)</li> <li>Fix record pattern formatting #2314 (lukaszcz)</li> <li>Update ci to use ormolu 0.5.3.0 and reformat project #2313 (janmasrovira)</li> <li>Add pragma face #2312 (janmasrovira)</li> <li>Remove <code>open import</code> syntax #2307 (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v043","title":"v0.4.3","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Allow wildcard arguments in new function definition syntax #2295 (lukaszcz)</li> <li>Allow omitting <code>: Type</code> in implicit function argument definitions and in type definitions #2291 (lukaszcz)</li> <li>Record patterns #2271 (janmasrovira)</li> <li>User-friendly operator declaration syntax #2270 (lukaszcz)</li> <li>Record updates #2263 (janmasrovira)</li> <li>Add field projections for records #2260 (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Fix shell variables in linux static build stack install #2309 (paulcadman)</li> <li>Replace gitrev with githash for obtaining build-time git info #2308 (paulcadman)</li> <li>Check that type functions are supported #2306 (janmasrovira)</li> <li>Minor comment updates #2303 (lukaszcz)</li> <li>Update stdlib to use new ADT and record syntax #2302 (paulcadman)</li> <li>Fix bug in arity checker with pi types #2300 (janmasrovira)</li> <li>Error on duplicate keys in YAML #2290 (lukaszcz)</li> <li>Check for incomparable precedences #2289 (lukaszcz)</li> <li>Prettyprint aggregate ADT constructor types with parentheses #2284 (paulcadman)</li> <li>Fixes behaviour of default stdlib when internal-build-flag is set #2283 (paulcadman)</li> <li>Enable builtin list syntax in the standard library #2282 (lukaszcz)</li> <li>Improve iterator and named arguments parsing #2278 (lukaszcz)</li> <li>Update stackage resolver to LTS 21.6 #2275 (paulcadman)</li> <li>Fix benchmark wasmer command #2268 (paulcadman)</li> <li>Disallow iterators with zero ranges #2267 (lukaszcz)</li> <li>Don't print pragmas in documentation #2266 (lukaszcz)</li> <li>Adt syntax #2262 (janmasrovira)</li> <li>Minor refactor and script update #2261 (lukaszcz)</li> <li>Separate modules namespace #2257 (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v042-2023-07-25","title":"v0.4.2 (2023-07-25)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Fold lets when the bound variable occurs at most once #2231 (lukaszcz)</li> <li>Case folding #2229 (lukaszcz)</li> <li>Specialization optimisation #2164 (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Refactor deriving statements in <code>Concrete.Language</code> #2256 (janmasrovira)</li> <li>Rename inductive constructor #2255 (janmasrovira)</li> <li>Add record declaration syntax #2254 (janmasrovira)</li> <li>Typcheck imports before statements #2253 (janmasrovira)</li> <li>Named arguments #2250 (janmasrovira)</li> <li>Format juvix files using new function syntax #2245 (janmasrovira)</li> <li>Update to GEB version 0.3.2 #2244 (lukaszcz)</li> <li>New syntax for function definitions #2243 (janmasrovira)</li> <li>Parse many consecutive <code>-</code> as a comment #2240 (janmasrovira)</li> <li>Add syntax for builtin list #2239 (janmasrovira)</li> <li>Fix bug in aritychecker #2238 (janmasrovira)</li> <li>Local pragmas improvements #2236 (lukaszcz)</li> <li>Fix bug in <code>computeTypeInfo</code> #2234 (lukaszcz)</li> <li>Numeric range types #2232 (lukaszcz)</li> <li>Use specialization pragmas in the standard library #2230 (lukaszcz)</li> <li>Fix de Bruijn indices in LetRecs #2227 (lukaszcz)</li> <li>Remove abstract #2219 (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v041-2023-06-23","title":"v0.4.1 (2023-06-23)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>The <code>public</code> pragma #2223 (lukaszcz)</li> <li>Local pragmas #2222 (lukaszcz)</li> <li>Lifting calls out of cases for the VampIR backend #2218 (lukaszcz)</li> <li>Use equality instead of less-equal when translating matching on Nats #2215 (lukaszcz)</li> <li>Support juvix format with no argument to format a project #2208 (paulcadman)</li> <li>Always print source of formatted file unless --check is specified #2205 (paulcadman)</li> <li>Improve iterator formatting and syntax #2204 (lukaszcz)</li> <li>Restrict permutative conversions on cases to non-booleans #2201 (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Build and cache smoke binary keyed using icu4c version #2221 (paulcadman)</li> <li>Switch to Halo2 for VampIR backend tests #2216 (lukaszcz)</li> <li>Remove Subtree sections, all collapse all button #2213 (vrom911)</li> <li>Fix <code>isNegative</code> in the VampIR runtime #2212 (lukaszcz)</li> <li>Use juvix-installer in CodeSpaces, install vamp-ir #2210 (vrom911)</li> <li>Move termination checker to Internal #2209 (janmasrovira)</li> <li>Propogate formatter results when traversing subdirs #2207 (paulcadman)</li> <li>Update vamp-ir CI installation #2199 (jonaprieto)</li> <li>More tests for the VampIR compilation pipeline #2197 (lukaszcz)</li> <li>Fix runtime C maybe benchmark example #2195 (paulcadman)</li> <li>Refactor isValidChar #2194 (jonaprieto)</li> <li>Check valid argument names in YAML #2193 (lukaszcz)</li> <li>Fix benchmark runtime C examples #2192 (paulcadman)</li> <li>Update to the new version of VampIR #2138 (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v040-prague-2023-06-02","title":"v0.4.0 - Prague! (2023-06-02)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Always print source of formatted file unless --check is specified #2173 (paulcadman)</li> <li>Improve parsing error messages #2170 (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Use stderr for errors in the runtime #2184 (lukaszcz)</li> <li>Change terminal colours to be more align with the scheme #2183 (vrom911)</li> <li>Respect fixity in runtime printer #2182 (lukaszcz)</li> <li>Format returns 0 when file is not formatted #2181 (vrom911)</li> <li>Print values in <code>juvix eval</code> #2179 (lukaszcz)</li> <li>Fix 'function not found' error in <code>juvix eval</code> #2178 (lukaszcz)</li> <li>Store source location of \\(almost\\) everything #2174 (janmasrovira)</li> <li>Do not filter unreachable symbols when compiling for REPL #2172 (paulcadman)</li> </ul>"},{"location":"CHANGELOG/#v035-2023-06-02","title":"v0.3.5 (2023-06-02)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Update standard library for better readability, efficiency and iterator use #2153 (lukaszcz)</li> <li>Use the<code>JUVIX_LLVM_DIST_PATH</code> environment variable to search for the clang executable #2152 (paulcadman)</li> <li>Finish the new pretty printing algorithm and delete the old one #2151 (janmasrovira)</li> <li>Add <code>:doc</code> command to the repl #2142 (janmasrovira)</li> <li>Allow to specify VampIR variable names #2141 (lukaszcz)</li> <li>VampIR pipeline: handle booleans in the type of <code>main</code> #2137 (lukaszcz)</li> <li>Add <code>main</code> field to <code>juvix.yaml</code> #2120 (janmasrovira)</li> <li>Add <code>:def</code> command to the repl #2119 (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Properly scan imports inside local modules #2165 (janmasrovira)</li> <li>Add extra git dependencies to <code>cabal.project</code> #2158 (janmasrovira)</li> <li>Support new <code>import ... open</code> syntax in REPL #2156 (paulcadman)</li> <li>Add the <code>format</code> pragma #2150 (lukaszcz)</li> <li>Remove code for <code>Eval</code> and <code>Print</code> statements #2149 (lukaszcz)</li> <li>Fix printing of infix constructor values #2144 (lukaszcz)</li> <li>Add <code>ValueType</code> #2143 (janmasrovira)</li> <li>Add <code>Semigroup</code> instance for <code>AnsiText</code> #2140 (janmasrovira)</li> <li>Show unicode characters without escaping #2127 (janmasrovira)</li> <li>Iterator syntax #2126 (lukaszcz)</li> <li>Fix spurious messages from Makefile.generic #2125 (lukaszcz)</li> <li>Add gnu-sed to the macOS build in the CI #2123 (jonaprieto)</li> <li>Fix baseUrl for juvix docs in Doctor command #2122 (vrom911)</li> <li>Remove --no-format option #2121 (vrom911)</li> <li>Add Bottom node #2112 (janmasrovira)</li> <li>VampIR integration #2103 (lukaszcz)</li> <li>Add VampIR to the CI #2096 (jonaprieto)</li> </ul>"},{"location":"CHANGELOG/#v034-2023-05-22","title":"v0.3.4 (2023-05-22)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Allow symbol renaming inside <code>using {..}</code> #2109 (janmasrovira)</li> <li>Scope check symbols inside <code>using {..}</code> and <code>hiding {..}</code> #2108 (janmasrovira)</li> <li>Pass through compile optimization flag to C compiler and disable optimization for --debug #2106 (paulcadman)</li> <li>Add syntax for Judoc blocks #2102 (janmasrovira)</li> <li>Add dangling judoc error #2099 (janmasrovira)</li> <li>Modify <code>open import</code> syntax #2098 (janmasrovira)</li> <li>Improve error message when input path doesn't exist #2092 (paulcadman)</li> <li>Partial incremental highlighting #2053 (janmasrovira)</li> <li>Normalization by Evaluation #2038 (lukaszcz)</li> <li>Inlining #2036 (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Use PrettyCode instance instead of obsolete ppUsingItem in Print.Base #2115 (janmasrovira)</li> <li>Add <code>syntax</code> keyword #2107 (lukaszcz)</li> <li>Simplify formatting of lambdas with a single clause #2105 (janmasrovira)</li> <li>Fix extra whitespace in text rendering of indented empty lines #2101 (paulcadman)</li> <li>Reachability analysis in Core #2097 (lukaszcz)</li> <li>Slightly improve prettyprinting for Core #2094 (janmasrovira)</li> <li>Bump to LTS Haskell 20.21 \\(ghc-9.2.7\\) #2093 (jonaprieto)</li> <li>Direct translation from normalized JuvixCore to VampIR #2086 (lukaszcz)</li> <li>ci: clean .juvix-build directory before formatting/typechecking examples #2079 (paulcadman)</li> <li>Fix format on projects that contain subprojects #2078 (paulcadman)</li> <li>Implement core transformation <code>let-hoisting</code> #2076 (janmasrovira)</li> <li>Allow nested block comments #2075 (janmasrovira)</li> <li>Fix topCommandInputFile for Format command #2063 (vrom911)</li> <li>Fix reachability analysis with imports in unreachable nested modules #2062 (lukaszcz)</li> <li>Fix devcontainer juvix install #2061 (paulcadman)</li> <li>Fix Makefile target bugs for formatting and type Checking Juvix files #2057 (jonaprieto)</li> <li>Fix a bug in the positivity checker \\(\\#1943\\) #2054 (jonaprieto)</li> <li>Arity check types and functions \\(-\\&gt;\\) #2049 (janmasrovira)</li> <li>Fix ordering of statements in Abstract -&gt; Internal #2040 (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v033-2023-05-08","title":"v0.3.3 (2023-05-08)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Update to latest stdlib #2048 (paulcadman)</li> <li>Support module imports in Juvix REPL #2029 (paulcadman)</li> <li>Make format command's filepath optional #2028 (vrom911)</li> <li>format long lambda clause body on a new line #2015 (paulcadman)</li> <li>Support more paths #2000 (janmasrovira)</li> <li>Add: pragma support #1997 (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Fix pipeline setup in the repl #2046 (janmasrovira)</li> <li>Fix HasExpressions ConstructorApp #2044 (paulcadman)</li> <li>Fix fromSource behaviour when both stdin and filename #2043 (vrom911)</li> <li>Return endLine info in highlighting command #2042 (vrom911)</li> <li>Enable self-application test #2041 (janmasrovira)</li> <li>Add bank example #2037 (janmasrovira)</li> <li>Substitute calls after lambda lifting #2031 (janmasrovira)</li> <li>Add delimiter face #2027 (janmasrovira)</li> <li>Propertly register top module name in scoper #2026 (janmasrovira)</li> <li>Add judoc code annotation and face #2025 (janmasrovira)</li> <li>Fix dependencies suggestion in missing module error #2024 (paulcadman)</li> <li>Remove docs related files #2023 (jonaprieto)</li> <li>Improve formatting of comments #2022 (janmasrovira)</li> <li>Support positive arity typealias in arity checker #2021 (paulcadman)</li> <li>Add format stdin smoke tests #2019 (vrom911)</li> <li>Add <code>juvix clean</code> to remove project build artifact directory #2018 (paulcadman)</li> <li>Sync stdlib #2012 (janmasrovira)</li> <li>Ide improvements #2009 (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v032-2023-04-18","title":"v0.3.2 (2023-04-18)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Qualified imports #2004 (janmasrovira)</li> <li>Pretty print JuvixCore values consistently with Juvix syntax #1988 (lukaszcz)</li> <li>Add: the 'seq' builtin \\(\\&gt;\\&gt;\\&gt;\\) #1982 (lukaszcz)</li> <li>Fix: pprint positive kw for data types #1980 (jonaprieto)</li> <li>Fix: format juvix files in test/positive #1978 (jonaprieto)</li> <li>Add syntax highlighting for juvix code blocks in docs #1971 (jonaprieto)</li> <li>Add juvix global project under xdg directory and other improvements #1963 (janmasrovira)</li> <li>Add builtin integer type to the surface language #1948 (paulcadman)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Preserve escaped \" in String literals #2011 (paulcadman)</li> <li>Fix: broken links of Example programs #2003 (jonaprieto)</li> <li>Write compile output file to invoke dir by default #1999 (paulcadman)</li> <li>Add minor improvements to the docs #1995 (vrom911)</li> <li>ci: Specify llvm version in brew prefix command #1990 (paulcadman)</li> <li>Fix location for case expressions #1987 (lukaszcz)</li> <li>Fix: add supported targets as option for compile commands #1983 (jonaprieto)</li> <li>Fix: Stop 'make check' at first failure #1981 (jonaprieto)</li> <li>Test numbering #1977 (lukaszcz)</li> <li>Refactor Core datastructures #1975 (lukaszcz)</li> <li>Add Juvix to all benchmarks #1974 (lukaszcz)</li> <li>Check for the executable \\(WASM/native\\) pipeline prerequisites #1970 (lukaszcz)</li> <li>Print quoted strings in the runtime #1969 (lukaszcz)</li> <li>Update the tutorial #1967 (lukaszcz)</li> <li>Fix PrettyCode \\(Maybe a\\) instance \"Just\" case #1966 (paulcadman)</li> <li>Documentation for projects and modules #1962 (janmasrovira)</li> <li>repl: Run disambiguateNames on result node #1961 (paulcadman)</li> <li>Add FoldTypeSynonyms Transformation to Geb Pipeline and more Geb Tests #1956 (lukaszcz)</li> <li>Support local modules #1872 (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v031-2023-03-31","title":"v0.3.1 (2023-03-31)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Option <code>--show-args-num</code> #1946   (lukaszcz)</li> <li>Preserve the target type in letrec lifting   #1945   (janmasrovira)</li> <li>Add syntax highlighting to Core error messages   #1938   (lukaszcz)</li> <li>Add the <code>--unroll</code> option   #1935   (lukaszcz)</li> <li>Preserve name and location information in Internal-to-Core   #1933   (lukaszcz)</li> <li>Polymorphic type inference in Core   #1931   (lukaszcz)</li> <li>Update README.md with Juvix nightly builds badge   #1923   (jonaprieto)</li> <li>Create clean-up-cache.yaml   #1915   (jonaprieto)</li> <li>Update GitHub pages deployment using deploy-pages action   #1910   (jonaprieto)</li> <li>Check for recursive inductive types in the GEB pipeline   #1909   (lukaszcz)</li> <li>CI pre-commit maintenance   #1905   (jonaprieto)</li> <li>Add new README and md files   #1904   (jonaprieto)</li> <li>Print JuvixCore correctly   #1875   (lukaszcz)</li> <li>Pattern matching compilation   #1874   (lukaszcz)</li> <li>CI Haskell maintenance   #1797   (jonaprieto)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Let-folding after lifting   #1955   (lukaszcz)</li> <li>Fix removal of polymorphic type arguments   #1954   (lukaszcz)</li> <li>Fix a bug in closure traversal   #1953   (lukaszcz)</li> <li>Update typecheck command to check for coverage   #1952   (janmasrovira)</li> <li>CI: Ignore errors linux typecheck / format examples step   #1950   (paulcadman)</li> <li>Filter out type synonyms in RemoveTypeArgs   #1949   (lukaszcz)</li> <li>Add fail nodes to Geb   #1947   (lukaszcz)</li> <li>End-to-end Geb compilation tests   #1942   (lukaszcz)</li> <li>Add juvix dev repl command   #1941   (paulcadman)</li> <li>Refactor Geb values   #1940   (lukaszcz)</li> <li>Avoid capturing the same free variable multiple times in letrec lifting   #1939   (janmasrovira)</li> <li>Add Judoc syntax reference   #1934   (janmasrovira)</li> <li>Fix spacing of judoc in the formatter   #1932   (janmasrovira)</li> <li>bench: Fix juvix compile flag for wasm   #1925   (paulcadman)</li> <li>Fix memory count for string operations   #1924   (lukaszcz)</li> <li>Let folding   #1921   (lukaszcz)</li> <li>Add a test suite for milestone examples   #1920   (paulcadman)</li> <li>Add --numeric-version flag   #1918   (jonaprieto)</li> <li>Fix bug with unregistered builtin bool   #1917   (lukaszcz)</li> <li>Recursion unrolling for functions   #1912   (lukaszcz)</li> <li>Fix REPL state to include enough information to rerun the pipeline   #1911   (janmasrovira)</li> <li>CI Haskell fix for macOS build   #1908   (jonaprieto)</li> <li>Fix bug in IO runtime   #1906   (lukaszcz)</li> <li>Fix JuvixAsm validation   #1903   (lukaszcz)</li> <li>Fix registration of builtin inductive axioms   #1901   (paulcadman)</li> <li>internal-to-core: Fix index shifting of pattern arguments   #1900   (paulcadman)</li> <li>Fix de Bruijn indices in rmap   #1898   (lukaszcz)</li> <li>Normalize types in repl   #1897   (janmasrovira)</li> <li>Add MidSquareHash.juvix and fix types in MidSquareHash.jvc   #1896   (lukaszcz)</li> <li>Automatically detect and split mutually recursive blocks in let expressions   #1894   (janmasrovira)</li> <li>The <code>rmap</code> recursor   #1893   (lukaszcz)</li> <li>Add <code>juvix format</code> command   #1886   (paulcadman)</li> <li>Make keyword <code>end</code> optional for top modules   #1883   (janmasrovira)</li> <li>Add errors to the Core pipeline and check GEB prerequisites   #1871   (lukaszcz)</li> <li>Test core to geb translation   #1865   (jonaprieto)</li> </ul>"},{"location":"CHANGELOG/#v030-2023-03-15","title":"v0.3.0 (2023-03-15)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Avoid line breaks in applications within a type signature   #1850   (paulcadman)</li> <li>Respect user's spacing decisions in the formatter   #1837   (janmasrovira)</li> <li>Formatter should not transform ASCII symbols to unicode by default   #1827   (janmasrovira)</li> <li>Enable match-to-case, nat-to-int and convert-builtins by default in   REPL #1825   (lukaszcz)</li> <li>The Juvix formatter works poorly with multi-line ifs   #1793   (janmasrovira)</li> <li>Add a lazy IO sequencing function (#1772)   #1773   (lukaszcz)</li> <li>Support LetRec in the GEB backend   #1756   (janmasrovira)</li> <li>Support integers in the GEB backend   #1753   (lukaszcz)</li> <li>GEB evaluator #1751   (jonaprieto)</li> <li>Add debugging builtin functions   #1731   (jonaprieto)</li> <li>Non-judoc comments are removed when generating HTML output   #1723   (janmasrovira)</li> <li>Special syntax for <code>case</code> #1716   (janmasrovira)</li> <li>Make || and &amp;&amp; lazy   #1701   (lukaszcz)</li> <li>It should be possible to specify multiple implicit type arguments at   once #1692   (janmasrovira)</li> <li>Naive compilation of complex pattern matches with match-expressions   to decision trees with case-expressions   #1531   (paulcadman)</li> <li>New compilation pipeline   #1832   (lukaszcz)</li> <li>Add internal core-eval option to evaluate named function identifier   #1819   (paulcadman)</li> <li>Short syntax for sequences of function and datatype parameters   #1809   (lukaszcz)</li> <li>Add Geb Backend Evaluator with some extra subcommands   #1808   (jonaprieto)</li> <li>Add REPL option to apply Core transformations   #1796   (paulcadman)</li> <li>String builtins #1784   (lukaszcz)</li> <li>Use restore/save github action to speed up the CI testing   #1783   (jonaprieto)</li> <li>Fix minor issue with ==% for type equality   #1780   (jonaprieto)</li> <li>Add debugging builtin functions <code>trace</code> and <code>fail</code> #1771   (jonaprieto)</li> <li>Keep regular comments in html output   #1766   (janmasrovira)</li> <li>Lazy boolean operators   #1743   (lukaszcz)</li> <li>Refactor <code>html</code> command with extra options   #1725   (jonaprieto)</li> <li>Add initial setup for codespaces   #1713   (jonaprieto)</li> <li>Typecheck let expressions   #1712   (janmasrovira)</li> <li>Use Smoke instead of shelltestrunner   #1710   (jonaprieto)</li> <li>Replace \u2013output-dir flag by \u2013internal-build-dir   #1707   (jonaprieto)</li> <li>Compiler output #1705   (jonaprieto)</li> <li>Allow optional pipe before the first constructor for inductive type   declarations #1699   (jonaprieto)</li> <li>Nat builtins #1686   (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Remove dead code in <code>Internal</code> #1891   (janmasrovira)</li> <li>Remove missing Juvix examples and webapp example from docs build   #1890   (paulcadman)</li> <li>Fix type synonym in let   #1880   (janmasrovira)</li> <li>Update stack resolver to lts-20.12   #1873   (paulcadman)</li> <li>Use Ape to format patterns   #1870   (janmasrovira)</li> <li>Fix Core-To-Geb translation   #1863   (jonaprieto)</li> <li>Remove the old C backend   #1862   (lukaszcz)</li> <li>Move <code>substEnv</code> to its own module   #1861   (janmasrovira)</li> <li>Add <code>_caseTypeWholeExpression</code> to Internal   #1860   (janmasrovira)</li> <li>remove old minihaskell files   #1859   (jonaprieto)</li> <li>Fix bugs in the Case translation in Core-to-Geb   #1858   (lukaszcz)</li> <li>Format examples #1856   (janmasrovira)</li> <li>Sort the identifiers topologically in the Core-to-GEB translation   #1854   (lukaszcz)</li> <li>Add type info to the mid-square hashing function   #1853   (lukaszcz)</li> <li>Use APE mechanism to format Function expressions   #1852   (paulcadman)</li> <li>Preserve single wildcards pretty printing function parameters   #1851   (paulcadman)</li> <li>Add type annotation to case expression   #1849   (janmasrovira)</li> <li>Remove module parameters   #1848   (janmasrovira)</li> <li>Allow shadowing local variables with let function definitions   #1847   (janmasrovira)</li> <li>Add lambda type info   #1845   (janmasrovira)</li> <li>Improve comma formatting   #1842   (janmasrovira)</li> <li>Improve formatter #1840   (janmasrovira)</li> <li>Respect lambda Ascii/Unicode   #1838   (janmasrovira)</li> <li>Fix <code>juvix init</code> #1835   (janmasrovira)</li> <li>The formatter respects the ascii function arrow   #1834   (janmasrovira)</li> <li>Add <code>dev core from-concrete</code> command   #1833   (janmasrovira)</li> <li>Give proper errors for incorrect application of lazy builtins   #1830   (lukaszcz)</li> <li>Documentation: update language reference   #1829   (lukaszcz)</li> <li>Add compilation of complex pattern matching to case   #1824   (paulcadman)</li> <li>Apply CI ghcup workaround to docs build   #1823   (paulcadman)</li> <li>Update the Juvix tutorial for 0.3   #1822   (lukaszcz)</li> <li>Workaround ghcup issue on CI runner   #1821   (paulcadman)</li> <li>Respect the <code>juvix dev highlight --format</code> flag when outputting   errors #1820   (janmasrovira)</li> <li>Comments about the usage of the JuvixCore recursors   #1818   (lukaszcz)</li> <li>Emacs mode and VSCode extension tutorials   #1815   (lukaszcz)</li> <li>Documentation: how to compile Juvix programs   #1813   (lukaszcz)</li> <li>Make '&gt;&gt;' lazy #1812   (lukaszcz)</li> <li>Output proper GEB Lisp programs   #1810   (lukaszcz)</li> <li>Remove the usage annotation syntax   #1805   (lukaszcz)</li> <li>Mid-square hashing implemented in JuvixCore   #1804   (lukaszcz)</li> <li>Autocompletion for <code>dev core compilation --target</code> #1803   (janmasrovira)</li> <li>Special syntax for case   #1800   (janmasrovira)</li> <li>Adapt benchmarks to the new pipeline   #1795   (lukaszcz)</li> <li>Support letrec lifting without lambda lifting   #1794   (janmasrovira)</li> <li>Use the reader effect   #1791   (janmasrovira)</li> <li>Remove braces from let expressions   #1790   (janmasrovira)</li> <li>Translate as-pattern binders to Core PatternBinders   #1789   (paulcadman)</li> <li>Fix termination with as-patterns   #1787   (janmasrovira)</li> <li>Allow type signatures to have a body   #1785   (janmasrovira)</li> <li>Track builtins in the Core InfoTable   #1782   (paulcadman)</li> <li>Pipes for lambda clauses   #1781   (janmasrovira)</li> <li>Support integers in the GEB backend   #1778   (lukaszcz)</li> <li>Add builtin nat and bool types as start nodes in reachability   analysis #1775   (paulcadman)</li> <li>Update pre-commit #1772   (jonaprieto)</li> <li>Parse JuvixCore with absolute paths   #1770   (paulcadman)</li> <li>Use absolute path in Core Evaluator to generate source file location   #1769   (paulcadman)</li> <li>Install wasmer binary from Github releases   #1765   (jonaprieto)</li> <li>Run the new Juvix formatter for all the Juvix examples   #1764   (jonaprieto)</li> <li>Fix let expressions in the repl   #1763   (janmasrovira)</li> <li>Improve arity inference for repl expressions   #1762   (janmasrovira)</li> <li>Fix broken links and other improvements   #1761   (jonaprieto)</li> <li>Translate Nat builtins to the correct Core Ops   #1760   (paulcadman)</li> <li>Remove hlint from the CI and pre-commit config   #1759   (jonaprieto)</li> <li>Fix demo example build   #1757   (paulcadman)</li> <li>Basic Geb integration   #1748   (lukaszcz)</li> <li>Fix macOS CI build #1747   (paulcadman)</li> <li>Adapt Juvix programs to the new pipeline   #1746   (lukaszcz)</li> <li>Fix link in README for the new docs   #1745   (lukaszcz)</li> <li>Move juvix-mode to a separate repository   #1744   (jonaprieto)</li> <li>Print comments when pretty printing concrete syntax   #1737   (janmasrovira)</li> <li>Demo #1736   (lukaszcz)</li> <li>Update CI to install Smoke, Github actions, and Makefile fixes   #1735   (jonaprieto)</li> <li>Update stack.yaml #1734   (jonaprieto)</li> <li>Fix Nat builtins #1733   (lukaszcz)</li> <li>Script to count LOC   #1732   (lukaszcz)</li> <li>Give a proper type to literal Strings   #1730   (paulcadman)</li> <li>Do not filter implicit args in internal to core translation   #1728   (paulcadman)</li> <li>Fix de Brujin indexing of lambda arguments   #1727   (paulcadman)</li> <li>Fix inference loop #1726   (janmasrovira)</li> <li>Remove wildcard patterns from Internal   #1724   (janmasrovira)</li> <li>Restructure the documentation and add a tutorial   #1718   (lukaszcz)</li> <li>Improve error message for confusing ':=' with '='   #1715   (lukaszcz)</li> <li>Fix #1704 #1711   (janmasrovira)</li> <li>Fix #1693 #1708   (janmasrovira)</li> <li>Tests for the new compilation pipeline   #1703   (lukaszcz)</li> <li>Add printString and printBool support to legacy C backend   #1698   (paulcadman)</li> <li>Add \u2013show-de-bruijn option to <code>juvix repl</code> #1694   (lukaszcz)</li> <li>Allow 'terminating' keyword with builtins   #1688   (lukaszcz)</li> <li>Remove unicode cons symbol   #1687   (lukaszcz)</li> <li>Change syntax for ind. data types and forbid the empty data type   #1684   (jonaprieto)</li> <li>Convert Nat literals to Core integers   #1681   (lukaszcz)</li> <li>Less verbose output from running <code>make check</code> #1675   (jonaprieto)</li> <li>Remove where syntax   #1674   (jonaprieto)</li> <li>Benchmarks #1673   (janmasrovira)</li> <li>JuvixCore to JuvixAsm translation   #1665   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v029-2023-01-18","title":"v0.2.9 (2023-01-18)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Refactor <code>html</code> command with extra options   #1725   (jonaprieto)</li> <li>Add initial setup for codespaces   #1713   (jonaprieto)</li> <li>Typecheck let expressions   #1712   (janmasrovira)</li> <li>Use Smoke instead of shelltestrunner   #1710   (jonaprieto)</li> <li>Replace \u2013output-dir flag by \u2013internal-build-dir   #1707   (jonaprieto)</li> <li>Compiler output #1705   (jonaprieto)</li> <li>Allow optional pipe before the first constructor for inductive type   declarations #1699   (jonaprieto)</li> <li>Nat builtins #1686   (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Demo #1736   (lukaszcz)</li> <li>Update stack.yaml #1734   (jonaprieto)</li> <li>Fix Nat builtins #1733   (lukaszcz)</li> <li>Script to count LOC   #1732   (lukaszcz)</li> <li>Give a proper type to literal Strings   #1730   (paulcadman)</li> <li>Do not filter implicit args in internal to core translation   #1728   (paulcadman)</li> <li>Fix de Brujin indexing of lambda arguments   #1727   (paulcadman)</li> <li>Fix inference loop #1726   (janmasrovira)</li> <li>Remove wildcard patterns from Internal   #1724   (janmasrovira)</li> <li>Restructure the documentation and add a tutorial   #1718   (lukaszcz)</li> <li>Improve error message for confusing ':=' with '='   #1715   (lukaszcz)</li> <li>Fix #1704 #1711   (janmasrovira)</li> <li>Fix #1693 #1708   (janmasrovira)</li> <li>Tests for the new compilation pipeline   #1703   (lukaszcz)</li> <li>Add printString and printBool support to legacy C backend   #1698   (paulcadman)</li> <li>Add \u2013show-de-bruijn option to <code>juvix repl</code> #1694   (lukaszcz)</li> <li>Allow 'terminating' keyword with builtins   #1688   (lukaszcz)</li> <li>Remove unicode cons symbol   #1687   (lukaszcz)</li> <li>Change syntax for ind. data types and forbid the empty data type   #1684   (jonaprieto)</li> <li>Convert Nat literals to Core integers   #1681   (lukaszcz)</li> <li>Less verbose output from running <code>make check</code> #1675   (jonaprieto)</li> <li>Remove where syntax   #1674   (jonaprieto)</li> <li>Benchmarks #1673   (janmasrovira)</li> <li>JuvixCore to JuvixAsm translation   #1665   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v028-2022-12-20","title":"v0.2.8 (2022-12-20)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Support basic dependencies   #1622   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Refactor hie.yaml and add entry in the readme   #1672   (janmasrovira)</li> <li>Fix inline monospace formatted text in README   #1671   (paulcadman)</li> <li>Pin mdbook to version 0.4.22 in docs build   #1670   (paulcadman)</li> <li>Add option to specify Core transformations to   <code>dev internal core-eval</code> #1669   (paulcadman)</li> <li>Revert \"Ignore binaries generated by running some tests\"   #1668   (jonaprieto)</li> <li>Add configuration files so the project can be built with cabal   #1667   (paulcadman)</li> <li>Add documentation for compiling/running the TicTacToe example   #1664   (paulcadman)</li> <li>Ignore binaries generated by running some tests   #1663   (jonaprieto)</li> <li>Conversion of Nat representation to JuvixCore integers   #1661   (lukaszcz)</li> <li>Move applications inside Lets and Cases   #1659   (lukaszcz)</li> <li>Run shelltests on macOS build   #1658   (paulcadman)</li> <li>Restore macOS CI build/test   #1657   (paulcadman)</li> <li>Remove type arguments and type abstractions from Nodes   #1655   (lukaszcz)</li> <li>Pretty printing of JuvixAsm code   #1650   (lukaszcz)</li> <li>Remove NameId from Core   #1649   (lukaszcz)</li> <li>Translation from JuvixAsm to C   #1619   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v027-2022-12-05","title":"v0.2.7 (2022-12-05)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add juvix-repl-mode for emacs   #1612   (paulcadman)</li> <li>Make lambda lifting correct when free variables occur in the types   of binders #1609   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Files pure refactor   #1652   (janmasrovira)</li> <li>Use the same stack version in all CI jobs and remove <code>stack setup</code>   step #1651   (paulcadman)</li> <li>Fix 'not a primitive type' error message   #1648   (lukaszcz)</li> <li>Upgrade stack snapshot to use ghc-9.2.5   #1621   (janmasrovira)</li> <li>Add an emacs function to restart the REPL   #1618   (paulcadman)</li> <li>Add types to Core functions and constructors when translating from   Internal #1617   (paulcadman)</li> <li>Auto complete argument of 'dev core read -t'   #1616   (janmasrovira)</li> <li>Compute new entrypoint root when loading a file in the REPL   #1615   (paulcadman)</li> <li>Compute maximum runtime stack height in JuvixReg   #1613   (lukaszcz)</li> <li>Remove shelltest threading   #1611   (paulcadman)</li> <li>Use StackInfo and recurseS in the JuvixAsm to JuvixReg translation.   #1610   (lukaszcz)</li> <li>Precompute maximum heap allocation   #1608   (lukaszcz)</li> <li>Improvements to Juvix REPL   #1607   (paulcadman)</li> <li>Fix discrepancy between Juvix and WASM pages   #1605   (lukaszcz)</li> <li>Compute JuvixAsm stack usage info   #1604   (lukaszcz)</li> <li>Improve As-Pattern parsing   #1603   (ii8)</li> <li>Juvix core recursors should descend into nodes stored in infos   #1600   (janmasrovira)</li> <li>Add docs for installing the linux binary   #1599   (paulcadman)</li> <li>Binder refactor #1598   (janmasrovira)</li> <li>Juvix C runtime #1580   (lukaszcz)</li> <li>As-patterns #1576   (ii8)</li> <li>Eta expansion at the top of each core function definition (#1481)   #1571   (janmasrovira)</li> <li>Add translation from Internal to Core   #1567   (paulcadman)</li> </ul>"},{"location":"CHANGELOG/#v026-2022-10-26","title":"v0.2.6 (2022-10-26)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Support go to definition for the standard library   #1592   (paulcadman)</li> <li>Add builtin if #1585   (paulcadman)</li> <li>Add builtin boolean   #1582   (paulcadman)</li> <li>Add lambda expressions to internal and add typechecking support   #1538   (janmasrovira)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix arity checker bug   #1546   (janmasrovira)</li> <li>Look in patterns when building the dependency graph   #1536   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update language reference to match current state of Juvix   #1594   (paulcadman)</li> <li>Fix letrec printing   #1591   (janmasrovira)</li> <li>Update stdlib submodule with builtin changes   #1589   (paulcadman)</li> <li>Rename builtin natural to nat and boolean to bool   #1588   (paulcadman)</li> <li>Improve the test for eta-expansion of constructors and builtins   #1583   (lukaszcz)</li> <li>Properly newline expressions in the pretty printer   #1581   (janmasrovira)</li> <li>Letrec lifting #1579   (janmasrovira)</li> <li>Add softlines between applications and hang definitions   #1578   (janmasrovira)</li> <li>Parse optional type info in JVC files   #1575   (lukaszcz)</li> <li>Fix symbol numbering bug   #1574   (lukaszcz)</li> <li>1569 rewrite the test for lambda lifting to use evaluation   #1572   (janmasrovira)</li> <li>Remove lambda from reservedSymbols   #1568   (lukaszcz)</li> <li>Keywords refactor #1566   (janmasrovira)</li> <li>remove \u2254 from the language and replace it by :=   #1563   (janmasrovira)</li> <li>JuvixReg #1551   (lukaszcz)</li> <li>Remove duplicate function in concrete analysis   #1550   (ii8)</li> <li>Evaluator minor style refactor   #1547   (janmasrovira)</li> <li>Properly handle top lambdas in the termination checker   #1544   (janmasrovira)</li> <li>Mutual inference #1543   (janmasrovira)</li> <li>Autocomplete \".jvc\" input files for core {eval, read} commands   #1542   (paulcadman)</li> <li>Add \u2013show-de-bruijn to <code>core eval</code> command   #1540   (paulcadman)</li> <li>Inductive types should depend on the types of their constructors   #1537   (lukaszcz)</li> <li>Parser labels #1535   (janmasrovira)</li> <li>JuvixAsm #1432   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v025-2022-09-14","title":"v0.2.5 (2022-09-14)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Properly type check patterns that need normalization   #1472   (janmasrovira)</li> <li>Detect nested patterns as smaller in the termination checker   #1524</li> <li>Fix developBeta in Core/Extra.hs   #1487   (lukaszcz)</li> <li>Core/Extra/Recursors/Collector bugfix   #1510   (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Replace -&gt; by := in lambda syntax   #1533   (janmasrovira)</li> <li>'Match' with complex patterns in Core   #1530   (lukaszcz)</li> <li>Refactor CLI #1527   (janmasrovira)</li> <li>Add CanonicalProjection   #1526   (janmasrovira)</li> <li>Make comma a delimiter   #1525   (lukaszcz)</li> <li>Detect nested patterns as smaller in the termination checker   #1524   (janmasrovira)</li> <li>Disallow tab characters as spaces   #1523   (janmasrovira)</li> <li>Refactor <code>destruct</code> in Core/Extra/Base   #1522   (lukaszcz)</li> <li>JuvixCore primitive types   #1521   (lukaszcz)</li> <li>Enable autocompletion for the \u2013theme flag   #1519   (janmasrovira)</li> <li>Stripped version of Core Node datatype   #1518   (lukaszcz)</li> <li>Add <code>internal core read</code> command   #1517   (janmasrovira)</li> <li>Implement some instances for BinderList   #1515   (janmasrovira)</li> <li>Back recursor types with type families   #1514   (janmasrovira)</li> <li>Eager evaluation of Constr arguments   #1513   (lukaszcz)</li> <li>Dynamic type in Core   #1508   (lukaszcz)</li> <li>LetRec in Core #1507   (lukaszcz)</li> <li>Add Haddock and Agda licenses   #1506   (janmasrovira)</li> <li>Fix docs webapp examples CI build   #1505   (paulcadman)</li> <li>Add CLI usage examples doc and integrate with README   #1504   (paulcadman)</li> <li>Refactor BinderInfo   #1503   (lukaszcz)</li> <li>Make <code>juvix compile</code> default to native target   #1502   (paulcadman)</li> <li>Refactor Node datatype   #1501   (lukaszcz)</li> <li>Clean up import list in Pipeline   #1499   (jonaprieto)</li> <li>Remove mono #1497   (jonaprieto)</li> <li>Remove Haskell support   #1496   (jonaprieto)</li> <li>Implement lambda lifting   #1494   (janmasrovira)</li> <li>Document Emacs installation and the 'exec-path' problem   #1493   (lukaszcz)</li> <li>Add \u2013allow-different-user to workflow stack command   #1492   (paulcadman)</li> <li>Stack with github actions permissions workaround   #1490   (paulcadman)</li> <li>Restructure recursors and add some lens interfaces   #1489   (janmasrovira)</li> <li>Add a github action to build a static linux binary   #1488   (paulcadman)</li> <li>Fix developBeta in Core/Extra.hs   #1487   (lukaszcz)</li> <li>Add an option to show name ids in errors   #1486   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v024-2022-08-19","title":"v0.2.4 (2022-08-19)","text":"<p>Full Changelog</p> <p>(Special version for Heliax's retreat in Italy)</p> <p>Implemented enhancements:</p> <ul> <li>Add \u2013stdin flag #1459   (janmasrovira)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix typechecker #1458   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>use \u2013stdin in flycheck mode   #1460   (janmasrovira)</li> <li>Add a native compile target for demos   #1457   (paulcadman)</li> <li>Small changes for the presentation   #1456   (jonaprieto)</li> <li>Fixes TicTacToe Web example   #1454   (paulcadman)</li> <li>Upgrade to ghc-9.2.4   #1451   (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v023-2022-08-15","title":"v0.2.3 (2022-08-15)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>add <code>name</code> and <code>version</code> to <code>juvix.yaml</code> #1422   (janmasrovira)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Properly handle paragraphs in judoc   #1447   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Give a proper type to literal natural numbers   #1453   (janmasrovira)</li> <li>Add the option to output json in the <code>juvix internal highlight</code>   command #1450   (janmasrovira) for supporting the   new Juvix Mode for Visual Studio Code   (jonaprieto)</li> <li>Allow _ in Wasm exported names to support Anoma signature   #1449   (paulcadman)</li> <li>Add Towers of Hanoi and Pascal triangle examples   #1446   (paulcadman)</li> <li>Add <code>juvix init</code> command   #1445   (janmasrovira)</li> <li>Refactor pretty to reduce duplication   #1443   (janmasrovira)</li> <li>Add initial support for examples in Html documentation   #1442   (janmasrovira)</li> <li>Add revisions to README   #1440   (jonaprieto)</li> <li>CI: Run build on push to main   #1437   (paulcadman)</li> <li>Add doctor subcommand   #1436   (paulcadman)</li> <li>CI checkout repo before cache and use recommended cache strategy   #1435   (paulcadman)</li> <li>Various documentation adjustments   #1434   (paulcadman)</li> <li>Setup Clang before building docs in CI   #1433   (paulcadman)</li> <li>Major revisions to Makefile   #1431   (jonaprieto)</li> <li>Do not add <code>-src</code> suffix to links in HTML when running <code>juvix html</code> #1429   (paulcadman)</li> <li>Add a Web version of TicTacToe   #1427   (paulcadman)</li> <li>WASM import all non-compile axioms with alphanum names in entrypoint   #1426   (paulcadman)</li> <li>Export all functions with alpha numeric names from entrypoint module   #1425   (paulcadman)</li> <li>Refactor #1420   (jonaprieto)</li> <li>Permit axiom without a compile block   #1418   (paulcadman)</li> <li>Implement an html documentation generator similar to haddock (#1413)   #1416   (janmasrovira)</li> <li>Fix version shell test for 0.2.2   #1415   (paulcadman)</li> <li>Remove Int from stdlib and update SimpleFungibleToken example   #1414   (paulcadman)</li> </ul>"},{"location":"CHANGELOG/#v022-2022-07-25","title":"v0.2.2 (2022-07-25)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Compute name dependency graph and filter unreachable definitions   #1408   (lukaszcz)</li> <li>Support type aliases   #1404   (janmasrovira)</li> <li>Add debugging custom function to Prelude   #1401   (jonaprieto)</li> <li>Add positivity check for data types   #1393   (jonaprieto)</li> <li>Keep qualified names   #1392   (janmasrovira)</li> <li>Direct translation from MicroJuvix to MiniC   #1386   (lukaszcz)</li> <li>Widens the accepted symbol list   #1385   (mariari)</li> <li>Check all the type parameter names are different when declaring an   inductive type #1377   (jonaprieto)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Curly braces are allowed nested in patterns   #1380   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Add <code>Fail</code> effect (#1409)   #1411   (janmasrovira)</li> <li>Refactor of typechecking and other checking processes   #1410   (jonaprieto)</li> <li>Use bold for code in scoper error messages   #1403   (janmasrovira)</li> <li>Replace ppSimple by text   #1402   (jonaprieto)</li> <li>Implement some error messages (#1396)   #1400   (lukaszcz)</li> <li>Refactor childs of pattern parentheses and braces   #1398   (janmasrovira)</li> <li>Update Juvix standard-library   #1389   (jonaprieto)</li> <li>Fix documentation generation   #1387   (jonaprieto)</li> <li>Adds Collatz sequence generator example   #1384   (paulcadman)</li> <li>html-examples #1381   (jonaprieto)</li> <li>Refine hole in type signature to function type   #1379   (janmasrovira)</li> <li>Type checking fails when the type of a pattern is not given by the   signature #1378   (janmasrovira)</li> <li>Set cname for gh-pages action   #1376   (paulcadman)</li> <li>Add fibonacci sequence example program   #1375   (paulcadman)</li> <li>Fix Changelog links and minors   #1371   (jonaprieto)</li> <li>Add Version number to the emacs mode   #1320   (mariari)</li> </ul>"},{"location":"CHANGELOG/#new-name-juvix","title":"New name: Juvix","text":"<p>Since version 0.2.2, the project has been renamed from \"Mini Juvix\" to \"Juvix\". The new name reflects the fact that the project is no longer just a compiler for a subset of Juvix, but a full implementation of the language. Affected by this change are:</p> <ul> <li>Github repository moved from the Heliax organization to the Anoma   organization. \"anoma/juvix\" is the new repository name.</li> <li>All references to \"Mini Juvix\" have been replaced with \"Juvix\".   Unfortunetly,</li> </ul> <p>due to the move, the old links to the Mini Juvix repository are broken and will not be fixed.</p>"},{"location":"CHANGELOG/#v021-2022-07-12","title":"v0.2.1 (2022-07-12)","text":"<p>Implemented enhancements:</p> <ul> <li>Specialize commands of/for internal use MiniJuvix-#270   (jonaprieto)</li> <li>Improve handling of location information for different objs   MiniJuvix-#263 (jonaprieto)</li> <li>Add issues and PR templates MiniJuvix-#261   (jonaprieto)</li> <li>Throw error when reading a file that conflicts with embedded stdlib   MiniJuvix-#243 (paulcadman)</li> <li>Embed standard library in the minijuvix binary MiniJuvix-#210   (paulcadman)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fixed a bug with the path to walloc.c MiniJuvix-#237   (lukaszcz)</li> <li>Perform ScopedToAbstract exactly once for each module MiniJuvix-#223   (paulcadman)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Label renaming MiniJuvix-#275   (jonaprieto)</li> <li>Update link to discord MiniJuvix-#264   (Romainua)</li> <li>Include <code>open import</code> statements when generating HTML MiniJuvix-#260   (paulcadman)</li> <li>Renaming MiniJuvix to Juvix MiniJuvix-#259   (jonaprieto)</li> <li>Updates tests to use the updated standard library MiniJuvix-#253   (paulcadman)</li> <li>Enforce C99 standard in the generated C files MiniJuvix-#252   (lukaszcz)</li> <li>Restore mascot images to the minijuvix book MiniJuvix-#250   (paulcadman)</li> <li>Allow jumping to another module in emacs MiniJuvix-#249   (janmasrovira)</li> <li>Restore Juvix mascot image to README MiniJuvix-#248   (paulcadman)</li> <li>Add emacs option <code>minijuvix-disable-embedded-stdlib</code> MiniJuvix-#247   (paulcadman)</li> <li>Deprecate GHC backend MiniJuvix-#244   (lukaszcz)</li> <li>Removed 'eval' and 'print' keywords (#214) MiniJuvix-#242   (lukaszcz)</li> <li>Add option to disable minijuvix input method MiniJuvix-#239   (janmasrovira)</li> <li>Remove the 'match' keyword MiniJuvix-#238   (lukaszcz)</li> <li>Removed tests/positive/HelloWorld.mjuvix and specified clang version   in the documentation MiniJuvix-#236   (lukaszcz)</li> <li>Filter symbol entries properly in the scoper MiniJuvix-#234   (janmasrovira)</li> <li>Use the ModulesCache for <code>open</code> statements in ScopedToAbstract pass   MiniJuvix-#224 (paulcadman)</li> <li>README: Include <code>--recursive</code> in git clone command to fetch stdlib   MiniJuvix-#211 (paulcadman)</li> <li>Update project description v0.2.0 MiniJuvix-#209   (jonaprieto)</li> <li>Unify AST representation of types and expressions in MicroJuvix   MiniJuvix-#188 (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-06-28","title":"v0.2.0 (2022-06-28)","text":"<p>Implemented enhancements:</p> <ul> <li>Support built in types MiniJuvix-#192   (janmasrovira)</li> <li>Support partial application and closure passing in C backend   MiniJuvix-#190 (paulcadman)</li> <li>Allow <code>open import</code> statements MiniJuvix-#175   (janmasrovira)</li> <li>Remove TypeAny and adapt typechecking for literals MiniJuvix-#173   (janmasrovira)</li> <li>Allow holes to be refined into function types MiniJuvix-#165   (janmasrovira)</li> <li>Support implicit arguments MiniJuvix-#144   (janmasrovira)</li> <li>Add support for holes in type signatures MiniJuvix-#141   (janmasrovira)</li> <li>Support function closures with no environment in minic   MiniJuvix-#137 (paulcadman)</li> <li>Add holes for expressions in function clauses and inference support   MiniJuvix-#136 (janmasrovira)</li> <li>Add \"-Oz\" optimization flag to clang args MiniJuvix-#133   (paulcadman)</li> <li>Add version and help option and root command to the CLI   MiniJuvix-#131 (jonaprieto)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix: Ignore implicit patterns and arguments in termination checking   MiniJuvix-#172 (janmasrovira)</li> <li>Fix: pretty printing for terminating keyword MiniJuvix-#145   (jonaprieto)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Fix: proper error handling for typechecker errors MiniJuvix-#189   (jonaprieto)</li> <li>Add juvix version info and date to HTML output MiniJuvix-#186   (jonaprieto)</li> <li>Fix: Add check for constructor return types MiniJuvix-#182   (jonaprieto)</li> <li>Use Abstract name in Abstract syntax and Micro/MonoJuvix   MiniJuvix-#181 (janmasrovira)</li> <li>Add an option to specify the path where to put the HTML output   MiniJuvix-#179 (jonaprieto)</li> <li>Upgrade to ghc-9.2.3 MiniJuvix-#178   (janmasrovira)</li> <li>Replace dead link in README with a link to the Juvix book   MiniJuvix-#177 (paulcadman)</li> <li>Embed HTML assets in the juvix binary MiniJuvix-#176   (paulcadman)</li> <li>Fix: identifiers with a keyword prefix cannot be parsed   MiniJuvix-#171 (janmasrovira)</li> <li>Improve filepath equality MiniJuvix-#170   (janmasrovira)</li> <li>Update validity predicate milestone example to 0.2 syntax   MiniJuvix-#167 (paulcadman)</li> <li>Fix links in documentation and update to new syntax MiniJuvix-#163   (paulcadman)</li> <li>Update stdlib to work with version 0.2 MiniJuvix-#160   (janmasrovira)</li> <li>Update README usage example to use the compile command   MiniJuvix-#158 (paulcadman)</li> <li>Remove dead code related to the pipeline MiniJuvix-#156   (janmasrovira)</li> <li>Add negative test for AppLeftImplicit MiniJuvix-#154   (janmasrovira)</li> <li>Add positive test designed for implicit arguments MiniJuvix-#153   (janmasrovira)</li> <li>Remove ExpressionTyped from MicroJuvix MiniJuvix-#143   (janmasrovira)</li> <li>Revision for package.yaml and minor deletions MiniJuvix-#135   (jonaprieto)</li> </ul>"},{"location":"CHANGELOG/#v014-2022-05-30","title":"v0.1.4 (2022-05-30)","text":"<p>Merged pull requests:</p> <ul> <li>Generic Errors and refactoring MiniJuvix-#123   (jonaprieto)</li> <li>Only generates docs if the pull request merges MiniJuvix-#121   (jonaprieto)</li> <li>Add initial docs generation website MiniJuvix-#119   (jonaprieto)</li> <li>Fix internal link in README MiniJuvix-#116   (paulcadman)</li> <li>Add minic-runtime for linking without libc MiniJuvix-#113   (paulcadman)</li> <li>Add termination checking to the pipeline MiniJuvix-#111   (jonaprieto)</li> <li>Support uncurried higher order functions MiniJuvix-#110   (paulcadman)</li> <li>Improve error generation and handling MiniJuvix-#108   (janmasrovira)</li> <li>Add MiniC tests with clang+wasi-sdk MiniJuvix-#105   (paulcadman)</li> <li>Add usage example and move developer docs MiniJuvix-#96   (paulcadman)</li> <li>Refactor warning related stuff MiniJuvix-#91   (janmasrovira)</li> <li>Remove Agda backend MiniJuvix-#86   (paulcadman)</li> </ul> <p>Implemented enhancements:</p> <ul> <li>Add <code>compile</code> subcommand to generate binaries MiniJuvix-#128</li> <li>Add intervals to flycheck errors MiniJuvix-#124</li> <li>Improve error handling in juvix-mode MiniJuvix-#107</li> <li>Support multiple modules in compilation MiniJuvix-#93</li> <li>Add compile command to CLI MiniJuvix-#130   (paulcadman)</li> <li>Use Interval in GenericErrors MiniJuvix-#125   (janmasrovira)</li> <li>Remove dev in the CI and other tweaks MiniJuvix-#118   (jonaprieto)</li> <li>Highlight comments correctly MiniJuvix-#106   (janmasrovira)</li> <li>Support multiple modules in compilation MiniJuvix-#100   (janmasrovira)</li> <li>New target syntax and modular VP examples MiniJuvix-#92   (jonaprieto)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Missing error messages when using throw/error MiniJuvix-#117</li> <li>Fix highlight of comments MiniJuvix-#104</li> <li>Fix juvix-mode coloring for projects with multiple modules   MiniJuvix-#101</li> <li>Fix <code>highlight</code> command for modules with import statements   MiniJuvix-#102 (janmasrovira)</li> </ul> <p>Closed issues:</p> <ul> <li>Deprecate the class JuvixError MiniJuvix-#115</li> <li>Add ToGenericError instance for the infix parsing errors   MiniJuvix-#114</li> <li>Compile to WASM without linking libc MiniJuvix-#112</li> <li>Add the termination checker to the pipeline MiniJuvix-#109</li> <li>Use clang + wasi-sdk instead of emcc to compile to WASM   MiniJuvix-#103</li> <li>Move developer tooling docs out of README MiniJuvix-#95</li> <li>Add pre-commit checks to CI checks MiniJuvix-#94</li> <li>Support higher order functions in C backend MiniJuvix-#90</li> <li>Remove dev from the list of branches in the CI MiniJuvix-#89</li> <li>Refactor warning related stuff MiniJuvix-#87</li> <li>The Juvix website MiniJuvix-#51</li> </ul>"},{"location":"CHANGELOG/#v013-2022-05-05","title":"v0.1.3 (2022-05-05)","text":"<p>Closed issues:</p> <ul> <li>Monomorphisation naming inconsistency MiniJuvix-#84</li> <li>Remove BackendAgda MiniJuvix-#83</li> <li>Change terminating keyword behavior MiniJuvix-#81</li> <li>MonoJuvix <code>ExpressionTyped</code> is never used MiniJuvix-#79</li> <li>Bump stackage nightly and delete <code>allow-newer: true</code> from   <code>stack.yaml</code> MiniJuvix-#75</li> <li>Generate automatically CHANGELOG and Github Release Notes   MiniJuvix-#73</li> <li>Make flag \u2013show-name-ids global MiniJuvix-#61</li> <li>Add C code generation backend MiniJuvix-#60</li> <li>Add polymorphism MiniJuvix-#59</li> <li>Add the compile keyword to the frontend syntax (support up to   Scoping) MiniJuvix-#58</li> <li>Error with undefined or underscores MiniJuvix-#54</li> <li>Add support for other GHC and Stack stable version MiniJuvix-#52</li> <li>Autodetect output ANSI support when prettyprinting MiniJuvix-#38</li> <li>Terminating for type signatures MiniJuvix-#11</li> </ul> <p>Merged pull requests:</p> <ul> <li>Remove agda backend MiniJuvix-#86   (paulcadman)</li> <li>84 monomorphisation naming inconsistency MiniJuvix-#85   (janmasrovira)</li> <li>Change terminating keyword behavior MiniJuvix-#82   (jonaprieto)</li> <li>Remove unused constructor ExpressionTyped in Monojuvix MiniJuvix-#80   (janmasrovira)</li> <li>Stricter stack builds and pedantic mode for CI MiniJuvix-#78   (jonaprieto)</li> <li>Bump stackage version and remove allow-newer MiniJuvix-#76   (janmasrovira)</li> <li>Add automatically updates/issues/merged PRs to the changelog   MiniJuvix-#74 (jonaprieto)</li> <li>Add terminating keyword MiniJuvix-#71   (jonaprieto)</li> <li>Monomorphization MiniJuvix-#70   (janmasrovira)</li> <li>Remove StatementCompile in AST after scoping MiniJuvix-#69   (paulcadman)</li> <li>Add C code generation backend MiniJuvix-#68   (paulcadman)</li> <li>Check if stderr supports ANSI and print accordingly MiniJuvix-#67   (janmasrovira)</li> <li>Add support for compile (by Jonathan) MiniJuvix-#66   (paulcadman)</li> <li>Add NameIdGen effect to the pipeline MiniJuvix-#64   (janmasrovira)</li> <li>Make the <code>--show-name-ids</code> flag global MiniJuvix-#63   (janmasrovira)</li> <li>Implement type checker with polymorphism MiniJuvix-#62   (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v012-2022-04-11","title":"v0.1.2 (2022-04-11)","text":"<p>Closed issues:</p> <ul> <li>Add en emacs mode with support for scoped highlighting MiniJuvix-#25</li> <li>Add support for project root detection through a juvix.yaml file   MiniJuvix-#24</li> <li>Add CLI cmd to generate juvix autocompletion files for fish and zsh   MiniJuvix-#23</li> <li>Add pretty and typecheck subcommands to the microjuvix CLI   MiniJuvix-#21</li> <li>Translate identifiers from MicroJuvix to MiniHaskell (valid Haskell)   MiniJuvix-#19</li> <li>Implement the MiniHaskell to Haskell translation (prettyprinter)   MiniJuvix-#18</li> <li>Implementation of a typechecker for MicroJuvix MiniJuvix-#16</li> <li>Add references to the Abstract AST to update compilation to   MiniHaskell MiniJuvix-#12</li> <li>Order in the house MiniJuvix-#10</li> </ul> <p>Merged pull requests:</p> <ul> <li>The Juvix project now follows the same goals as the original Juvix   project. MiniJuvix-#7 (jonaprieto)</li> <li>Dev\u2192main MiniJuvix-#6 (jonaprieto)</li> <li>Big update including termination checking MiniJuvix-#5   (janmasrovira)</li> <li>Parser and scoper MiniJuvix-#3   (jonaprieto)</li> <li>Upgrade to ghc9 and use hpack MiniJuvix-#2   (janmasrovira)</li> <li>Merge MiniJuvix-#1 (jonaprieto)</li> </ul>"},{"location":"CHANGELOG/#v011-2022-03-25","title":"v0.1.1 (2022-03-25)","text":"<ul> <li>Add support in the parser/scoper for Axiom backends</li> <li>Add support for <code>foreign</code> keyword</li> <li>Add flag <code>--no-colors</code> for the scope command</li> <li>Upgrade to GHC 9.2.2</li> <li>Improve resolution of local symbols in the scoper</li> <li>Several new tests related to ambiguous symbols</li> <li>Add <code>--version</code> flag</li> <li>Add InfoTableBuilder effect for the scoper</li> </ul> <p>Closed issues:</p> <ul> <li>Add diff output to the test suite MiniJuvix-#9</li> <li>Improve scoper ambiguity error messages MiniJuvix-#8</li> </ul>"},{"location":"juvix-packages/","title":"Juvix Packages and Projects","text":"<ul> <li> <p> <code>anoma/juvix-containers</code></p> <p>Immutable container types for Juvix.</p> <ul> <li> <p> BinaryTree, Map, Queue, Set, Tree, UnbalancedSet, and much more to come.</p> </li> <li> <p> Tests using anoma/juvix-test.</p> </li> </ul> </li> <li> <p> <code>anoma/juvix-quickcheck</code></p> <p>This package provides property-based testing for the Juvix programming language inspired by the popular Haskell library, QuickCheck.</p> <ul> <li> Automated testing: Generate random test cases to validate properties of Juvix code.</li> </ul> </li> <li> <p> <code>anoma/juvix-stdlib</code></p> <p>Shipped with Juvix, the standard library provides a set of useful functions and types for writing Juvix programs.</p> </li> <li> <p> <code>anoma/juvix-test</code></p> <p>A unit testing framework for Juvix programs.</p> </li> </ul>"},{"location":"juvix-packages/#projects-using-juvix","title":"Projects using Juvix","text":"<ul> <li> <p> <code>anoma/taiga-simulator</code></p> <p>The Taiga Simulator is a Juvix function that simulates the Taiga execution model.</p> </li> <li> <p> <code>anoma/juvix-e2e-demo</code></p> <p>A project for demostrating the process of generating arithmetic circuits from high-level specifications. This CodeSpace includes all the necessary compilers for circuit generation, such as Juvix, GEB, and VampIR. Furthermore, it features the Juvix VSCode extension to simplify writing Juvix programs and allows users to interact with and evaluate the resulting GEB/VampIR programs.</p> </li> </ul> <p>Info</p> <p>If you are using Juvix in your project, please let us know by opening an issue or a pull request to add it to this list.</p>"},{"location":"juvix-packages/#other-juvix-programs","title":"Other Juvix programs","text":"<p>The following links are clickable versions of their corresponding Juvix program. The sources can be found in the examples/milestone directory in the Juvix repository. The webpages can be generated by running the following command:</p> <pre><code>juvix html --recursive FileName.juvix</code></pre> <ul> <li>HelloWorld.juvix</li> <li>Fibonacci.juvix</li> <li>Hanoi.juvix</li> <li>PascalsTriangle.juvix</li> <li>Collatz.juvix</li> <li>TicTacToe.juvix</li> </ul>"},{"location":"about/community/","title":"Juvix community","text":"<p>Join us on our Discord server</p> <p>This project is part of a bigger effort called Anoma. Anoma is a suite of protocols and mechanisms for self-contained, self-sovereign coordination. Join the Anoma project.</p>"},{"location":"about/license/","title":"License","text":"<pre><code>                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    &lt;one line to give the program's name and a brief idea of what it does.&gt;\n    Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    &lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n&lt;https://www.gnu.org/licenses/&gt;.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n&lt;https://www.gnu.org/licenses/why-not-lgpl.html&gt;.</code></pre>"},{"location":"about/overview/","title":"Juvix Project Overview","text":"CI Status   Codebase   <p>Juvix is an open-source, constantly evolving functional programming language designed for writing privacy-preserving decentralized applications. Using Juvix, developers can write high-level programs which can be compiled to WASM directly, or through VampIR to circuits for private execution with Taiga on Anoma or Ethereum.</p>"},{"location":"about/overview/#getting-started","title":"Getting Started","text":"<p>To get started with Juvix, head over to the documentation website to learn more about the language and its features. You can also find installation instructions and tutorials to help you get started with writing Juvix programs. You can download the latest release from the Juvix GitHub repository or use the web-based development environment, Juvix Github Codespace, which provides a pre-configured workspace ready to use with Juvix and the Haskell toolchain installed.</p>"},{"location":"about/overview/#language-features","title":"Language features","text":"<p>Juvix is designed with a focus on safety. The Juvix compiler runs several static analyses which guarantee the absence of runtime errors. Analyses performed include termination and type checking. As a result, functional programs, especially validity predicates, can be written with greater confidence in their correctness.</p> <p>Some language features in Juvix include:</p> <ul> <li>Haskell/Agda-like syntax with support for Unicode</li> <li>Type inference</li> <li>Parametric polymorphism</li> <li>User defined inductive data types</li> <li>Higher-order functions</li> <li>Referential transparency</li> </ul> <p>The Juvix module system allows developers to break down their programs into smaller, reusable modules that can be compiled separately and combined to create larger programs. These modules can be used to build libraries, which can then be documented using Juvix's built-in documentation generation tool, see for example, the Juvix standard library's website. For further details, please refer to the Juvix book which includes our latest updates.</p>"},{"location":"about/overview/#related-projects","title":"Related projects","text":"<p>If you're interested in Juvix, you may also want to explore the following related projects:</p> Project Description GEB Intermediate language for writing compilers and one of the Juvix backends. VampIR Proof-system-agnostic language for writing arithmetic circuits and one of the GEB backends. Taiga A framework for generalized shielded state transitions."},{"location":"about/overview/#resources","title":"Resources","text":"<p>Here is a summary of resources to help you learn more about Juvix:</p>"},{"location":"about/overview/#documentation","title":"Documentation","text":"Resource Description Official website The official website of Juvix, where you can find documentation, changelog, tutorials, and community resources. GitHub repository The official GitHub repository of Juvix, where you can find the source code and contribute to the project."},{"location":"about/overview/#community","title":"Community","text":"Resource Description Discord community The Juvix community on Discord is a space where you can connect with the developers behind Juvix and other members of the community who are passionate about privacy-preserving decentralized applications. It's a place where you can ask for help with using Juvix, discuss the latest features and updates, and get involved in the project. Twitter The official Twitter account of Juvix, where you can stay up-to-date with the latest news and announcements."},{"location":"about/overview/#libraries","title":"Libraries","text":"Resource Description Standard library The Juvix standard library is a collection of pre-written functions and modules that come bundled with the Juvix programming language. It provides developers with a set of common and useful tools that they can use to build their Juvix programs without having to write everything from scratch."},{"location":"about/overview/#ide-support","title":"IDE support","text":"Resource Description VSCode extension Support for the Juvix programming language with features such as syntax highlighting, error checking and many more directly in the VSCode editor. Emacs Juvix mode A major mode for Emacs that provides support for writing Juvix programs."},{"location":"about/overview/#development-environments","title":"Development environments","text":"Resource Description Juvix Standard Lib Codespace A web-based development environment for the Juvix standard library on GitHub. It provides a pre-configured workspace with the Juvix standard library installed and ready to use, so you can start using the library in your projects. Some examples of Juvix programs are also loaded in this environment. Juvix Github Codespace This codespace provides a pre-configured workspace with Juvix and the Haskell toolchain installed. Everything is ready to use, so you can start developing/inspecting the Juvix compiler right away."},{"location":"about/overview/#installation","title":"Installation","text":"Resource Description Homebrew Juvix formula A formula for Homebrew, a package manager for macOS and Linux, that allows you to easily install Juvix on your system. Juvix Nightly builds Users can download and use these nightly builds to experiment with the latest changes to the Juvix Compiler. Nightly builds may contain new features, bug fixes, and other improvements to Juvix that are still in development and have not yet been released in an official version."},{"location":"about/overview/#contributing","title":"Contributing","text":"<p>If you're interested in contributing to Juvix, please see the contributing guidelines for more information. We welcome contributions of all kinds, from bug reports and feature requests to code contributions and documentation improvements.</p>"},{"location":"about/overview/#license","title":"License","text":"<p>Juvix is open-source software released under the GNU General Public License v3.0. See the LICENSE file for more information.</p>"},{"location":"about/talks/","title":"Talks and workshops","text":"<p>On this page you will find a collection of our talks and workshop videos showcasing Juvix.</p> <p>In these videos we delve into the fascinating world of this powerful language, uncovering its core principles, and demonstrating real-world examples of Juvix applications.</p> <p>Gain valuable insights and inspiration from our presentations at various conferences.</p>"},{"location":"about/talks/#2023","title":"2023","text":"<ul> <li>Veronika Romashkina (2023, July 10). Juvix: Towards a Functional Programming Language for Decentralized Applications and Beyond [Video]. Retrieved from YouTube. Link to the video</li> </ul>"},{"location":"about/talks/#2022","title":"2022","text":"<ul> <li>Paul Cadman (2022, July 20). Juvix [Video]. Retrieved from YouTube. Link to the video</li> </ul>"},{"location":"about/team/","title":"Juvix Team","text":""},{"location":"about/team/#core-team","title":"Core team","text":"<ul> <li>Paul Cadman</li> <li>Jonathan Cubides</li> <li>\u0141ukasz Czajka</li> <li>Artem Gureev</li> <li>Jan Mas Rovira</li> </ul>"},{"location":"about/team/#anoma-contributors","title":"Anoma contributors","text":"<ul> <li>Christopher Goes</li> <li>Jeremy Orleans</li> <li>Terence Rokop</li> </ul>"},{"location":"about/team/#past-members","title":"Past members","text":"<ul> <li>Veronika Romashkina</li> </ul>"},{"location":"blog/","title":"Juvix Blog","text":"<p>Welcome! Join us in our cozy corner as we explore functional programming and next-generation distributed apps, sharing insights on Juvix, its development, and discussing related concepts. Stay tuned for our upcoming events and let's embark on this exciting journey together!</p>"},{"location":"blog/ethprague/","title":"Join Juvix Team at ETHPrague","text":"<p>The Juvix team is excited to announce our participation in ETHPrague 2023, an Ethereum-focused event happening in Prague, Czech Republic, from June 8-11.</p> <p>Join us for an immersive experience where you can learn about the current state of the Juvix language, explore and create real-world applications built with Juvix, and engage in discussions about the future possibilities and exciting plans we have in store.</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#the-event","title":"The event","text":"<p>ETHPrague is a premier blockchain event that brings together the global Ethereum community to discuss the future of Ethereum, blockchain technology, and new concepts. It provides a platform for knowledge sharing, networking, and collaboration among enthusiasts, experts, and visionaries.</p> <p>The event features an impressive lineup of speakers, including the esteemed Vitalik Buterin. With engaging panels, workshops, and even a hackathon, ETHPrague offers abundant opportunities to learn, network, and connect with exceptional individuals and communities.</p> <p>The event will take place from June 8th to June 11th in the beautiful city of Prague, Czech Republic. For more information, please visit the official event webpage.</p> <p>Make sure to mark your calendar for the following key sessions:</p> <ul> <li>Talk by Veronika Romashkina: On Saturday, June 10th, from 14:10 - 14:30   at the Institute of Cryptoanarchy, Veronika, Developer Relations at Heliax,   will present a talk titled \"Juvix: Toward a Functional Programming Language   for Decentralized Applications and Beyond.\"</li> <li>Workshop by Paul Cadman: Also on Saturday, June 10th, from 16:20 - 17:20   at the Paper Hub, Paul, Compiler Engineer at Heliax, will host a workshop   titled \"Discovering Juvix: The High-Level Functional Programming Language   for Building Next-Generation dApps.\"</li> </ul>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#explore-juvix-talk-highlights","title":"Explore Juvix: Talk Highlights","text":"<p>During the talk, you'll get an in-depth introduction to Juvix, an innovative language for developing next-generation decentralized applications. Juvix combines the strengths of functional languages with efficient compilation to low-level languages like C or LLVM, providing a powerful and transparent coding experience.</p> <p>Designed with a strong type system and a focus on referential transparency, Juvix incorporates the best features of existing functional languages. We'll explore Juvix's current state, including its compiler phases and language features, and discuss the ongoing development progress and the challenges we face in creating a robust tool for the rapidly evolving world of decentralised applications. With the power of the high-level language Juvix you can grasp on the easier way to create arithmetic circuits for zero-knowledge proofs.</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#engage-in-the-workshop-hands-on-experience","title":"Engage in the Workshop: Hands-On Experience","text":"<p>In addition to the introductory presentation, we invite you to join our practical workshop session on Juvix. It's an excellent opportunity to dive deeper into Juvix and get hands-on experience.</p> <p>During the workshop, our team will guide you through creating your first Juvix application. How exciting is that! We'll assist you with installing the Juvix compiler and related tools, provide an overview of the Juvix language, and explore some fascinating Juvix applications.</p> <p>To get started, simply clone the workshop GitHub repository. It contains all the necessary instructions to prepare for the workshop in advance. Don't worry if you encounter any questions or challenges along the way \u2014 we'll be there to support and assist you during the workshop.</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#meet-the-team","title":"Meet the team","text":"<p>In addition to the talk and workshops, the teams will have a dedicated Namada/Anoma booth at the venue. We'd love for you to stop by, say hi and learn more about the projects. The team would love to hear from you and meet you there.</p> <p>And, of course, your effort and hard work will be rewarded by the unique merch we will be sharing exclusively with the talk and workshop participants. Join the session, or come find us at the Juvix booth at the conference premises to get some for yourself!</p> <p>See you in Prague \ud83c\udde8\ud83c\uddff</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/geb-backend/","title":"Compiling to VampIR through Geb","text":"<p>Note</p> <p>The compilation described is currently not supported by the newest version of Juvix and Geb. Changes are forthcoming.</p> <p>Before, we discussed the standard normalization approach to compiling Juvix programs to VampIR. An alternative backend is provided by the Geb project currently implemented in Lisp providing a categorical view of the needed translations.</p> <p>The post will be devoted to discussing the core ideas of Geb, the practical steps to take in order to use the corresponding pipeline, as well as the current limitations the backend faces.</p> <p>We assume basic familiarity with categorical concepts and VampIR.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#geb-pipeline","title":"Geb Pipeline","text":"<p>Geb is a developing language providing a useful interface for specifying categorical constructs and helping define compilers in terms of functors. The approach is inspired by a classical observation that instead of dealing with 'good' compilation procedures one can instead specify functors between appropriate categories representing the languages one initially considers.</p> <p>In the current state of development, Geb is a fairly simple category in which one can do \"basic arithmetic.\" It is a category freely spanned by terminal/initial objects and finite (co)products with additional constructs for objects representing <code>n</code>-bit natural numbers. The pipeline itself is a string of functors between categories:</p> \\[ \\text {Lambda} \\to \\text {Geb} \\to \\text {Seq} \\mathbb N \\] <p>which are all implemented in Lisp. The morphisms in the final category have a fairly direct interpretation as VampIR programs.</p> <p>Here, Lambda stands for an extension of STLC with natural numbers types of different bit-width and some arithmetic, while Seq\\(\\mathbb N\\) is a category of finite natural number sequences with morphism $$f: (x_1,\\dots,x_n) \\to (y_1,\\dots,y_m) $$ a VampIR function which takes in \\(n\\) inputs with \\(i\\)-th input of bit-length \\(x_i\\) and spits out an \\(m\\)-tuple with \\(i\\)-th outputs of bit-length \\(y_i\\).</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#the-practice","title":"The Practice","text":"<p>In this section, we describe all the practical steps one needs to take in order to compile Juvix code to VampIR using the Geb binary.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-juvix-to-lambda","title":"From Juvix to Lambda","text":"<p>The first step to the compilation is getting Juvix code to compile to Lambda. The translation can be done inside of Juvix itself.</p> <p>Let us create an example using one of the VampIR tests in the codebase. We create a file <code>NotZero.juvix</code> with body</p> <pre><code>--8&lt;-- [start:NotZero]\nmodule NotZero;\n\nimport Stdlib.Data.Bool open;\nimport Stdlib.Data.Nat open;\nimport Stdlib.Data.Nat.Ord open;\nimport Stdlib.Trait open;\n\n-- We need to name the module exactly the same name as the file\nintToBool (x : Nat) : Bool := not (x == 0);\n\n-- We need to include a function named main\n-- for the compilation to succeed\nmain : Nat -&gt; Bool := intToBool;\n--8&lt;-- [end:NotZero]</code></pre> <p>and we want to compile it to code that is readable by the Lisp implementation of Geb. We run</p> <pre><code>juvix compile -t geb NotZero.juvix</code></pre> <p>which generates a <code>NonZero.lisp</code> file with the following code:</p> <pre><code>(defpackage #:NotZero\n  (:shadowing-import-from :geb.lambda.spec #:pair #:right #:left)\n  (:shadowing-import-from :geb.spec #:case)\n  (:use #:common-lisp #:geb.lambda.trans #:geb.lambda.main #:geb.lambda.spec #:geb))\n\n(in-package :NonZero)\n\n(defparameter *entry*\n  (app (lamb (list (fun-type\n                        int\n                        (coprod\n                          so1\n                          so1)))\n               (lamb (list int)\n                      (case-on\n                        (app  (index 1)\n                              (list (index 0)))\n                        (bit-choice 0)\n                        (bit-choice 1))))\n        (list (lamb (list int)\n                      (case-on\n                        (lamb-eq\n                          (index 0)\n                          (bit-choice 0))\n                        (right\n                          so1\n                          (unit))\n                        (left\n                          so1\n                          (unit)))))))\n</code></pre> <p>The file generated will be used by the Geb binary where <code>*entry*</code> is a parameter for a term to be compiled. The Lambda code produced is similar to STLC with certain variations. In the above code, we have:</p> <ol> <li>Unit type is <code>so1</code></li> <li>Unique element of the Unit type is <code>unit</code></li> <li>Coproduct type of <code>a</code> and <code>b</code> is <code>coprod a b</code></li> <li><code>left</code> and <code>right</code> are appropriate sum-type injections</li> <li>Function type from <code>a</code> to <code>b</code> is <code>fun-type a b</code></li> <li><code>int</code> a stand-in for a type of 24-bit numbers</li> <li><code>lamb</code> is lambda abstraction</li> <li><code>app</code> is function application</li> <li><code>case-on</code> is sum type induction</li> <li><code>lamb-eq</code> predicate for checking number equality</li> <li><code>index n</code> is an <code>n</code>-th DeBruijn index</li> <li><code>bit-choice n</code> is a constructor for number <code>n</code></li> </ol>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-lambda-to-vampir","title":"From Lambda to VampIR","text":"<p>After generating the file, one needs to go into the Geb repository, make a binary, creating <code>geb.image</code> file inside the <code>build</code> folder and inside it run</p> <pre><code>./geb.image -i \"NonZero.lisp\" -e \"NonZero:*entry*\" -l -p -o \"NonZero.pir\"</code></pre> <p>This will generate a <code>NonZero.pir</code> file in <code>build</code> with the inserted Lambda code compiled to VampIR through Geb.</p> <p>One can remove <code>-o \"NonZero.pir\"</code> in order for the terminal to print the relevant code instead of putting it in a separate file.</p> <p>In the build directory type</p> <pre><code>./geb.image -i \"NonZero.lisp\" -e \"NonZero:*entry*\" -l -p</code></pre> <p>Which returns</p> <pre><code>(def entry x1 x2 = {\n   (1 - (iszero x1))\n };)</code></pre> <p>Note that the last variable in the function is unused. This will be the case for any compiled function and is due to a compilation side-effect when we go from Lambda to Geb.</p> <p>For further instructions on the use of the binary, consult the Geb documentation.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#interactive-mode","title":"Interactive Mode","text":"<p>If one is interested in using more features than the direct compilation to VampIR, one may use the Geb codebase interactively.</p> <p>To do so, load the system as per the Geb documentation, then go a package preferably using all the relevant lambda code such as <code>geb.lambda.trans</code> by typing</p> <pre><code>CL-USER&gt; (in-package geb.lambda.trans)</code></pre> <p>Here one can compile the relevant code to several targets. <code>to-circuit</code> takes a lambda term in an empty context and a name.</p> <p>If we want to compile the identity function on natural numbers <code>(lamb (list int) (index 0))</code> with name <code>id</code> we type</p> <pre><code>TRANS&gt; (to-circuit (lamb (list int) (index 0)) :id)</code></pre> <p>Moreover, we can compile this not to a circuit but to Geb in a nil context (which we need to specify explicitly), e.g. by typing</p> <pre><code>TRANS&gt; (to-cat nil (lamb (list int) (index 0)))</code></pre> <p>or to Seq\\(\\mathbb N\\) in the nil context by</p> <pre><code>TRANS&gt; (to-seqn (lamb (list int) (index 0)))</code></pre> <p>For further utility function discription, please consult the relevant documentation.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#the-theory","title":"The Theory","text":"<p>This section is devoted to describing the core ideas of how the compilation occurs step-by-step.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-juvix-to-lambda_1","title":"From Juvix to Lambda","text":"<p>The transformation of Juvix to Lambda is a pretty easy one compared to the normalization approach partially due to the limitations we will discuss later.</p> <p>The Juvix code gets transformed by</p> <ol> <li>Transforming type names and rescuing needed type signatures, e.g. <code>Nat</code>    becomes primitive <code>Int</code></li> <li>Unrolling recursion</li> <li>Lifting out let-statements</li> <li>Inlining type synonyms</li> <li>Presenting finite indictive datatypes using sum/product type structures</li> </ol> <p>Afterwards, a direct translation to STLC follows.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-lambda-to-geb","title":"From Lambda to Geb","text":"<p>The compilation of Lambda to Geb is actually a canonical one. Geb is secretly a category equivalent to FinSet and in particular, is a Cartesian Closed Category. By a classical result of Lambek-Scott, there is a unique compilation of STLC to Geb preserving STLC structure. All other datatypes are compiled primitively: e.g. <code>plus</code> in Lambda gets compiled to the primitive <code>nat-plus</code>.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-geb-to-seqmathbb-n","title":"From Geb to Seq\\(\\mathbb N\\)","text":"<p>The transformation to the finite-sequence category representing VampIR operations is a bit tricky, yet the point is that each object in Geb has an intuitive notion of bit-width. The object of <code>n</code>-bit numbers has <code>n</code>-width, while <code>bool</code>, the coproduct of two terminal objects, has width <code>1</code>. Products should just append the widths of its parts while coproducts should mark the left bit entries with <code>0</code> while right ones with <code>1</code> to differentiate between the two. Hence all the objects get encoded in this manner with morphisms following a similar fashion.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-seqmathbb-n-to-vampir","title":"From Seq\\(\\mathbb N\\) to VampIR","text":"<p>The compilation to VampIR is a straightforward one as the morphisms in Seq\\(\\mathbb N\\) have been chosen in such a way that the category can be directly seen as a model of VampIR. For more detailed info on the compilation, consult the recent report on the pipeline by the Juvix team.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#limitations","title":"Limitations","text":"<p>After describing the Geb backend, we also need to mention current limitations and challenges that the pipeline faces.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#limited-interpretation-power","title":"Limited Interpretation Power","text":"<p>Currently, not all Juvix programs can be interpreted in Geb. As we have mentioned, Geb is just a variation of FinSet, a fairly weak category. We currently do not have support for interpreting any polymorphic type or any infinite datatype.</p> <p>Moreover, as there are no primitive function types in Geb, we also do not have a way to make internal function definitions via constraints in VampIR the way the normalizer compilation does.</p> <p>However, these issues are to be addressed in a newer version of Geb, which will significantly enhance the expressive power of the language.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#heap-exhaustion-for-functions-of-natural-number","title":"Heap Exhaustion for Functions of Natural Number","text":"<p>While Geb seems like a good candidate to do \"categorical arithmetic\" in and hence to compile to arithmetic circuits, the fact that the primitive constructions are very minimal serves as a reason for an exponential blow-up. An object representing <code>n</code>-bit natural number <code>nat-wdth n</code> is analyzed as a <code>2^n</code> coproduct of terminal objects. So even if we have primitives for natural numbers, for <code>curry</code> and <code>uncurry</code> operations the functions get analyzed bit-by-bit, causing a blow-up.</p> <p>If one compiles complicated functions, even working with 2-bit numbers can cause a heap exhaust.</p> <p>However, there are forthcoming enhancements to the pipeline. Future optimizations of Lambda will include a \"smart\" version of beta-reduction allowing for the removal of unnecessary lambda and function application occurences. This will effectively eliminate all blow-up problems having to do with compiling relevant Juvix code.</p>","tags":["circuits","vampir"]},{"location":"blog/iterators/","title":"Iterator syntax","text":"<p>A common pattern in functional programming is the traversal of data structures, particularly lists, in a specified order accumulating some values. If you've used languages like Haskell or OCaml, you must have come across the \"fold left\" (<code>foldl</code>) and \"fold right\" (<code>foldr</code>) higher-order functions which implement this pattern. These functions are also available in Juvix. In this blog post, I describe an iterator syntax I designed for Juvix which allows expressing folds (and maps, filters and more) in a readable manner.</p> <p>The next paragraph discusses some issues with using fold functions directly. Don't worry if you've never heard of folds - just skip this paragraph and the rest of the blog post will teach you how to use them in a nice iterator syntax.</p> <p>The problem with folds is that they are hard to read and understand, which results in code that is difficult to maintain. From a fold application, e.g., <code>foldr \\{ acc x := body } a xs</code>, it is not always immediately apparent how the list traversal proceeds. This is especially the case when the function argument is big and spans several lines - then the initial value <code>a</code> of the accumulator and the list <code>xs</code> are syntactically \"disconnected\" from the accumulator variable <code>acc</code> and the current list element <code>x</code>. Personally, I also find it hard to remember which argument is which - this differs between different functional languages. I'm not the first person who noticed this problem. For example, the unreadability of folds was one of the motivations behind introducing a monadic <code>for .. in</code> notation in Lean 4.</p>","tags":["iterators","syntax"]},{"location":"blog/iterators/#the-essence-of-folds","title":"The essence of folds","text":"<p>The anatomy of a fold (left or right) is simple.</p> <ol> <li> <p>We have an accumulator variable <code>acc</code> which we initialise to some value <code>a</code>.</p> </li> <li> <p>We go through a data structure (list) in some specified order (left-to-right    or right-to-left).</p> </li> <li> <p>At each step, we receive the current value of the accumulator <code>acc</code> and the    current element <code>x</code>. From those we need to compute the new value of <code>acc</code>.</p> </li> <li> <p>After going through all elements, the final value of <code>acc</code> is the result of    the fold expression.</p> </li> </ol>","tags":["iterators","syntax"]},{"location":"blog/iterators/#the-for-notation","title":"The for-notation","text":"<p>The Juvix standard library defines two iterators on lists which correspond to list folds:</p> <ul> <li><code>for</code> as a syntactic sugar for fold left (<code>foldl</code>),</li> <li><code>rfor</code> as a syntactic sugar for fold right (<code>foldr</code>).</li> </ul> <p>Iterator application has the syntax:</p> <pre><code>for (acc := a) (x in xs) {body}</code></pre> <p>The braces around <code>body</code> are optional.</p> <p>The above <code>for</code> iteration starts with the accumulator <code>acc</code> equal to <code>a</code> and goes through the list <code>xs</code> from left to right (from beginning to end), at each step updating the accumulator to the result of evaluating <code>body</code>. The variables <code>acc</code>, <code>x</code> are locally bound in <code>body</code> where they denote the previous accumulator value (<code>acc</code>) and the current element (<code>x</code>). The final value of the accumulator becomes the value of the entire <code>for</code> expression.</p> <p>For example, the following code computes the sum of all numbers in the list <code>xs</code>:</p> <pre><code>for (acc := 0) (x in xs) {x + acc}</code></pre> <p>Product of all numbers in a list:</p> <pre><code>for (acc := 1) (x in xs) {x * acc}</code></pre> <p>Reversing a list:</p> <pre><code>for (acc := nil) (x in xs) {x :: acc}</code></pre> <p>Counting odd numbers in a list:</p> <pre><code>for (acc := 0) (x in xs) {if (mod x 2 == 0) acc (acc + 1)}</code></pre> <p>Sum of squares of positive numbers in a list:</p> <pre><code>for (acc := 0) (x in xs) {if (x &gt; 0) (acc + x * x) acc}</code></pre> <p>The <code>for</code> iterator is complemented by the <code>rfor</code> iterator which goes through the list from right to left (from end to beginning).</p> <p>For example, the following code concatenates all lists from a list of lists:</p> <pre><code>rfor (acc := nil) (x in xs) {x ++ acc}</code></pre> <p>If we used the <code>for</code> iterator above, the order of concatenations would be reversed.</p> <p>Applying a function <code>f</code> to each element in a list may be implemented with:</p> <pre><code>rfor (acc := nil) (x in xs) {f x :: acc}</code></pre> <p>Filtering a list with a predicate <code>p</code>:</p> <pre><code>rfor (acc := nil) (x in xs) {if (p x) (x :: acc) acc}</code></pre> <p>The above keeps only the elements that satisfy <code>p</code>. The order of the elements would be reversed if we used <code>for</code> instead of <code>rfor</code>.</p>","tags":["iterators","syntax"]},{"location":"blog/iterators/#maps-filters-and-more","title":"Maps, filters and more","text":"<p>If you're familiar with the <code>map</code> and <code>filter</code> higher-order functions, you probably noticed that the last two examples above provide their implementations using <code>rfor</code>. In fact, one can use the iterator notation directly with <code>map</code> and <code>filter</code>, and several other list functions from the standard library. In this case, there are no explicit accumulators in the notation.</p> <p>The expression</p> <pre><code>map (x in xs) {body}</code></pre> <p>is equivalent to (assuming <code>acc</code> doesn't occur in <code>body</code>)</p> <pre><code>rfor (acc := nil) (x in xs) {(body) :: acc}</code></pre> <p>or if you're familiar with the standard <code>map</code> function:</p> <pre><code>map \\{ x := body } xs</code></pre> <p>Similarly, one can use the notation</p> <pre><code>filter (x in xs) p x</code></pre> <p>to filter <code>xs</code> with the predicate <code>p</code>.</p> <p>Other functions that can be used with the iterator syntax are <code>all</code> and <code>any</code> which check whether <code>all</code>, resp. <code>any</code>, elements <code>x</code> in a list satisfy <code>body</code> (which would of course refer to <code>x</code>):</p> <pre><code>all (x in xs) {body}\n\nany (x in xs) {body}</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators/#multiple-accumulators","title":"Multiple accumulators","text":"<p>In fact, the <code>acc</code> and <code>x</code> in the iterator syntax don't need to be variables - they can be arbitrary patterns. This is especially useful in conjunction with pairs, allowing to effectively operate on multiple accumulators.</p> <p>For example, to compute the largest and the second-largest element of a list of non-negative numbers one can use:</p> <pre><code>for (n, n' := 0, 0) (x in lst) {if (x &gt;= n) (x, n) (if (x &gt; n') (n, x) (n, n'))}</code></pre> <p>where <code>n</code> is the largest and <code>n'</code> the second-largest element found so far.</p> <p>One can also operate on multiple lists simultaneously. For example, the following computes the dot product of the lists <code>xs</code>, <code>ys</code> (assuming they have equal lengths):</p> <pre><code>for (acc := 0) (x, y in zip xs ys) {x * y + acc}</code></pre> <p>The <code>zip</code> function creates a list of pairs of elements in the two lists, e.g.,</p> <pre><code>zip (1 :: 2 :: nil) (3 :: 4 :: nil) = (1, 3) :: (2, 4) :: nil</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators/#declaring-iterators","title":"Declaring iterators","text":"<p>Iterator syntax can be enabled for any identifier <code>func</code> with the declaration:</p> <pre><code>syntax iterator func;</code></pre> <p>Then any iterator application of the form</p> <pre><code>func (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}</code></pre> <p>is automatically replaced by</p> <pre><code>func \\{ acc1 .. accn x1 .. xk := body } acc1 .. accn xs1 .. xsk</code></pre> <p>The replacement is entirely syntactic and happens before type-checking.</p> <p>It is possible to restrict the number of initialisers (<code>acci := ai</code>) and ranges (<code>xi in xsi</code>) accepted:</p> <pre><code>syntax iterator func {init: n, range: k};</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators/#further-reading","title":"Further reading","text":"<p>More information on iterators can be found in the Juvix language reference and the Juvix tutorial.</p>","tags":["iterators","syntax"]},{"location":"blog/strictly-positive-data-types/","title":"Stay Positive with Your Data Types","text":"<p>In this discussion, we will explore the concept of strictly positive inductive data types, a critical requirement within the Juvix framework for classifying a data type as well-typed.</p> <p>An inductive type is considered strictly positive if it either:</p> <ol> <li>Does not appear within the argument types of its constructors, or</li> <li>Appears strictly positively within the argument types of its constructors.</li> </ol> <p>A name is considered strictly positive for an inductive type if it never appears in a negative position within the argument types of its constructors. The term negative position denotes instances located to the left of an arrow in a type constructor argument.</p>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types/#example","title":"Example","text":"<p>Consider the following data type <code>X</code> where <code>A</code> and <code>B</code> are types in scope:</p> <pre><code>  type X :=\n    | c0 : (B -&gt; X) -&gt; X\n    | c1 : (X -&gt; A) -&gt; X;</code></pre> <p>In this example, the type <code>X</code> occurs strictly positive in the constructor <code>c0</code>, but negatively in the constructor <code>c1</code> in the type argument <code>X -&gt; A</code>. Therefore, <code>X</code> is not strictly positive.</p> <p>Positive parameters can also be described as those that do not occur in negative positions. For instance, the type <code>B</code> in the <code>c0</code> constructor above appears to the left of the arrow <code>B-&gt;X</code>, placing <code>B</code> in a negative position. It is essential to consider negative parameters when verifying strictly positive data types, as they might enable the definition of non-strictly positive data types.</p> <p>Let us consider another example:</p> <pre><code>  type T0 (A : Type) := c0 : (A -&gt; T0 A) -&gt; T0 A;</code></pre> <pre><code>  type T1 := c1 : T0 T1 -&gt; T1;</code></pre> <p>In this example, the type <code>T0</code> is strictly positive, while the type <code>T1</code> is not. It is only after unfolding the type application <code>T0 (T1 A)</code> in the data constructor <code>c1</code> that we can determine <code>T1</code> occurs in a negative position due to <code>T0</code>. More specifically, the type parameter <code>A</code> of <code>T0</code> is negative.</p>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types/#bypassing-the-strict-positivity-condition","title":"Bypassing the Strict Positivity Condition","text":"<p>To bypass the positivity check in a data type declaration, you can annotate it with the <code>positive</code> keyword. Alternatively, you can use the CLI global flag <code>--no-positivity</code> when type checking a <code>Juvix</code> file.</p> <pre><code>  positive\n  type T0 (A : Type) := c0 : (T0 A -&gt; A) -&gt; T0 A;</code></pre>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types/#examples-of-non-strictly-positive-data-types","title":"Examples of Non-Strictly Positive Data Types","text":"<ul> <li>The <code>Bad</code> data type is not strictly positive due to the negative parameter <code>A</code>   of <code>Tree</code>.</li> </ul> <pre><code>  type Tree (A : Type) :=\n    | leaf : Tree A\n    | node : (A -&gt; Tree A) -&gt; Tree A;</code></pre> <pre><code>  type Bad := bad : Tree Bad -&gt; Bad;</code></pre> <ul> <li><code>A</code> is a negative parameter.</li> </ul> <pre><code>  type B (A : Type) := b : (A -&gt; B (B A -&gt; A)) -&gt; B A;</code></pre>","tags":["type-system","inductive-types"]},{"location":"blog/vampir-circuits/","title":"Compiling Juvix programs to arithmetic circuits via Vamp-IR","text":"<p>Since version 0.3.5, the Juvix compiler supports the <code>vampir</code> target which generates Vamp-IR input files that can be compiled to various proof systems based on arithmetic circuits, like Plonk or Halo 2. Vamp-IR is a proof-system-agnostic language for writing arithmetic circuits.</p> <p>In this post, we will not be discussing the details of Vamp-IR or the circuit computation model. Instead, we will describe how high-level functional Juvix programs can be compiled to circuits, what the common pitfalls and current limitations are. The reader is assumed to have at least basic familiarity with Vamp-IR.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#a-simple-circuit-program","title":"A simple circuit program","text":"<p>For a simple example of a Juvix program that can be compiled to an arithmetic circuit via Vamp-IR, we consider computing the 6-bit mid-square hash of a 16-bit number.</p> <pre><code>module MidSquareHash;\n\nimport Stdlib.Prelude open;\nimport Stdlib.Data.Nat.Ord open;\n\n--- `pow N` is 2 ^ N\npow : Nat -&gt; Nat\n  | zero := 1\n  | (suc n) := 2 * pow n;\n\n--- `hash N` hashes a number with max N bits (i.e. smaller than 2^N) into 6 bits\n--- (i.e. smaller than 64) using the mid-square algorithm.\nhash : Nat -&gt; Nat -&gt; Nat\n  | (suc n@(suc (suc m))) x :=\n    if\n      (x &lt; pow n)\n      (hash n x)\n      (mod (div (x * x) (pow m)) (pow 6));\n  | _ x := x * x;\n\nmain (x y : Nat) : Bool := hash 16 x == y;</code></pre> <p>To compile this file to Vamp-IR type</p> <pre><code>juvix compile -t vampir MidSquareHash.juvix</code></pre> <p>This should generate the <code>MidSquareHash.pir</code> file containing the Vamp-IR code.</p> <p>The exact details of the hashing algorithm are not essential here. What matters is that Juvix can compile this ordinary high-level program, which uses recursion, pattern-matching, etc., into low-level Vamp-IR representation. The user does not need to understand arithmetic circuits or Vamp-IR beyond the basics.</p> <p>The Juvix <code>main</code> function is compiled to a Vamp-IR <code>main</code> function which is then used in an equation which connects the inputs (arguments of <code>main</code>) to the ouput of <code>main</code>. For example, for the program above the generated equation is:</p> <pre><code>main x y = 1;</code></pre> <p>stating that <code>main x y</code> equals <code>true</code>. The variables <code>x</code>, <code>y</code> are Vamp-IR's private inputs.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#controlling-generated-equations","title":"Controlling generated equations","text":"<p>In principle, any Juvix program can be compiled to a circuit, subject to certain restrictions. When targeting Vamp-IR, the <code>main</code> function must have the type</p> <pre><code>main : ArgTy1 -&gt; .. -&gt; ArgTyN -&gt; ResTy;</code></pre> <p>where <code>ArgTyK</code> and <code>ResTy</code> are <code>Nat</code>, <code>Int</code> or <code>Bool</code>. Since Vamp-IR natively supports only numbers (field elements), booleans are represented using <code>1</code> for <code>true</code> and <code>0</code> for <code>false</code>.</p> <p>If the result type <code>ResTy</code> is a boolean (<code>Bool</code>), then the generated Vamp-IR file will contain the equation</p> <pre><code>main arg1 .. argN = 1;</code></pre> <p>where <code>arg1</code>, .., <code>argN</code> are the names of inputs to the <code>main</code> function. By default, these are inferred from the variable names in the first clause of <code>main</code>, e.g., compiling</p> <pre><code>main (x y : Nat) : Bool := x == y;</code></pre> <p>will generate Vamp-IR code similar to</p> <pre><code>def main x y = equal x y;\n\nmain x y = 1;</code></pre> <p>The Vamp-IR input variable names can also be explicitly specified with the <code>argnames</code> pragma, e.g., compiling</p> <pre><code>{-# argnames: [a, b] #-}\nmain (x y : Nat) : Bool := x == y;</code></pre> <p>will generate Vamp-IR code similar to</p> <pre><code>def main x y = equal x y;\n\nmain a b = 1;</code></pre> <p>If the result type <code>ResTy</code> is <code>Nat</code> or <code>Int</code>, then the generated equation is</p> <pre><code>main arg1 .. argN = out;</code></pre> <p>Currently, all Vamp-IR inputs (<code>argK</code>, <code>out</code>) are private, and it is not possible to change the name of <code>out</code>. These technical limitations will be lifted in future Juvix versions.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#recursion-unrolling","title":"Recursion unrolling","text":"<p>Neither arithmetic circuits nor the Vamp-IR intermediate representation support recursion. This means that all Juvix recursive functions need to be unrolled up to a specified depth. Currently, the default unrolling depth is 140, which may be too much or too little depending on your particular program. The unrolling depth can be specified globally on the command line with the <code>--unroll</code> option, or on a per-function basis with the <code>unroll</code> pragma. For example, using</p> <pre><code>{-# unroll: 16 #-}\nhash : Nat -&gt; Nat -&gt; Nat;</code></pre> <p>would limit the recusion depth (i.e. the number of possible nested recursive calls) for <code>hash</code> to 16. It is the responsibility of the user to ensure that the recursion unrolling depth is sufficient for all arguments that the function might be applied to in the program. In the above example, <code>hash</code> recurses on its first argument and the call to <code>hash</code> in <code>main</code> provides <code>16</code> as the first argument. Hence, no more than 16 nested recursive calls to <code>hash</code> are possible.</p> <p>If the recursion unrolling depth is too small, i.e. smaller than the actual number of nested recursive calls, then the computation result may be incorrect. On the other hand, the circuit size grows with the unrolling depth, so it's advised to keep it as small as possible.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#compilation-by-normalization","title":"Compilation by normalization","text":"<p>Currently, the Juvix compiler uses a straightforward method to translate Juvix programs to Vamp-IR code: it simply computes the full normal form of the <code>main</code> function. Because of the restrictions we imposed on its type, the normal form of the <code>main</code> function must be an applicative expression built up from variables, constants and arithmetic and boolean operations. Such an expression can be directly translated to the Vamp-IR input format.</p> <p>The disadvantage of performing full normalization is that it may super-exponentially blow up the size of the program. As explained below, this applies in particular to branching recursive functions with at least two recursive calls.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#the-branching-problem","title":"The branching problem","text":"<p>With the current compilation method, any recursive function which contains two or more recursive calls to itself in its body will cause an exponential blow-up in the generated code size, and thus will most likely fail to compile. As a rule of thumb, the size of the VampIR code generated for a Juvix function is proportional to k^n where k &gt; 1 is the number of recursive calls in the function body and n is the unrolling depth; or proportional to n when k = 1.</p> <p>For example, trying to compile the fast power function</p> <pre><code>{-# unroll: 30 #-}\nterminating\npower' (acc a b : Nat) : Nat :=\n  if\n    (b == 0)\n    acc\n    (if\n      (mod b 2 == 0)\n      (power' acc (a * a) (div b 2))\n      (power' (acc * a) (a * a) (div b 2)));\n\npower : Nat \u2192 Nat \u2192 Nat := power' 1;</code></pre> <p>makes the Juvix compiler hang. The pragma <code>unroll: 30</code> doesn't help, because 2^30 = 1073741824 is still a large number - this is the factor by which the program size increases during compilation.</p> <p>However, the fast power function may be reformulated to use only one recusive call:</p> <pre><code>{-# unroll: 30 #-}\nterminating\npower' (acc a b : Nat) : Nat :=\n  let\n    acc' : Nat := if (mod b 2 == 0) acc (acc * a);\n  in if (b == 0) acc (power' acc' (a * a) (div b 2));\n\npower : Nat \u2192 Nat \u2192 Nat := power' 1;</code></pre> <p>With the reformulated definition, the program size increases only by a factor of 30. Now compiling to Vamp-IR succeeds and it is possible to generate a ZK proof that e.g. 2^30 is indeed equal to 1073741824.</p>","tags":["circuits","vampir"]},{"location":"explanations/","title":"Index","text":"<p>Welcome to the Explanations section! In this part, we will dive into various coding concepts and techniques that are essential for every developer. We will cover a wide range of topics, from basic programming principles to more advanced subjects.</p>"},{"location":"explanations/typetheory/","title":"Type theory","text":""},{"location":"explanations/totality/coverage/","title":"Coverage checking","text":""},{"location":"explanations/totality/positive/","title":"Strictly positive data types","text":""},{"location":"explanations/totality/termination/","title":"Termination","text":"<p>To prevent inconsistencies arising from function declarations, Juvix mandates that every function passes its termination checker. Nevertheless, this requirement can be challenging to meet; thus, we provide users with two distinct methods for bypassing this check:</p>"},{"location":"explanations/totality/termination/#keyword","title":"Keyword","text":"<p>Utilize the terminating keyword to annotate function type signatures as terminating. In the following example we mark the function <code>fun</code> as terminating.</p> <pre><code>terminating\nfun : A \u2192 B;</code></pre> <p>Note</p> <p>Annotating a function with the <code>terminating</code> keyword indicates that all of its function clauses meet the termination checker's criteria. For mutual recursive functions, to bypass the termination checker, all involved functions must be annotated as <code>terminating</code>.</p>"},{"location":"explanations/totality/termination/#cli-flag","title":"CLI flag","text":"<p>You can disable the termination checking by utilizing the global CLI flag <code>--no-termination</code>.</p> <pre><code>juvix --no-termination typecheck MyProgram.juvix</code></pre> <p>Note</p> <p>Please note that our termination checker has certain limitations, as it only accepts a subset of recursive functions. The algorithm used in the termination checker is a minor adaptation of the one employed for checking termination in the Foetus language.</p>"},{"location":"howto/compilation/","title":"Program Compilation","text":""},{"location":"howto/compilation/#example-hello-world","title":"Example: Hello World","text":"<p>A Juvix file must declare a module with the same name as the file. For instance, <code>Hello.juvix</code> should declare a module <code>Hello</code>:</p> <pre><code>-- This is a comment.\nmodule Hello;\n\n-- Importing the 'String' type from standard library prelude\nimport Stdlib.Prelude open;\n\nmain : String := \"Hello world!\";</code></pre> <p>The zero-argument function <code>main</code> is evaluated when running the program and must be defined in a file compiled to an executable.</p> <p>To compile <code>Hello.juvix</code>, type:</p> <pre><code>juvix compile Hello.juvix</code></pre> <p>For all options of the <code>compile</code> command, type:</p> <pre><code>juvix compile --help</code></pre>"},{"location":"howto/compilation/#compilation-targets","title":"Compilation Targets","text":"<p>Juvix supports several targets specified with the <code>-t</code> option:</p> <pre><code>juvix compile -t TARGET file.juvix</code></pre> <p>Targets include:</p> <ol> <li><code>native</code>: Default target producing a native 64bit executable.</li> <li><code>wasm32-wasi</code>: Produces a WebAssembly binary using the WASI runtime.</li> <li><code>vampir</code>: Creates a VampIR input file.</li> <li><code>geb</code>: Generates a GEB input file.</li> <li><code>core</code>: Produces <code>.jvc</code> file.</li> <li><code>asm</code>: Produces <code>.jva</code> file.</li> </ol>"},{"location":"howto/compilation/#compilation-options","title":"Compilation Options","text":"<p>To view all compilation options, type <code>juvix compile --help</code>. Commonly used options include:</p> <ul> <li><code>-t TARGET</code>: Target specification.</li> <li><code>-g</code>: Debug information and runtime assertions generation.</li> <li><code>-O LEVEL</code>: Optimization level setting (default: 1, or 0 with <code>-g</code>).</li> <li><code>-o FILE</code>: Output file specification.</li> </ul>"},{"location":"howto/compilation/#juvix-projects","title":"Juvix Projects","text":"<p>A Juvix project is a collection of Juvix modules in one main directory containing a <code>juvix.yaml</code> metadata file. Each module's name must match its file path, relative to the project's root directory. For instance, if the file is <code>root/Data/List.juvix</code>, the module should be called <code>Data.List</code>.</p> <p>To initialize a Juvix project interactively in the current directory, use <code>juvix init</code>.</p> <p>To verify correct project root detection by Juvix, run <code>juvix dev root File.juvix</code>.</p> <p>Refer to: Modules Reference.</p>"},{"location":"howto/compilation/#compiling-to-vampir-backend","title":"Compiling to VampIR Backend","text":"<p>For the VampIR backend, the <code>main</code> function must have type:</p> <pre><code>Ty1 -&gt; ... -&gt; Tyn -&gt; TyR</code></pre> <p>Here, <code>Tyi</code>,<code>TyR</code> are <code>Nat</code>, <code>Int</code> or <code>Bool</code>. The compiler adds an equation to the generated VampIR file that states the relationship between the input and output of the <code>main</code> function:</p> <pre><code>main arg1 .. argn = out</code></pre> <p>Here, <code>arg1</code>, ... ,<code>argn</code> are the argument names of <code>main</code> found in the source code. If <code>main</code> returns a boolean (<code>Bool</code>), the compiler uses <code>1</code> (true) instead of <code>out</code>.</p> <p>The variables <code>argi</code>,<code>out</code> in the generated file are unbound VampIR variables for which VampIR solicits witnesses during proof generation.</p> <p>For example:</p> <pre><code>main (x y : Nat) : Bool := x + y &gt; 0;</code></pre> <p>Generates the equation:</p> <pre><code>main x y = 1</code></pre> <p>The <code>main</code> input argument names in the generated VampIR file can also be specified with the <code>argnames</code> pragma:</p> <pre><code>{-# argnames: [a, b] #-}\nmain (x y : Nat) : Bool := x + y &gt; 0;</code></pre> <p>Generates the equation:</p> <pre><code>main a b = 1</code></pre>"},{"location":"howto/contributing/","title":"Contributing to Juvix","text":"<p>Thank you for considering contributing to Juvix! We welcome all contributions, big or small, of any kind. We appreciate any help/feedback we can get.</p>"},{"location":"howto/contributing/#getting-started","title":"Getting Started","text":"<p>Make sure you have followed the installation instructions and have a working Juvix installation. You can also use the web-based development environment ready to the Juvix development, Juvix Github Codespace</p> <ol> <li>Fork the repository.</li> <li>Clone your forked repository to your local machine.</li> <li>Install Stack if you    haven't already.</li> <li>Build the project by running <code>stack build</code>. To build the project with    optimizations, run <code>stack build --fast</code>. To install the binaries to your    local <code>~/.local/bin</code>, run <code>stack install</code>.</li> <li>Run the tests by running <code>stack test</code>.</li> <li>Make sure to install the pre-commit binary, so you    can run the pre-commit hooks by running <code>make precommit</code> in the root    directory of the project. All the Pull Requests will be checked by the    pre-commit hooks.</li> </ol>"},{"location":"howto/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your changes: <code>git checkout -b my-branch-name</code>. In case you are working on an issue, please name your branch after the issue number, e.g. <code>issue-123</code>.</li> <li>Make your changes and commit them with a descriptive message.</li> <li>Push your changes to your forked repository: <code>git push origin my-branch-name</code>.</li> <li>Submit a pull request to the main repository with a concise description of your changes.</li> <li>Make sure that your pull request passes all the tests and pre-commit hooks.</li> </ol>"},{"location":"howto/contributing/#haskell-code-style","title":"Haskell Code Style","text":"<p>We value readability and maintainability over saving lines of code. The best source of truth for the Juvix code style is the existing codebase. We strongly encourage you to look at the existing code and follow the same style. Open an issue if you have any questions, or better yet, join our Discord and ask there!</p> <p>Some basic guidelines when writing code:</p> <ul> <li>Use clear and descriptive names for variables, functions, and types.</li> <li>Keep functions short and focused on a single task. Separate functions when   they start to get too long.</li> <li>Use comments to explain complex or non-obvious code.</li> <li>Run <code>make format</code> to format your code with <code>ormolu</code>.</li> </ul>"},{"location":"howto/contributing/#testing","title":"Testing","text":"<p>Please include tests for any new functionality or bug fixes. The tests are located in the <code>test</code> directory, the tests are written in Haskell and use the tasty framework. To run the tests, run <code>stack test</code>. If you are changing the CLI, please also update the smoke tests in the <code>tests/smoke</code> directory.</p>"},{"location":"howto/contributing/#code-review","title":"Code Review","text":"<p>All pull requests will be reviewed by at least one member of the development team. Feedback may be provided on the code itself, as well as on the tests and documentation.</p> <p>Thank you for contributing to Juvix!</p>"},{"location":"howto/installing/","title":"Installing Juvix","text":""},{"location":"howto/installing/#prerequisites","title":"Prerequisites","text":"<p>You need Clang / LLVM version 13 or later. Note that on macOS the preinstalled clang does not support the wasm target, so use e.g. <code>brew install llvm</code> instead.</p> <p>If you want to compile to WebAssembly, you also need:</p> <ul> <li>wasmer</li> <li>wasi-sdk</li> <li>wasm-ld - the LLVM linker for WASM (NB: On   Linux you may need to install the <code>lld</code> package; on macOS this is   installed as part of <code>llvm</code>).</li> </ul> <p>See below for instructions on how to install the dependencies.</p>"},{"location":"howto/installing/#shell-script","title":"Shell script","text":"<p>We provide a shell script that installs the Juvix compiler binary for Linux and macOS using the GitHub release page.</p> <p>Copy and paste the following command into your terminal to install Juvix.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSfL https://get.juvix.org | sh</code></pre> <p>In VSCode, install Juvix automatically with the Juvix VSCode   extension.</p>"},{"location":"howto/installing/#macos","title":"MacOS","text":"<p>The easiest way to install Juvix on MacOS is by using Homebrew.</p> <p>To install the homebrew-juvix tap, run:</p> <pre><code>brew tap anoma/juvix</code></pre> <p>To install Juvix, run:</p> <pre><code>brew install juvix</code></pre> <p>Helpful information can also be obtained by running:</p> <pre><code>brew info juvix</code></pre>"},{"location":"howto/installing/#linux-x86_64","title":"Linux x86_64","text":"<p>A Juvix compiler binary executable for Linux x86_64 is available on the Juvix release page.</p> <p>To install this executable, download and unzip the linked file and move it to a directory on your shell's <code>PATH</code>.</p> <p>For example if <code>~/.local/bin</code> is on your shell's <code>PATH</code>, you can install Juvix as follows:</p> <pre><code>cd /tmp\ncurl https://api.github.com/repos/anoma/juvix/releases/latest \\\n  | grep \"browser_download_url.*linux\" \\\n  | cut -d : -f2,3 | tr -d \\\" \\\n  | xargs curl -L -o linux_release.zip\nunzip linux_release.zip\nmv juvix ~/.local/bin/juvix</code></pre>"},{"location":"howto/installing/#building-juvix-from-source","title":"Building Juvix from source","text":"<p>To install Juvix from source you must clone the GitHub repository. Then Juvix can be installed with the following commands. We assume you have Stack and GNU Make installed.</p> <pre><code>git clone --recursive https://github.com/anoma/juvix.git\ncd juvix\nmake install</code></pre> <p>The C compiler and linker paths can be specified as options to the <code>make install</code> command, e.g.</p> <pre><code>make install CC=path/to/clang LIBTOOL=path/to/llvm-ar</code></pre> <p>On macOS, you can alternatively run the following command for Homebrew. The flag <code>--HEAD</code> used below is optional \u2013 use it to build the latest version of Juvix in the <code>main</code> branch on GitHub.</p> <pre><code>brew install --build-from-source --HEAD juvix --verbose</code></pre>"},{"location":"howto/installing/#building-the-project-with-cabal","title":"Building the project with <code>cabal</code>","text":"<p>We recommend using the <code>stack</code> build tool with this project.</p> <p>If you prefer the <code>cabal</code> build tool instead, then you need to generate the <code>juvix.cabal</code> file using hpack before running <code>cabal build</code>.</p> <p>You also need to compile the runtime first:</p> <pre><code>make runtime\ncabal build</code></pre>"},{"location":"howto/installing/#installing-dependencies","title":"Installing dependencies","text":"<p>To install <code>wasi-sdk</code> you need to download <code>libclang_rt</code> and <code>wasi-sysroot</code> precompiled archives from the wasi-sdk release page and:</p> <ol> <li> <p>Extract the <code>libclang_rt.builtins-wasm32-wasi-*.tar.gz</code> archive in     the <code>clang</code> installation root (for example <code>/usr/lib/clang/13</code> on     Ubuntu or <code>`brew --prefix llvm`</code> on macOS).</p> <p>For example on macOS with <code>homebrew clang</code>:</p> </li> </ol> <pre><code>cd `brew --prefix llvm`\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/libclang_rt.builtins-wasm32-wasi-15.0.tar.gz -OL\ntar xf libclang_rt.builtins-wasm32-wasi-15.0.tar.gz</code></pre> <ol> <li> <p>Extract the <code>wasi-sysroot-*.tar.gz</code> archive on your local system and     set <code>WASI_SYSROOT_PATH</code> to its path.</p> <p>For example:</p> </li> </ol> <pre><code>cd ~\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/wasi-sysroot-15.0.tar.gz -OL\ntar xf wasi-sysroot-15.0.tar.gz\nexport WASI_SYSROOT_PATH=~/wasi-sysroot</code></pre> <p>Checking your setup</p> <p>Run <code>juvix doctor</code> in your terminal to validate your setup.</p>"},{"location":"howto/judoc/","title":"Documenting Juvix programs with Judoc","text":""},{"location":"howto/project/","title":"How to setup a Juvix project","text":"<p>A juvix project is a collection of juvix modules plus some extra metadata gathered in a <code>juvix.yaml</code> file. The most convenient way to create a juvix project is to run the command <code>juvix init</code>.</p>"},{"location":"howto/project/#juvix-yaml-file","title":"Juvix YAML file","text":"<p>A project is rooted in a directory. The root is set by creating a <code>juvix.yaml</code>, which contains the following fields, no order is required:</p> <ul> <li><code>name</code></li> <li><code>version</code></li> <li><code>dependencies</code></li> <li><code>main</code></li> </ul> <p>The fields are explained below.</p> <ul> <li>name: This is the name assigned to the project. The name must not be empty   and cannot exceed 100 characters. Lower case letters, digits and hyphen <code>-</code>   are acceptable characters. The first letter must not be a hyphen.   Summarizing, it must match the following regexp: <code>[a-z0-9][a-z0-9-]{0,99}</code>.</li> <li>version (optional): The version of the project. It must follow the   SemVer specification. If the version is missed then it   will be assumed to be 0.0.0.</li> <li>main (optional): The main module of the project used as entry point.</li> <li>dependencies (optional): The dependencies of the project is given as a   list. See below for more information.</li> </ul> <p>Note</p> <p>As intuition would tell, a Juvix module belongs to a Juvix project if it is   placed in the subtree hanging from the root directory. This rule has two   exceptions:</p> <ol> <li>Modules in a hidden (or hanging from a hidden) directory are not part of the      project. E.g., if the root of a project is <code>dir</code>, then the module      <code>dir/.d/Lib.juvix</code> does not belong to the project rooted in <code>dir</code>.</li> <li>A <code>juvix.yaml</code> file shadows other <code>juvix.yaml</code> files in parent      directories. E.g. if the root of a project is <code>dir</code> and the files      <code>dir/juvix.yaml</code> and <code>dir/nested/juvix.yaml</code> exist, then the module      <code>dir/nested/Lib.juvix</code> would belong to the project in <code>dir/nested</code>.</li> </ol> <p>Note</p> <p>Any Juvix module outside of a project is considered a standalone module and lives in its own (global) project. In other words, there is no need to create a <code>juvix.yaml</code> file for a standalone module.</p>"},{"location":"howto/project/#package-dependencies","title":"Package dependencies","text":"<p>In order to specify the list of dependencies for a package, the field <code>dependencies</code> has been added to the <code>juvix.yaml</code>. The <code>dependencies</code> field is a list of directories (relative or absolute) or git dependencies. If the dependency is a directory then its location must contain a <code>juvix.yaml</code> file. As expected, if we add a package to the list of dependencies, we will be able to access its modules through import statements. External dependencies are supported through git dependencies.</p> <p>By default, the compiler include the standard library as a dependency, and therefore a user can use it including the following line in the <code>juvix.yaml</code></p> <pre><code># -- juvix.yaml\ndependencies:\n  - .juvix-build/stdlib/\nfile: []\nname: juvix-docs\nversion: 0.0.0</code></pre>"},{"location":"howto/project/#external-dependencies","title":"External dependencies","text":"<p>To use external dependencies, it is required to have <code>git</code> installed. You can add a git block to the dependencies list:</p> <pre><code>name: HelloWorld\nmain: HelloWorld.juvix\ndependencies:\n  - .juvix-build/stdlib\n  - git:\n      url: https://my.git.repo\n      name: myGitRepo\n      ref: main\nversion: 0.1.0</code></pre> <p>Git block required fields:</p> <ul> <li> <p><code>url</code>: The URL of the git repository</p> </li> <li> <p><code>ref</code>: The git reference that should be checked out</p> </li> </ul> <p>Note</p> <p>The values of the <code>name</code> fields must be unique among the git blocks in the dependencies list.</p> <ul> <li><code>name</code>: The name for the dependency. This is used to name the   directory of the   clone, it is required. Perhaps we could come up with a way to automatically   name the clone directory. Current ideas are to somehow encode the URL / ref   combination or use a UUID. However, there's some value in having the clone   directory named in a friendly way.</li> </ul>"},{"location":"howto/project/#behaviour","title":"Behaviour","text":"<p>When dependencies for a package are registered, at the beginning of the compiler pipeline, all remote dependencies are processed:</p> <ol> <li>If it does not already exist, the remote dependency is cloned to    <code>.juvix-build/deps/$name</code></li> <li><code>git fetch</code> is run in the clone</li> <li><code>git checkout</code> at the specified <code>ref</code> is run in the clone</li> </ol> <p>Note</p> <ul> <li>Remote dependencies of transitive dependencies are also processed.</li> <li>The <code>git fetch</code> step is required for the case where the remote is updated.</li> </ul>"},{"location":"howto/project/#fixing-errors","title":"Fixing errors","text":"<ul> <li>Missing fields in the Git dependency block are YAML parse errors</li> <li>Duplicate <code>name</code> values in the dependencies list is an error thrown when the package file is processed</li> <li>The <code>ref</code> does not exist in the clone or the clone directory is otherwise   corrupt. An error with a suggestion to <code>juvix clean</code> is given. The package   file path is used as the location in the error message.</li> <li>Other <code>git</code> command errors (command not found, etc.), a more verbose error is   given with the arguments that were passed to the git command.</li> </ul>"},{"location":"howto/quick-start/","title":"Quick Start","text":"<p>To install Juvix, follow the instructions in the installation guide.</p> <p>After installation, run <code>juvix --help</code> to see the list of commands.</p> <p>Run Juvix doctor to check your system setup:</p> <pre><code>juvix doctor</code></pre>"},{"location":"howto/quick-start/#cli-usage-examples","title":"CLI Usage Examples","text":"<p>Create a new package:</p> <pre><code>juvix init</code></pre> <p>Evaluate a source file:</p> <pre><code>juvix eval path/to/source.juvix</code></pre> <p>Compile a source file into a native executable:</p> <pre><code>juvix compile path/to/source.juvix</code></pre> <p>Compile a source file into a WebAssembly binary:</p> <pre><code>juvix compile -t wasm32-wasi path/to/source.juvix</code></pre> <p>Launch the REPL:</p> <pre><code>juvix repl</code></pre> <p>Typecheck a source file:</p> <pre><code>juvix typecheck path/to/source.juvix</code></pre> <p>Generate HTML representations of a source file and its imports:</p> <pre><code>juvix html --recursive path/to/source.juvix</code></pre>"},{"location":"howto/quick-start/#the-hello-world-example","title":"The Hello World example","text":"<p>This is the Juvix source code of the traditional Hello World program.</p> <pre><code>-- HelloWorld.juvix\nmodule HelloWorld;\n\nimport Stdlib.Prelude open;\n\nmain : IO := printStringLn \"hello world!\";</code></pre> <p>To compile and run a binary generated by Juvix, save the source code to a file called <code>HelloWorld.juvix</code> and run the following command from the directory containing it:</p> <pre><code>juvix compile HelloWorld.juvix\n./HelloWorld</code></pre> <p>You should see the output: <code>hello world!</code></p> <p>The source code can also be compiled to a WebAssembly binary. This requires some additional setup. See the Installation How-to for more information. You can also run <code>juvix doctor</code> to check your setup.</p> <pre><code>juvix compile --target wasm32-wasi HelloWorld.juvix\nwasmer HelloWorld.wasm</code></pre>"},{"location":"notes/lsp/","title":"LSP support","text":"<p>We provide a sample <code>hie.yaml</code> configuration file for both <code>cabal</code> and <code>stack</code>.</p> <p>If you prefer <code>stack</code>, run:</p> <pre><code>cp stack.hie.yaml hie.yaml</code></pre> <p>If you prefer <code>cabal</code>, run:</p> <pre><code>cp cabal.hie.yaml hie.yaml</code></pre>"},{"location":"notes/runtime-benchmark-results/","title":"Benchmarks of the new Juvix runtime","text":"<p>Benchmarked version: commit 148ececb4d4259eacbb980f5992073a3ac611d82 from 31.10.2022</p>"},{"location":"notes/runtime-benchmark-results/#summary","title":"Summary","text":"<p>We benchmark several programs manually compiled into the primitives of the new Juvix runtime. The code corresponds closely to the code that will be generated by the new compilation process, with basic low-level optimisations (unboxing, untagging, etc.) but without any high-level optimisations on JuvixCore (inlining, specialisation, constant folding, fusion, etc.). This corresponds to the compilation process planned for the 0.4 milestone.</p> <p>We compare the running time and memory usage with analogous programs written in Haskell, OCaml, JuvixCore (using the evaluator), current Juvix (with the \"direct\" transpilation to C) and C.</p> <p>The results suggest that for most first-order programs the new compilation process will produce code with running time comparable to the code produced by the native OCaml compiler. For higher-order programs heavy on closure manipulation, the results are acceptable but noticeably worse, especially with third-order functions (i.e. functions which take functions taking functions). This could, however, be alleviated by implementing the specialisation optimisation (see the \"specialised\" column in the <code>ackermann</code> and <code>mapfun</code> benchmarks). Besides, functional programs of order higher than two are rare.</p> <p>The comparisons with OCaml and Haskell were not entirely fair because the new Juvix runtime does not perform garbage collection. The overhead of garbage collection is particularly visible on the <code>mergesort</code> benchmark which creates many intermediate data structures that are quickly discarded. With proper memory management, the running time results on first-order programs for the new Juvix runtime are expected to become slightly worse than for the native OCaml compiler.</p> <p>For simple programs operating on integers which don't require any heap memory allocation (<code>fibonacci</code> and <code>combinations</code> benchmarks), the direct transpilation to C in the current Juvix seems to perform best (behind only C). The reason is that for very simple programs `clang` can better optimise the output of such a direct transpiler. The main problem with the transpilation to C approach is that it cannot scale to reliably work for more complex programs, as evidenced by the segfaults, longer running time and higher memory use on other benchmarks.</p> <p>In addition to the <code>fibonacci</code> and <code>combinations</code> benchmarks, the advantage of direct transpilation for very simple programs is also visible on the <code>fold</code> benchmark where a simple loop over a list dominates the running time. However, this is partly because the compilation of closures in current Juvix is incorrect allowing it to be more efficient.</p>"},{"location":"notes/runtime-benchmark-results/#benchmark-programs","title":"Benchmark programs","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci","title":"fibonacci","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)</p> <p>The Nth Fibonacci number is computed in O(N). Needs only constant stack space and no heap memory. This benchmark tests the efficiency of tail recursion and arithmetic operations.</p>"},{"location":"notes/runtime-benchmark-results/#combinations","title":"combinations","text":"<p>Count combinations of numbers 1 to N having sum N (N = 100)</p> <p>This benchmark tests the efficiency of general recursion. No heap memory needs to be allocated. Uses stack space proportional to N. The running time is exponential in N.</p>"},{"location":"notes/runtime-benchmark-results/#prime","title":"prime","text":"<p>Compute the Nth prime (N = 16384)</p> <p>The Nth prime number is computed via the Eratosthenes sieve. A list of N primes is created. No intermediate lists are discarded (garbage collection not needed). This benchmark tests the efficiency of tail recursion, arithmetic operations, list cell allocation and access.</p>"},{"location":"notes/runtime-benchmark-results/#mergesort","title":"mergesort","text":"<p>Merge sort a list of N integers (N = 2\u2019000\u2019000)</p> <p>At each level of merge sort intermediate lists are created and discarded. The running time for this benchmark largely depends on the efficiency of memory management. Here one may observe the overhead of garbage collection or the memory blow-up if no garbage collection is used.</p>"},{"location":"notes/runtime-benchmark-results/#maybe","title":"maybe","text":"<p>Optionally sum N integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)</p> <p>If a fixed number k is encountered in the tree then the result is <code>Nothing</code>, otherwise it is <code>Just sum</code>. The computation is repeated for values of k from 0 to K. This tests the efficiency of handling optional values and data structure access.</p>"},{"location":"notes/runtime-benchmark-results/#fold","title":"fold","text":"<p>Fold a list of N integers K times (N = 100\u2019000, K = 1000)</p> <p>The sum of N natural numbers is computed via fold<sub>left</sub> (tail-recursive). The computation is repeated K times. The list is created only once, so that allocation time does not dominate. This benchmark tests the efficiency of closure call and list cell access.</p>"},{"location":"notes/runtime-benchmark-results/#cps","title":"cps","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)</p> <p>The function computing the Nth Fibonacci number is written in continuation-passing style, tail-recursively calling a continuation supplied as an argument. This benchmark tests the efficiency of closure call and allocation.</p>"},{"location":"notes/runtime-benchmark-results/#mapfold","title":"mapfold","text":"<p>Map and fold a list of N integers K times (N = 10000, K = 10000)</p> <p>This benchmark tests the efficiency of standard higher-order functions on lists, closure call and memory management. The program allocates O(K) intermediate lists of length N which are quickly discarded.</p>"},{"location":"notes/runtime-benchmark-results/#ackermann","title":"ackermann","text":"<p>Compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)</p> <p>The higher-order Ackermann function definition iterates an iteration of function compositions. Hence, it uses a third-order invocation of an iteration function. This benchmark tests the efficiency of creating and calling second-order closures, and of partial application.</p>"},{"location":"notes/runtime-benchmark-results/#mapfun","title":"mapfun","text":"<p>Successively map K functions to a list of N integers (K = 100, N = 10000)</p> <p>The benchmark stores K second-order closures in a list, maps them successively to a list of K closures, and then successively maps the K closures from the result to a list of N integers. This benchmark tests the efficiency of manipulating closures and storing them in data structures.</p> <p>The benchmark programs can be found in <code>tests/benchmark</code> in the Juvix source directory.</p>"},{"location":"notes/runtime-benchmark-results/#methodology","title":"Methodology","text":"<p>For each program the total running time (elapsed real time) and memory use (maximum resident set size) were measured on an M1 iMac with no significant background activity. Averages of several runs were taken. The variance was negligible, unless indicated otherwise by providing a range.</p>"},{"location":"notes/runtime-benchmark-results/#results","title":"Results","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci_1","title":"fibonacci","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.26 0.35 0.35 0.23 13.15 10.03 0.39 0.35 0.94 0.16 0.22 Memory use (MB, max RSS) 1.5 3.8 1.3 8.8 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#combinations_1","title":"combinations","text":"<p>Count all combinations of numbers 1 to N having sum N (N = 1000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 6.67 11.25 3.22 5.1 441.71 5.48 5.48 6.53 41.08 2.69 4.80 Memory use (MB, max RSS) 1.5 3.9 1.3 8.9 22.3 9.6 9.6 1.7 1.9 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#prime_1","title":"prime","text":"<p>Compute the Nth prime (N = 16384)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.52 1.91 segfault 3.09 167.04 3.85 3.85 1.68 14.82 0.12 0.13 Memory use (MB, max RSS) 1.7 4.0 segfault 9.3 24.4 9.8 9.6 2.2 2.2 1.4 4.0"},{"location":"notes/runtime-benchmark-results/#mergesort_1","title":"mergesort","text":"<p>Merge sort a list of N integers (N = 2\u2019000\u2019000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.40 0.31 3.55 1.32 22.45 2.86 2.90 1.95 3.52 0.15 0.15 Memory use (MB, max RSS) 1973.7 720.4 5046.7 2729.8 1728.9 253.6 253.6 172.6 343.1 24.4 26.8"},{"location":"notes/runtime-benchmark-results/#maybe_1","title":"maybe","text":"<p>Optionally sum N non-zero integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.64 3.29 1.57 22.75 5.58 0.59 0.30 3.57 0.27 0.50 Memory use (MB, max RSS) 1.6 3.8 2646.1 1320.9 22.4 5560.7 9.7 3.9 4.0 1.3 4.1"},{"location":"notes/runtime-benchmark-results/#fold_1","title":"fold","text":"<p>Fold a list of N integers K times (N = 100\u2019000, K = 1000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.54 0.35 0.23 15.27 0.58 0.58 0.36 1.80 NA NA Memory use (MB, max RSS) 3.1 4.6 4.4 10.6 43.4 12.7 12.7 5.9 5.9 NA NA"},{"location":"notes/runtime-benchmark-results/#cps_1","title":"cps","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.43 0.52 1.56 stack overflow 20.22 10.04 0.39 0.35 1.60 0.16 0.25 Memory use (MB, max RSS) 1.5 3.9 1539.3 stack overflow 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfold_1","title":"mapfold","text":"<p>Map and fold a list of N integers K times (N = 10000, K = 10000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.01 1.59 2.74 1.81 38.24 1.29 2.42 1.43 4.22 NA NA Memory use (MB, max RSS) 2154.5 893.0 3059.1 1542.0 26.4 10.6 10.7 7.5 10-20 NA NA"},{"location":"notes/runtime-benchmark-results/#ackermann_1","title":"ackermann","text":"<p>Compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.92 1.21 0.30 0.65 segfault runtime error 11.71 0.87 0.47 0.54 1.35 0.00 0.14 Memory use (MB, max RSS) 2.6 4.1 2.3 3.9 segfault runtime error 23.3 13.6 9.6 2.0 3.6 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfun_1","title":"mapfun","text":"<p>Successively map K functions to a list of N integers (K = 100, N = 10000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.27 1.04 0.39 0.46 segfault runtime error 4.18 1.85 0.95 0.19 0.68 NA NA Memory use (MB, max RSS) 3209.8 1229.7 21.8 13.2 segfault runtime error 33.0 13.6 11.6 5.3 7.9 NA NA"},{"location":"notes/runtime-benchmark-results/#comments","title":"Comments","text":"<p>\"New Juvix runtime\" denotes C programs written using the primitives of the new Juvix runtime. These programs were \"manually\" compiled from the corresponding Juvix/JuvixCore programs, according to the new Juvix compilation concept. They correspond closely to the code that will be generated by the basic version of the new compilation process, without any high-level optimisations (inlining, specialisation, fusion, constant folding) but with basic low-level memory representation optimisations (unboxing, untagging, etc). This version of the new compilation process should be finished with the 0.4 milestone.</p> <p>The \"specialised\" column for \"New Juvix runtime\" denotes a version of the corresponding \"New Juvix runtime\" benchmark program for which specialisation of higher-order functions was manually performed (to simulate the effects of the high-level specialisation optimisation).</p> <p>\"Current Juvix\" denotes Juvix programs compiled with the current compilation process via a \"direct\" translation to C. For a fair comparison, all number operations were implemented using native binary C integers (exposed via <code>foreign</code> and <code>compile</code> blocks) without overflow check, instead of using the unary Nat from the standard library. For Haskell, we use the fixed-precision Int instead of the arbitrary-precision Integer.</p> <p>For the simplest benchmark programs without heap memory allocation (e.g. <code>fibonacci</code>, <code>combinations</code>), the performance of \"Current Juvix\" is comparable to or better than that of \"New Juvix runtime\". This is because <code>clang</code> managed to eliminate (tail) recursion and optimise the code to essentially the same or better thing. The main problem with the current \"direct\" transpilation to C approach is that it cannot scale to reliably work for more complex programs. By \"more complex\" I mean larger program size, more functions, more complex patterns of recursion and/or the use of more functional programming features (including functional data structures). I don't mean higher computational complexity or more resource use.</p> <p>The segfaults and runtime errors for \"Current Juvix\" are consequences of incorrectly generated code (current compilation of partial application is not entirely correct) or stack overflows (when <code>clang</code> didn't figure out how to eliminate tail recursion).</p> <p>The comparison with \"Current Juvix\" is not entirely fair for benchmarks that test the manipulation and calling of closures (e.g. <code>fold</code>). Current Juvix achieves good performance (when it doesn't segfault) at the expense of correctness: partial application is not compiled correctly and fixing this would require a fundamental change in closure representation.</p> <p>The comparison with Haskell and OCaml compilers is not entirely fair, because the new Juvix runtime does not perform garbage collection. With the GC overhead, I would expect the Juvix runtime results for native compilation of first-order programs to become a bit worse than the native OCaml versions. The GC overhead is particularly noticeable for the <code>mergesort</code> benchmark which creates many large intermediate lists. The memory usage of the Juvix runtime is much higher on this benchmark than the memory usage of OCaml or Haskell versions. The relatively small time difference between the OCaml native and bytecode versions of <code>mergesort</code> also indicates that GC accounts for a significant part of the running time.</p> <p>Another small overhead will be introduced by bounds checking for integer operations. Currently, the new Juvix runtime operates on unboxed 31-bit (or 63-bit) integers without checking for integer overflow.</p> <p>If we decide to default to transparent arbitrary-precision integers, then another small overhead will be introduced by the need to check the integer representation with each arithmetic operation.</p> <p>Admittedly, the programs were deliberately written in a way to make high-level optimisations unnecessary, except specialisation for higher-order functions (mostly in <code>ackermann</code> and <code>mapfun</code>). This also explains the good performance of the OCaml native compiler which doesn't do much high-level optimisation.</p> <p>In the \"Current Juvix\" and OCaml version of <code>mergesort</code>, to avoid stack overflow the <code>merge</code> function was written tail-recursively with accumulator reversal at the end. This is not necessary for the new Juvix runtime, because the stack is dynamically extended when needed.</p> <p>As evidenced by the <code>combinations</code> benchmark, for non-tail-recursive direct calls our code performs worse than the code which uses the C / WebAssembly stack and function call mechanisms. However, in general it is impossible to directly use the C / WebAssembly stack and call mechanisms for a purely functional language. Since we dynamically allocate the stack segments when needed, stack overflow is impossible. This is convenient in an eager functional language. Otherwise, one needs to rewrite all functions operating on large data to use tail recursion. We pay for this convenience with a small overhead, which is the main reason for poorer performance on <code>combinations</code> where stack manipulation cost dominates.</p> <p>Haskell's laziness seems to introduce more overhead than I expected. This would explain the comparatively better performance of the native OCaml compiler. The problem is particularly stark when Haskell's strictness analysis fails for some reason, as in the <code>fibonacci</code> benchmark. The second \"Haskell\" column with the \"-XStrict\" flag for GHC indicates the version of the benchmark compiled with strictness as the default.</p> <p>The C versions of the programs were written to take advantage of C's imperative features, e.g., using arrays instead of lists, loops instead of recursion. No C versions are provided for some benchmarks designed to test specifically functional language features.</p> <p>With the new Juvix runtime, the 32-bit WebAssembly version of <code>mergesort</code> is faster than the 64-bit native version because it needs roughly half as much memory (the word size is 4 bytes instead of 8). The difference is even starker between the WebAssembly and native versions of <code>mergesort</code> for \"Current Juvix\".</p> <p>There seems to be a memory leak in the JuvixCore evaluator. This is what happens too often when one uses a lazy language.</p> <p>Haskell also leaks memory in the Fibonacci benchmark, despite it being a simple tail-recursive program. It seems strictness analysis didn't work.</p>"},{"location":"reference/benchmarks/","title":"Benchmarks","text":""},{"location":"reference/examples/","title":"Examples of programs written in Juvix","text":"<p>The following links are clickable versions of their corresponding Juvix program. The sources can be found in the examples/milestone directory in the Juvix repository. The webpages can be generated by running the following command:</p> <pre><code>juvix html --recursive FileName.juvix</code></pre> <ul> <li>HelloWorld.juvix</li> <li>Fibonacci.juvix</li> <li>Hanoi.juvix</li> <li>PascalsTriangle.juvix</li> <li>Collatz.juvix</li> <li>TicTacToe.juvix</li> </ul>"},{"location":"reference/judoc/","title":"Native Documentation Tool","text":"<p>Inspired by Haddock and Agda, Juvix has its own documentation tool called Judoc.</p> <p>Judoc is used to document parts of your code. You can attach Judoc blocks to the following entities:</p> <ul> <li>A module.</li> <li>A type definition.</li> <li>A constructor definition.</li> <li>A type signature of a function.</li> <li>An axiom definition.</li> </ul> <p>In order to attach documentation to any of these entities, write blocks of documentation before them:</p> <ol> <li>For modules:</li> </ol> <pre><code>--- This module is cool\nmodule Cool;\n..</code></pre> <ul> <li>For type definitions:</li> </ul> <pre><code>--- Unary representation of natural numbers\ntype Nat : Type :=\n  | --- Nullary constructor representing number 0\n    zero : Nat\n  | --- Unary constructor representing the successor of a natural number\n    suc : Nat -&gt; Nat;</code></pre> <ul> <li>For type signatures (and likewise for axioms):</li> </ul> <pre><code>--- The polymorphic identity function\nid : {A : Type} -&gt; A -&gt; A;</code></pre> <p>Next we define the syntax of Judoc blocks.</p>"},{"location":"reference/judoc/#block","title":"Block","text":"<p>A block can be one of these:</p> <ol> <li>A paragraph.</li> <li>An example.</li> </ol> <p>Blocks are separated by a line with only <code>---</code>. For instance, this is a sequence of two blocks:</p> <pre><code>--- First block\n---\n--- Second block</code></pre> <p>Note that the following is a single block since it lacks the <code>---</code> separator:</p> <pre><code>--- First block\n\n--- Still first block</code></pre> <p>Alternatively, you can use block Judoc comments for that:</p> <pre><code>{-- First block\n\nSecond block\n---}</code></pre>"},{"location":"reference/judoc/#paragraph","title":"Paragraph","text":"<p>A paragraph is a non-empty sequence of lines.</p> <p>For instance, the following is a paragraph with two lines:</p> <pre><code>--- First line\n--- Second line</code></pre> <p>Note that a rendered paragraph will have have no line breaks. If you want to have line breaks, you will need to split the paragraph. Hence, the paragraph above will be rendered as</p> <pre><code>First line Second line</code></pre>"},{"location":"reference/judoc/#line","title":"Line","text":"<p>A line starts with <code>---</code> and is followed by a non-empty sequence of atoms.</p> <p>For instance, the following is a valid line:</p> <pre><code>--- A ;Pair Int Bool; contains an ;Int; and a ;Bool;</code></pre>"},{"location":"reference/judoc/#atom","title":"Atom","text":"<p>An atom is either:</p> <ol> <li>A string of text (including spaces but not line breaks).</li> <li>An inline Juvix expression surrounded by <code>;</code>.</li> </ol> <p>For instance, the following are valid atoms:</p> <ol> <li><code>I am some text.</code></li> <li><code>;Pair Int Bool;</code></li> </ol>"},{"location":"reference/judoc/#example","title":"Example","text":"<pre><code>--- &gt;&gt;&gt; someExpression ;</code></pre> <p>The <code>someExpression</code> can span multiple lines and it must be ended with a <code>;</code>. For instance:</p> <pre><code>--- &gt;&gt;&gt; 1\n        + 2\n        + 3;</code></pre>"},{"location":"reference/stdlib/","title":"Standard library","text":"<p>The Juvix standard library contains common functions that can be used in Juvix programs.</p>"},{"location":"reference/language/","title":"About","text":"<p>Juvix is designed with a focus on safety. The Juvix compiler runs several static analyses which guarantee the absence of runtime errors. Analyses performed include termination and type checking. As a result, functional programs, especially validity predicates, can be written with greater confidence in their correctness.</p> <p>Some language features in Juvix include:</p> <ul> <li>Haskell/Agda-like syntax with support for Unicode</li> <li>Type inference</li> <li>Parametric polymorphism</li> <li>User defined inductive data types</li> <li>Higher-order functions</li> <li>Referential transparency</li> </ul> <p>The Juvix module system allows developers to break down their programs into smaller, reusable modules that can be compiled separately and combined to create larger programs. These modules can be used to build libraries, which can then be documented using Juvix's built-in documentation generation tool, see for example, the Juvix standard library's website.</p>"},{"location":"reference/language/#related-internal-reports","title":"Related internal reports","text":"<p>An ongoing effort to specify the Juvix language and internal representations along its semantics is being carried out in the form of internal reports. These reports are written for our own internal use and are not intended to be read by the public, at least for now. However, we are making them available here for the sake of transparency.</p> Title Doi/url Date Juvix to VampIR Pipeline 10.5281/zenodo.8268823 Aug 14, 2023 The Core language of Juvix 10.5281/zenodo.8297159 Aug 29, 2023 Geb Pipeline 10.5281/zenodo.8262747 Aug 21, 2023 Rethinking VampIR 10.5281/zenodo.8262815 Aug 29, 2023"},{"location":"reference/language/aliases/","title":"Aliases","text":"<p>Aliases serve as shorthand for terms, functions, and types, enhancing readability. Introduced through the declaration,</p> <pre><code>syntax alias &lt;originalName&gt; := &lt;AlternativeName&gt;;</code></pre> <p>these new names are interchangeable with the aliased name, applicable in pattern matching, qualification, and module opening.</p>"},{"location":"reference/language/aliases/#application-of-aliases","title":"Application of Aliases","text":"<p>Aliases can be forward referenced, permitting their use prior to declaration. For instance, we define the alias Boolean for the <code>Bool</code> type, and their terms <code>true</code> and <code>false</code> as <code>\u22a4</code> and <code>\u22a5</code> respectively.</p> <pre><code>syntax alias Boolean := Bool;\nsyntax alias \u22a5 := false;\nsyntax alias \u22a4 := true;\n\ntype Bool :=\n  | false\n  | true;\n\nnot : Boolean -&gt; Boolean\n  | \u22a5 := \u22a4\n  | \u22a4 := \u22a5;</code></pre> <p>Aliases exhibit versatility in application. They can be used in local definitions, as shown in the <code>let</code> expression below.</p> <pre><code>localAlias : Binary -&gt; Binary\n  | b :=\n    let\n      syntax alias b' := b;\n    in b';</code></pre> <p>Like any other name, aliases can be exported from a module.</p> <pre><code>module ExportAlias;\n  syntax alias Binary := Bool;\n  syntax alias one := \u22a4;\n  syntax alias zero := \u22a5;\nend;\n\nopen ExportAlias;\n\nsyntax operator || logical;\n|| : Binary -&gt; Binary -&gt; Binary\n  | zero b := b\n  | one _ := one;</code></pre> <p>We can create aliases for not only types but also terms, including functions. For example, the binary <code>||</code> function can be aliased as <code>or</code>.</p> <pre><code>syntax alias or := ||;\n\nor3 (a b c : Binary) : Binary := or (or a b) c;</code></pre>"},{"location":"reference/language/axioms/","title":"Axiom","text":"<p>Axioms or postulates can be introduced by using the <code>axiom</code> keyword. For example, let us imagine one wants to write a program that assumes A is a type, and there exists a term x that inhabits A. Then the program would look like the following.</p> <pre><code>module axioms;\n\naxiom A : Type;\n\naxiom x : A;</code></pre> <p>Terms introduced by the <code>axiom</code> keyword lack any computational content. Programs containing axioms not marked as builtins cannot be compiled to most targets.</p>"},{"location":"reference/language/builtins/","title":"Built-ins","text":"<p>Juvix has support for the built-in natural type and a few functions that are compiled to efficient primitives.</p>"},{"location":"reference/language/builtins/#built-in-inductive-definitions","title":"Built-in inductive definitions","text":"<pre><code>builtin nat\ntype Nat :=\n  | zero : Nat\n  | suc : Nat \u2192 Nat;</code></pre>"},{"location":"reference/language/builtins/#builtin-function-definitions","title":"Builtin function definitions","text":"<pre><code>syntax operator + additive;\nbuiltin nat-plus\n+ : Nat \u2192 Nat \u2192 Nat\n  | zero b := b\n  | (suc a) b := suc (a + b);</code></pre>"},{"location":"reference/language/builtins/#builtin-axiom-definitions","title":"Builtin axiom definitions","text":"<pre><code>  builtin nat-print\n  axiom printNat : Nat \u2192 IO;</code></pre>"},{"location":"reference/language/comments/","title":"Comments","text":"<p>Comments follow the same syntax as in <code>Haskell</code> and <code>Agda</code>. Be aware, Juvix has no support for nested comments.</p> <ul> <li>Inline Comment</li> </ul> <pre><code>-- This is a comment!</code></pre> <ul> <li>Region comment</li> </ul> <pre><code>{-\n    This is a comment!\n-}</code></pre> <ul> <li>Judoc inline comments. These are used to document functions and types. See Judoc for more information.</li> </ul> <pre><code>--- This is a Judoc comment!</code></pre> <ul> <li>Judoc block comments. See Judoc for more information.</li> </ul> <pre><code>{--\n    This is a Judoc comment!\n--}</code></pre>"},{"location":"reference/language/control/","title":"Control Structures","text":""},{"location":"reference/language/control/#case-expressions","title":"Case Expressions","text":"<p>The syntax for a case expression is:</p> <pre><code>case &lt;expression&gt; of {\n  | &lt;pat1&gt; := &lt;branch1&gt;\n  ..\n  | &lt;patN&gt; := &lt;branchN&gt;\n  }</code></pre> <p>For instance, evaluation of the following expression in the REPL yields <code>1</code>:</p> <pre><code>Stdlib.Prelude&gt; case 2 of { | zero := 0 | suc x := x }\n1</code></pre>"},{"location":"reference/language/control/#lazy-builtins","title":"Lazy Builtins","text":"<p>The standard library offers several lazily evaluated builtin functions. These must be fully applied.</p> <ul> <li><code>if condition branch1 branch2</code>: Evaluates <code>condition</code> first, returns <code>branch1</code> if true, else returns <code>branch2</code>.</li> <li><code>a || b</code>: Lazy disjunction. Evaluates <code>a</code> first, returns true if true, else evaluates and returns <code>b</code>.</li> <li><code>a &amp;&amp; b</code>: Lazy conjunction. Evaluates <code>a</code> first, returns false if false, else evaluates and returns <code>b</code>.</li> <li><code>a &gt;&gt; b</code>: Sequences two IO actions, lazy in the second argument.</li> </ul>"},{"location":"reference/language/datatypes/","title":"Data Types","text":"<p>A data type, also known as an inductive type, is a type with elements constructed from a finite set of constructors.</p> <p>In the following example, we define a data type <code>Bool</code> with two constructors, <code>true</code> and <code>false</code>.</p> <pre><code>type Bool :=\n  | true : Bool\n  | false : Bool;</code></pre> <p>A declaration of a data type consists of the keyword <code>type</code>, followed by a unique name, type parameters, and constructors.</p> <pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n    | &lt;constructor1&gt; : &lt;type1&gt;\n    | ...\n    | &lt;constructorn&gt; : &lt;typen&gt;;</code></pre> <p>The syntax for declaring a data type varies (see the ADT syntax and record syntax) but the most general syntax is the one above.</p> <p>In this syntax:</p> <ul> <li> <p><code>&lt;name&gt;</code> represents a unique name for the declared data type.</p> </li> <li> <p><code>&lt;type-parameters&gt;</code> denote type parameters in the form <code>A B C ...</code> or with   typing information <code>(A : Type)</code>. These parameters are optional and define the   return type of the constructors, i.e., <code>&lt;name&gt; &lt;type-parameters&gt;</code>.</p> </li> <li> <p><code>&lt;constructor1&gt;</code> ... <code>&lt;constructorn&gt;</code> are the constructors of the data type.   Each constructor has a unique name and a type, which can be the type of the   declared data type or a function type from the types of the arguments to the   type of the declared data type.</p> </li> </ul> <p>Note</p> <p>A data type declaration implicitly declares a module with the same name as the data type, containing the symbols of the constructors, and the type of the data type itself. One can open this module to access these symbols or hide it to prevent access to them.</p>"},{"location":"reference/language/datatypes/#example-data-types","title":"Example data types","text":"<p>The <code>Unit</code> type, the simplest data type, has a single constructor named <code>unit</code>.</p> <pre><code>type Unit := unit : Unit;</code></pre> <p>We then declare the <code>Nat</code> type, representing unary natural numbers. It introduces two constructors: <code>zero</code> and <code>suc</code>. For instance, <code>suc zero</code> represents one, while <code>suc (suc zero)</code> represents two.</p> <pre><code>type Nat :=\n  | zero : Nat\n  | suc : Nat -&gt; Nat;</code></pre> <p>These constructors function as regular functions or patterns in pattern matching when defining functions. Here is an example of a function adding two natural numbers:</p> <pre><code>syntax operator + additive;\n+ : Nat -&gt; Nat -&gt; Nat\n  | zero b := b\n  | (suc a) b := suc (a + b);</code></pre>"},{"location":"reference/language/datatypes/#adt-syntax","title":"ADT syntax","text":"<p>As an alternative to the above syntax, we can use a more familiar and compact syntax for declaring data types. This syntax is inspired by ADT syntax in Haskell.</p> <pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n  | &lt;constructor1&gt; &lt;arg1-1&gt; ... &lt;arg1-n&gt;\n  | ...\n  | &lt;constructorN&gt; &lt;argn-1&gt; ... &lt;argn-n&gt;;</code></pre> <p>Different from the previous presentation, here the constructors do not have typing information.</p> <p>If a type constructor as above has no arguments, then its type is the type of the data type being declared. In the case the type constructor has arguments, then its type is the function type from the types of the arguments to the type of the data type being declared.</p> <p>For example, the <code>Nat</code> type can be declared as follows:</p> <pre><code>  type Nat :=\n    | Z\n    | S Nat;</code></pre> <p>Another example is the <code>List</code> type, which is polymorphic in the type of its elements.</p> <pre><code>  type List A :=\n    | Nil\n    | Cons A (List A);</code></pre>"},{"location":"reference/language/datatypes/#polymorphic-data-type","title":"Polymorphic data type","text":"<p>A data type can possess type parameters. When a data type has a type parameter <code>A</code>, it is referred to as polymorphic in <code>A</code>.</p> <p>A classic example of this concept is the <code>List</code> type, which is polymorphic in the type of its list elements.</p> <pre><code>  syntax operator :: cons;\n  type List (A : Type) :=\n    | nil : List A\n    | :: : A -&gt; List A -&gt; List A;</code></pre> <p>The following function determines whether an element is in a list or not.</p> <pre><code>  import Stdlib.Data.Bool open using {Bool; false; ||};\n\n  elem {A} (eq : A -&gt; A -&gt; Bool) (s : A) : List A -&gt; Bool\n    | nil := false\n    | (x :: xs) := eq s x || elem eq s xs;</code></pre> <p>For more examples of inductive types and how to use them, see the Juvix standard library.</p>"},{"location":"reference/language/fixity/","title":"Operator Fixity","text":"<p>A fixity declaration, introduced by the <code>syntax</code> keyword followed by <code>fixity</code>, defines an operator's precedence and associativity. The syntax varies based on the operator's arity, associativity, and precedence.</p> <ul> <li>Arity declaration of an operator with no precedence or associativity:</li> </ul> <pre><code>syntax fixitiy &lt;name&gt; := &lt;arity&gt;;</code></pre> <p>Where <code>&lt;arity&gt;</code> is either <code>unary</code> or <code>binary</code>.</p> <p>This is equivalent to:</p> <pre><code>syntax fixitiy &lt;name&gt; := &lt;arity&gt; {};</code></pre> <ul> <li>Associativity declaration of an operator with no precedence:</li> </ul> <pre><code>syntax fixitiy &lt;name&gt; := &lt;arity&gt; { assoc := &lt;associativity&gt; };</code></pre> <p>Where <code>&lt;associativity&gt;</code> is either <code>left</code>, <code>right</code>, or <code>none</code>.</p> <ul> <li> <p>Precedence declaration of an operator with no associativity:</p> </li> <li> <p>Equal precedence to another operator:</p> </li> </ul> <pre><code>syntax fixitiy &lt;name&gt; := &lt;arity&gt; { same := otherOperatorName };</code></pre> <ul> <li>Higher precedence than other operators:</li> </ul> <pre><code>syntax fixitiy &lt;name&gt; := &lt;arity&gt; {\n    above := [otherOperatorName1;...; otherOperatorNameN] };</code></pre> <ul> <li>Lower precedence than other operators:</li> </ul> <pre><code>syntax fixitiy &lt;name&gt; := &lt;arity&gt; {\n    below := [otherOperatorName1;...; otherOperatorNameN] };</code></pre> <ul> <li>Associativity and precedence declaration of an operator:</li> </ul> <pre><code>syntax fixitiy &lt;name&gt; := &lt;arity&gt; {\n    assoc := &lt;associativity&gt;;\n    above := [otherOperatorName1;...; otherOperatorNameN]\n    };</code></pre>"},{"location":"reference/language/fixity/#examples-of-fixity-declarations","title":"Examples of Fixity Declarations","text":"<p>Below are a few common fixity declarations for operators in Juvix's standard library.</p> <pre><code>syntax fixity rapp := binary {assoc := right};\nsyntax fixity lapp := binary {assoc := left; same := rapp};\nsyntax fixity seq := binary {assoc := left; above := [lapp]};\n\nsyntax fixity functor := binary {assoc := right};\n\nsyntax fixity logical := binary {assoc := right; above := [seq]};\nsyntax fixity comparison := binary {assoc := none; above := [logical]};\n\nsyntax fixity pair := binary {assoc := right};\nsyntax fixity cons := binary {assoc := right; above := [pair]};\n\nsyntax fixity step := binary {assoc := right};\nsyntax fixity range := binary {assoc := right; above := [step]};\n\nsyntax fixity additive := binary {assoc := left; above := [comparison; range; cons]};\nsyntax fixity multiplicative := binary {assoc := left; above := [additive]};\n\nsyntax fixity composition := binary {assoc := right; above := [multiplicative]};</code></pre>"},{"location":"reference/language/functions/","title":"Function declarations","text":"<p>A function declaration consists of a type signature followed by a group of function clauses.</p> <p>In the following example, we define a function <code>multiplyByTwo</code>.</p> <pre><code>  import Stdlib.Data.Nat open using {Nat; *};\n\n  multiplyByTwo : Nat -&gt; Nat\n    | n := 2 * n;</code></pre> <p>The first line <code>multiplyByTwo : Nat -&gt; Nat</code> is the type signature and the second line <code>| n := 2 * n;</code> is a function clause.</p>"},{"location":"reference/language/functions/#pattern-matching","title":"Pattern matching","text":"<p>A function may have more than one function clause. When a function is called, it will pattern match on the input, and the first clause that matches the arguments is used.</p> <p>The following function has two clauses:</p> <pre><code>  import Stdlib.Data.Bool open;\n\n  neg : Bool -&gt; Bool\n    | true := false\n    | false := true;</code></pre> <p>When <code>neg</code> is called with <code>true</code>, the first clause is used and the function returns <code>false</code>. Similarly, when <code>neg</code> is called with <code>false</code>, the second clause is used and the function returns <code>true</code>.</p>"},{"location":"reference/language/functions/#short-definitions","title":"Short definitions","text":"<p>Initial function arguments that are matched against variables or wildcards in all clauses can be moved to the left of the colon in the function definition. For example,</p> <pre><code>  import Stdlib.Data.Nat open;\n\n  add (n : Nat) : Nat -&gt; Nat\n    | zero := n\n    | (suc m) := suc (add n m);</code></pre> <p>is equivalent to</p> <pre><code>  import Stdlib.Data.Nat open;\n\n  add : Nat -&gt; Nat -&gt; Nat\n    | n zero := n\n    | n (suc m) := suc (add n m);</code></pre> <p>If there is only one clause with no patterns, then the pipe <code>|</code> must be omitted:</p> <pre><code>  import Stdlib.Data.Nat open;\n\n  multiplyByTwo (n : Nat) : Nat := n;</code></pre>"},{"location":"reference/language/functions/#mutually-recursive-functions","title":"Mutually recursive functions","text":"<p>Function declarations can depend on each other recursively. In the following example, we define a function that checks if a number is <code>even</code> by calling a function that checks if a number is <code>odd</code>.</p> <pre><code>  import Stdlib.Data.Nat open;\n  import Stdlib.Data.Bool open;\n\n  import Stdlib.Prelude open;\n\n  odd : Nat -&gt; Bool\n    | zero := false\n    | (suc n) := even n;\n\n  even : Nat -&gt; Bool\n    | zero := true\n    | (suc n) := odd n;</code></pre> <p>Identifiers do not need to be defined before they are used. Then it is possible to define mutually recursive functions/types without any special syntax.</p> <p>However, there are some exceptions to this. We cannot forward reference a symbol <code>f</code> in some statement <code>s</code> if between <code>s</code> and the definition of <code>f</code> there is one of the following statements:</p> <ul> <li>Local module</li> <li>Import statement</li> <li>Open statement</li> </ul>"},{"location":"reference/language/functions/#anonymous-functions","title":"Anonymous functions","text":"<p>Anonymous functions, or lambdas, are introduced with the syntax:</p> <pre><code>\\{| pat1 .. patN_1 := clause1\n  | ..\n  | pat1 .. patN_M := clauseM }</code></pre> <p>The first pipe <code>|</code> is optional. Instead of <code>\\</code> one can also use the Unicode alternative \u2013 <code>\u03bb</code>.</p> <p>An anonymous function just lists all clauses of a function without naming it. Any function declaration can be converted to use anonymous functions:</p> <pre><code>  import Stdlib.Prelude open;\n\n  odd : Nat -&gt; Bool :=\n    \\ {\n      | zero := false\n      | (suc n) := even n\n    };\n\n  even : Nat -&gt; Bool :=\n    \\ {\n      | zero := true\n      | (suc n) := odd n\n    };</code></pre>"},{"location":"reference/language/iterators/","title":"Iterators","text":"<p>Any identifier can be declared as an iterator. The syntax to define an iterator is the following:</p> <pre><code>syntax iterator iter;</code></pre> <p>or</p> <pre><code>syntax iterator iter {init := n ; range := k};</code></pre> <p>where <code>n</code> and <code>k</code> specify the number of initializers (of the form <code>acc := a</code>) and ranges (of the form <code>x in xs</code>) in iterator application. If the number of initializers or ranges is not specified, then any number is allowed in iterator application.</p> <p>An application of an iterator <code>iter</code> has the general form</p> <pre><code>iter (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}</code></pre> <p>where <code>acci</code>, <code>xi</code> are patterns, <code>ai</code>, <code>xsi</code> are expressions, and <code>body</code> is an expression which can refer to the variables bound by the <code>acci</code>, <code>xi</code>. The braces around <code>body</code> are optional.</p> <p>The iterator application syntax is equivalent to</p> <pre><code>iter \\{acc1 .. accn x1 .. xk := body} a1 .. an xs1 .. xsk</code></pre>"},{"location":"reference/language/let/","title":"Local definitions","text":"<p>Local definitions are introduced with the <code>let</code> construct.</p> <pre><code>import Stdlib.Prelude open;\n\nsum (lst : List Nat) : Nat :=\n  let\n    go (acc : Nat) : List Nat -&gt; Nat\n      | nil := acc\n      | (x :: xs) := go (acc + x) xs;\n  in go 0 lst;</code></pre> <p>The declarations within a <code>let</code> statement share the same syntax as those inside a module. However, their visibility is limited to the expression that follows the <code>in</code> keyword.</p>"},{"location":"reference/language/modules/","title":"Module System","text":"<p>Modules facilitate the division of programs into separate files. In Juvix, this is achieved through top modules and local modules. Top modules are defined at the file's top, while local modules are nested within another module. Local modules also serve to organize different scopes within a file.</p> <p>The syntax for defining a module is:</p> <pre><code>module &lt;name&gt;;\n  &lt;body&gt;\nend;</code></pre> <p>In this syntax:</p> <ul> <li> <p><code>&lt;name&gt;</code> represents the module's name.</p> </li> <li> <p><code>&lt;body&gt;</code> is a sequence of Juvix statements (traits, data types, functions,   etc.).</p> </li> <li> <p>The <code>end</code> keyword is used to close the module definition.</p> </li> </ul> <p>Note</p> <p>The <code>end</code> keyword is optional if the module definition is the last statement in the file.</p> <p>For instance, to define a module named <code>Data.List</code>, we write:</p> <pre><code>module Data.List;\n&lt;body&gt;</code></pre>"},{"location":"reference/language/modules/#top-module-naming-convention","title":"Top module naming convention","text":"<p>Top modules that belong to a project must follow a naming convention. That is, if <code>dir</code> is the root of a project, then the module in <code>dir/Data/List.juvix</code> must be named <code>Data.List</code>.</p>"},{"location":"reference/language/modules/#import-and-open-statements","title":"Import and open statements","text":"<p>In order to access the definitions from another modules we use an import statement. To import some module named <code>Data.List</code> we will write</p> <pre><code>import Data.List;</code></pre> <p>Now, we can access the definitions in the imported module using qualified names. E.g., <code>Data.List.sort</code>.</p> <p>It is possible to import modules and give them a more convenient name thus:</p> <pre><code>import Data.List as List;</code></pre>"},{"location":"reference/language/modules/#open-statements","title":"Open statements","text":"<p>If we want to access the contents of a module without the need to qualify the names, we use an open statement. The syntax is as follows:</p> <pre><code>open Data.List;</code></pre> <p>Now we can simply write <code>sort</code>.</p> <p>It is important to remember that when we open a module, that module must be in scope, i.e., it must either be imported or defined as a local module.</p> <p>Since importing and opening a module is done often, there is special syntax for that. The following statement:</p> <pre><code>import Data.List open;</code></pre> <p>Is equivalent to this:</p> <pre><code>import Data.List;\nopen Data.List;</code></pre> <p>In general, we can combine any import statement and open statement that refer to the same module. The syntax is <code>&lt;import statement&gt; &lt;open statement without module name&gt;</code>.</p> <p>When opening a module, if we want to open an explicit subset of its definitions, we must use the <code>using</code> keyword thus:</p> <pre><code>open Data.List using {List; sort; reverse};</code></pre> <p>We can also rename symbols in an open statement thus:</p> <pre><code>open Data.List using {List; sort as listSort; reverse as reverseList};</code></pre> <p>If we want to open all definitions of a module minus a subset, we use the <code>hiding</code> keyword thus:</p> <pre><code>open Data.List hiding {head; tail};</code></pre> <p>Sometimes you might want to open or hide the type constructors of a data type. Recall that each data type defines a module containing names linked to its type constructors. For example, if you want to hide the type constructors of a data type, you must use the <code>hiding</code> keyword and module keyword as follows:</p> <pre><code>import Stdlib.Prelude open hiding {module List};</code></pre>"},{"location":"reference/language/modules/#reexport-modules","title":"Reexport modules","text":"<p>All opened definitions are available under the current module, but they are not exported by default. Meaning that if another module imports the current module, it will only be able to access the definitions defined there but not those which have been opened. If we want opened definitions to be exported, we must use the <code>public</code> keyword thus:</p> <pre><code>module Prelude;\n\nimport Data.List open public;</code></pre> <p>Now, from another module we can access definitions in <code>Data.List</code> through the <code>Prelude</code> module.</p> <pre><code>module MyModule;\n\nimport Prelude open;\n\n-- List, sort, reverse, etc. are now in scope</code></pre>"},{"location":"reference/language/modules/#local-modules","title":"Local modules","text":"<p>Juvix modules have a hierarchical structure. So far we have discussed top level modules, which have a one-to-one correspondence with files in the filesystem. On the other hand, local modules are defined within another module. They can be useful to group definitions within a file.</p> <p>The syntax for local modules is as follows:</p> <pre><code>module Path.To.TopModule;\n\nmodule ModuleName;\n  &lt;body&gt;\nend;</code></pre> <p>Note that local module names cannot contain the <code>.</code> character.</p> <p>After the definition of a local module, we can access its definitions by using qualified names. Local modules can be opened by open statements in the same way as top modules.</p> <p>Local modules inherit the scope of the parent module. Some shadowing rules apply, and they probably follow your intuition:</p> <ol> <li>Opening or defining a symbol shadows inherited instances of that symbol.</li> <li>Opening a symbol does not shadow a defined instance of that symbol in the    current module.</li> <li>Conversely, defining a symbol in the current module does not shadow an    opened instance of that symbol.</li> </ol> <p>As a consequence of 2 and 3, using a symbol that is both defined and opened locally will result in an ambiguity error. In order to solve that, the symbol that was opened, would need to be used qualified instead.</p>"},{"location":"reference/language/operators/","title":"Operator Syntax","text":"<p>The <code>syntax</code> keyword, paired with <code>operator</code>, caters for functions serving as operators. These operators often have distinct associativity and precedence from regular functions. The pairing associates a term with one fixity, defining its arity and potentially its precedence and associativity. This syntax declaration has to precede the term declaration.</p> <pre><code>syntax operator &lt;name&gt; &lt;fixity&gt;;</code></pre> <p>Where <code>&lt;fixity&gt;</code> is a previously declared fixity. Note that there are already many commons of these declarations included with the standard library. See common fixities for more information.</p> <p>For instance, we can define the <code>\u00d7</code> operator as a binary operator as follows:</p> <pre><code>syntax fixity product := binary;\n\nsyntax operator \u00d7 product;\ntype \u00d7 (a : Type) (b : Type) := , : a \u2192 b \u2192 a \u00d7 b;</code></pre>"},{"location":"reference/language/pragmas/","title":"Pragma syntax","text":"<p>Pragmas can be associated with identifiers by placing a pragma comment just before identifier declaration. For example</p> <pre><code>{-# inline: true #-}\nf : Nat -&gt; Nat;</code></pre> <p>associates the <code>inline</code> pragma with value <code>true</code> to the identifier <code>f</code>.</p> <p>Multiple pragmas associated with one identifier are separated by commas:</p> <pre><code>{-# inline: true, unroll: 100 #-}\nf : Nat -&gt; Nat;</code></pre> <p>Pragmas associated with a module are inherited by all definitions in the module, unless overridden. For example,</p> <pre><code>{-# inline: true #-}\nmodule M;\n  f : Nat -&gt; Nat := ..;\n\n  g : Nat -&gt; Nat := ..;\n\n  {-# inline: false #-}\n  h : Nat -&gt; Nat := ..;\nend;</code></pre> <p>enables inlining for <code>f</code>, <code>g</code> and disables it for <code>h</code>.</p> <p>The pragmas are just mappings in YAML syntax, except that the outermost braces are not required for the top-level mapping if it is on one line. Since pragmas are supposed to be backwards-compatible, the compiler will ignore any pragmas it doesn't recognize. Pragmas control how code is compiled by providing annotations to the compiler, but they have no semantic significance - removing all pragmas should not change the meaning of the program.</p>"},{"location":"reference/language/pragmas/#available-pragmas","title":"Available pragmas","text":"<p>We list all currently recognized pragmas. Below <code>b</code> denotes a boolean (<code>true</code> or <code>false</code>), and <code>n</code> denotes a non-negative number.</p> <ul> <li><code>inline: b</code></li> </ul> <p>Indicates whether a function should be inlined:</p> <ul> <li><code>true</code>: always inline when fully applied,</li> <li><code>false</code>: never inline (also disables automatic inlining).</li> </ul> <p>When the <code>inline</code> pragma is not present and the optimization level is at least 1, a non-recursive fully applied function is automatically inlined if the height of the body term does not exceed the inlining depth limit, which can be specified with the <code>--inline</code> option to the compile command.</p> <ul> <li><code>inline: n</code></li> </ul> <p>Indicates that a partial application of the function with at least <code>n</code> explicit arguments should always be inlined. For example, with the definition</p> <pre><code>{-# inline: 2 #-}\ncompose {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);</code></pre> <p>in the expression <code>compose f g</code> the function <code>compose</code> will be inlined, but in <code>compose f</code> it won't be.</p> <ul> <li><code>unroll: n</code></li> </ul> <p>Set the maximum recursion unrolling depth to <code>n</code>. This affects only the <code>vampir</code> and <code>geb</code> backends.</p> <ul> <li><code>argnames: [arg1, .., argn]</code></li> </ul> <p>Set the names of function arguments in the generated output to <code>arg1</code>,..,<code>argn</code>. This is useful primarily with the <code>vampir</code> backend to name VampIR input variables.</p> <ul> <li><code>format: b</code></li> </ul> <p>Enable or disable formatting for the specified module. Adding the <code>format: false</code> pragma before a module makes the formatter ignore the module and output it verbatim.</p>"},{"location":"reference/language/records/","title":"Records","text":"<p>A record is a special data type which contain one or more data constructors, each with labeled type arguments.</p> <p>For example, the following defines a record type <code>Person</code> with a single constructor <code>mkPerson</code> that takes two arguments, <code>name</code> and <code>age</code>, of types <code>String</code> and <code>Nat</code>, respectively.</p> <pre><code>  type Person :=\n    mkPerson {\n      name : String;\n      age : Nat\n    };</code></pre> <p>In each type constructor of the record, the type arguments are called fields. Each field consists of a name and type. The field's name can be used to access to the value connected with the term of the record type.</p> <p>The syntax for declaring a record type is as follows:</p> <pre><code>type &lt;record name&gt; &lt;type parameters&gt; :=\n    | &lt;type-constructor1&gt; {\n        &lt;field1-1&gt; : &lt;type1-n&gt;;\n        ...\n        &lt;field1-n&gt; : &lt;type1-n&gt;\n        }\n    | ...\n    | &lt;type-constructor-n&gt; {\n        &lt;fieldn-1&gt; : &lt;typen-1&gt;;\n        ...\n        &lt;fieldn-n&gt; : &lt;typen-n&gt;\n    };</code></pre>"},{"location":"reference/language/records/#using-records","title":"Using Records","text":"<p>Records are just like any other data type. They can be used in local definitions, exported from a module, and used in pattern matching.</p> <p>That is, one could define a record with a single constructor or multiple constructors. For instance, here is an example declaring the <code>newType</code> record type declaration with the <code>mkNewtype</code> type constructor and one filed named <code>f</code>.</p> <pre><code>type T := constructT : T;\n\ntype newtype := mkNewtype {f : T};</code></pre> <p>We could also define a record with multiple constructors. For instance, let us define the record type called <code>Pair</code> to model pairs of values. The <code>Pair</code> type has a single <code>mkPair</code> type constructor that takes two arguments, called <code>fst</code> and <code>snd</code>, of types <code>A</code> and <code>B</code>, respectively.</p> <pre><code>type Pair (A B : Type) :=\n  mkPair {\n    fst : A;\n    snd : B\n  };</code></pre> <p>To use this type, create a <code>Pair</code> type term (a pair) using the <code>mkPair</code> type constructor and supplying values for each field.</p> <pre><code>p1 : Pair T T :=\n  mkPair (fst := constructT; snd := constructT);</code></pre> <p>Field names enable access to their associated values. For instance, another pair equivalent to the one defined above can be declared using values extracted via the field names.</p> <pre><code>p1' : Pair T T :=\n  mkPair (fst := Pair.fst p1; snd := Pair.snd p1);</code></pre> <p>The fields record type's fields are qualified by the type name by default. To access the fields without the type name, use the <code>open</code> keyword to bring these names into scope.</p> <pre><code>open Pair;\n\nflipP : Pair T T := mkPair (fst := snd p1; snd := fst p1);</code></pre> <p>Lastly, let us declare a record with multiple constructors.</p> <pre><code>type EnumRecord :=\n  | C1 {\n      c1a : T;\n      c1b : T\n    }\n  | C2 {\n      c2a : T;\n      c2b : T\n    };\n\np2 : Pair EnumRecord EnumRecord :=\n  mkPair\n    (fst := C1 (c1a := constructT; c1b := constructT);\n    snd := C2 (c2a := constructT; c2b := constructT));</code></pre>"},{"location":"reference/language/traits/","title":"Traits","text":"<p>A trait is a special type of record that can be used to define a set of functions that must be implemented for a given type. Traits are declared using the <code>trait</code> keyword.</p> <pre><code>trait\n&lt;record type declaration&gt;</code></pre> <p>The syntax of a record type declaration is as follows:</p> <pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n    &lt;constructor&gt; {\n       &lt;field1&gt; : &lt;type1&gt;;\n       ...\n       &lt;fieldn&gt; : &lt;typen&gt;\n    };</code></pre> <p>For example, the following defines a trait <code>Show</code>. Any type <code>A</code> that implements <code>Show</code> must provide a function <code>show</code> that takes an <code>A</code> and returns a <code>String</code>.</p> <pre><code>trait\ntype Show A := mkShow {show : A \u2192 String};</code></pre>"},{"location":"reference/language/traits/#instance-declarations","title":"Instance declarations","text":"<p>An instance of a trait refers to a term of the corresponding record type, which must implement all methods stipulated by the trait.</p> <p>To declare a given term is an instance of a trait, we use the <code>instance</code> keyword. To define an instance of a trait, we use the trait constructor of the corresponding record type.</p> <pre><code>instance\n&lt;term&gt; : {{&lt;trait&gt;}} := &lt;trait constructor&gt; (\n    field1 := &lt;term1&gt;;\n    ...\n    fieldn := &lt;termn&gt;;\n);</code></pre> <p>For example, we could define three instances of <code>Show</code> for <code>String</code>, <code>Bool</code>, and <code>Nat</code> as follows:</p> <pre><code>instance\nshowStringI : Show String := mkShow (show := id);\n\ninstance\nshowBoolI : Show Bool :=\n  mkShow (show := \u03bb {x := if x \"true\" \"false\"});\n\ninstance\nshowNatI : Show Nat := mkShow (show := natToString);</code></pre> <p>One more involved example is the following, which defines an instance of <code>Show</code> for the type of lists:</p> <pre><code>instance\nshowListI {A} {{Show A}} : Show (List A) :=\n  let\n    showList {A} : {{Show A}} \u2192 List A \u2192 String\n      | nil := \"nil\"\n      | (h :: t) := Show.show h ++str \" :: \" ++str showList t;\n  in mkShow (show := showList);</code></pre>"},{"location":"reference/language/traits/#using-traits","title":"Using traits","text":"<p>Using the <code>Show</code> trait defined above, we can define a function <code>showNat</code> that takes a <code>Nat</code> and returns a <code>String</code>. One possible implementation is the following:</p> <pre><code>type Box A := box A;\n\ntrait\ntype T A := mkT {pp : A \u2192 A};\n\nppBox {A} {{T A}} : Box A \u2192 Box A\n  | (box x) := box (T.pp x);\n\ninstance\nboxT {A} {{T A}} : T (Box A) := mkT (pp := ppBox);</code></pre> <p>To prevent looping during instance search, we ensure a structural decrease in the trait parameters of instance types. Therefore, the following is rejected:</p> <pre><code>type Box A := box A;\n\ntrait\ntype T A := mkT { pp : A \u2192 A };\n\ninstance\nboxT {A} : {{T (Box A)}} \u2192 T (Box A) := mkT (\u03bb{x := x});</code></pre> <p>We check whether each parameter is a strict subterm of some trait parameter in the target. This ordering is included in the finite multiset extension of the subterm ordering, hence terminating.</p> <ul> <li>Matching on implicit instances</li> </ul> <p>It is possible to manually provide an instance and to match on implicit instances, as shown below:</p> <pre><code>f' {A} : {{Show A}} \u2192 A \u2192 String\n  | {{mkShow s}} x := s x;\n\nf'' {A} : {{Show A}} \u2192 A \u2192 String\n  | {{M}} x := Show.show {{M}} x;</code></pre> <p>Finally, using the <code>Show</code> trait and the function <code>printStringLn</code> and <code>IO</code> from the standard library, we could use the instances of <code>Show</code> as follows:</p> <pre><code>main : IO :=\n  printStringLn (Show.show true)\n    &gt;&gt; printStringLn (f false)\n    &gt;&gt; printStringLn (Show.show 3)\n    &gt;&gt; printStringLn (Show.show [true; false])\n    &gt;&gt; printStringLn (Show.show [1; 2; 3])\n    &gt;&gt; printStringLn (f' [1; 2])\n    &gt;&gt; printStringLn (f'' [true; false])\n    &gt;&gt; printStringLn (Show.show [\"a\"; \"b\"; \"c\"; \"d\"]);</code></pre>"},{"location":"reference/tooling/CLI/","title":"CLI","text":""},{"location":"reference/tooling/CLI/#usage","title":"Usage","text":"<pre><code>juvix [Global options] ((-v|--version) | (-h|--help) | COMPILER_CMD | UTILITY_CMD)</code></pre>"},{"location":"reference/tooling/CLI/#informative-options","title":"Informative options","text":"<ul> <li><code>-v,--version</code> Print the version and exit</li> <li><code>--numeric-version</code> Show only the version number</li> <li><code>-h,--help</code> Show this help text</li> </ul>"},{"location":"reference/tooling/CLI/#global-command-flags","title":"Global Command flags","text":"<ul> <li><code>--no-colors</code> Disable globally ANSI formatting</li> <li><code>--show-name-ids</code> Show the unique number of each identifier when   pretty printing</li> <li><code>--only-errors</code> Only print errors in a uniform format (used by   juvix-mode)</li> <li><code>--no-termination</code> Disable termination checking</li> <li><code>--no-positivity</code> Disable positivity checking for inductive types</li> <li><code>--no-coverage</code> Disable coverage checking for patterns</li> <li><code>--no-stdlib</code> Do not use the standard library</li> <li><code>--internal-build-dir BUILD_DIR</code> Directory for compiler internal output</li> <li><code>--stdin</code> Read from Stdin</li> <li><code>--unroll ARG</code> Recursion unrolling limit (default: 140)</li> </ul>"},{"location":"reference/tooling/CLI/#main-commands","title":"Main Commands","text":"<ul> <li><code>html</code> Generate HTML output from a Juvix file</li> <li><code>typecheck</code> Typecheck a Juvix file</li> <li><code>compile</code> Compile a Juvix file</li> <li><code>eval</code> Evaluate a Juvix file</li> </ul>"},{"location":"reference/tooling/CLI/#utility-commands","title":"Utility Commands","text":"<ul> <li><code>doctor</code> Perform checks on your Juvix development environment</li> <li><code>init</code> Interactively initialize a Juvix project in the current   directory</li> <li><code>repl</code> Run the Juvix REPL</li> <li><code>format</code> Format a Juvix file or Juvix project</li> <li><code>clean</code> Delete build artifacts</li> </ul>"},{"location":"reference/tooling/CLI/#dev-commands","title":"Dev Commands","text":"<pre><code>juvix dev COMMAND</code></pre> <ul> <li><code>parse</code> Parse a Juvix file</li> <li><code>scope</code> Parse and scope a Juvix file</li> <li><code>highlight</code> Highlight a Juvix file</li> <li><code>core</code> Subcommands related to JuvixCore</li> <li><code>asm</code> Subcommands related to JuvixAsm</li> <li><code>root</code> Show the root path for a Juvix project</li> <li><code>termination</code> Subcommands related to termination checking</li> <li><code>internal</code> Subcommands related to Internal</li> <li><code>minic</code> Translate a Juvix file to a subset of C</li> <li><code>geb</code> Subcommands related to JuvixGeb</li> <li><code>runtime</code> Subcommands related to the Juvix runtime</li> <li><code>repl</code> Run the Juvix dev REPL</li> </ul>"},{"location":"reference/tooling/CLI/#cli-auto-completion-scripts","title":"CLI Auto-completion Scripts","text":"<p>The Juvix CLI can generate auto-completion scripts. Follow the instructions below for your shell.</p> <p>Note</p> <p>NB: You may need to restart your shell after installing the completion script.</p>"},{"location":"reference/tooling/CLI/#bash","title":"Bash","text":"<p>Add the following line to your bash init script (for example <code>~/.bashrc</code>).</p> <pre><code>eval \"$(juvix --bash-completion-script juvix)\"</code></pre>"},{"location":"reference/tooling/CLI/#fish","title":"Fish","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --fish-completion-script juvix\n  &gt; ~/.config/fish/completions/juvix.fish</code></pre>"},{"location":"reference/tooling/CLI/#zsh","title":"ZSH","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --zsh-completion-script juvix &gt; $DIR_IN_FPATH/_juvix</code></pre> <p>where <code>$DIR_IN_FPATH</code> is a directory that is present on the ZSH FPATH variable (which you can inspect by running <code>echo $FPATH</code> in the shell).</p>"},{"location":"reference/tooling/doctor/","title":"Doctor","text":""},{"location":"reference/tooling/doctor/#juvix-doctor","title":"Juvix Doctor","text":"<p>The <code>juvix doctor</code> command can help you to troubleshoot problems with your development environment. For each problem the doctor finds they'll be a link to a section on this page to help you fix it.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-clang-command","title":"Could not find the clang command","text":"<p>The Juvix compiler uses the Clang compiler version 13 or later to generate binaries. You need to have Clang available on your system <code>$PATH</code>.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos","title":"MacOS","text":"<p>Use Homebrew:</p> <pre><code>brew install llvm</code></pre> <p>NB: The distribution of Clang that comes with XCode does not support the <code>Wasm</code> target so you must install the standard Clang distribution.</p>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install clang lldb lld</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S llvm lld</code></pre>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasm-ld-command","title":"Could not find the wasm-ld command","text":"<p>The Juvix compiler required <code>wasm-ld</code> (the Wasm linker) to produce <code>Wasm</code> binaries.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos_1","title":"MacOS","text":"<p><code>wasm-ld</code> is included in the Homebrew llvm distribution:</p> <pre><code>brew install llvm</code></pre>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux_1","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install lldb lld</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux_1","title":"Arch Linux","text":"<pre><code>sudo pacman -S lld</code></pre>"},{"location":"reference/tooling/doctor/#newer-clang-version-required","title":"Newer Clang version required","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-target","title":"Clang does not support the wasm32 target","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-wasi-target","title":"Clang does not support the wasm32-wasi target","text":"<p>Juvix uses WASI - The Wasm System Interface to produce binaries that can be executed using a Wasm runtime. The files necessary to setup Clang with <code>wasm32-wasi</code> support are available at wasi-sdk.</p> <p>To install the <code>wasm32-wasi</code> target for Clang you need to do two things:</p>"},{"location":"reference/tooling/doctor/#install-libclang_rtbuiltins-wasm32a-into-your-clang-distribution","title":"Install <code>libclang_rt.builtins-wasm32.a</code> into your Clang distribution","text":"<ol> <li> <p>Obtain <code>libclang_rt.builtins-wasm32-wasi-16.0.tar.gz</code> from the     wasi-sdk     releases page.</p> </li> <li> <p>Untar the file and place the file     <code>lib/wasi/libclang_rt.builtins-wasm32.a</code> into your Clang     distribution directory.</p> <p>On MacOS, if you installed llvm using homebrew you can find the Clang distribution directory using <code>brew --prefix llvm</code>. You should then place the builtins file at <code>`brew --prefix llvm`/lib/wasi/libclang_rt.builtins-wasm32.a</code>.</p> <p>On Linux the Clang distribution directory will be something like <code>/usr/lib/clang/13.0.1</code> where <code>13.0.1</code> is the version of Clang that you have installed. You should then place the builtins file at <code>/usr/lib/clang/13.0.1/lib/wasi/libclang_rt.builtins-wasm32</code>.</p> </li> </ol>"},{"location":"reference/tooling/doctor/#download-the-wasi-sysroot-and-set-wasi_sysroot_path","title":"Download the WASI sysroot and set <code>WASI_SYSROOT_PATH</code>","text":"<ol> <li>Obtain <code>wasi-sysroot-16.0.tar.gz</code> from the wasi-sdk     releases page.</li> <li>Untar the file and set the environment variable <code>WASI_SYSROOT_PATH</code>     to that location.</li> </ol>"},{"location":"reference/tooling/doctor/#environment-variable-wasi_sysroot_path-is-not-set","title":"Environment variable <code>WASI_SYSROOT_PATH</code> is not set","text":"<p>Set the <code>WASI_SYSROOT_PATH</code> to the directory where you installed the <code>wasi-sdk</code> sysroot files. See installing the WASI sysroot.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasmer-command","title":"Could not find the wasmer command","text":"<p>The Juvix test suite uses Wasmer as a Wasm runtime to execute compiled Wasm binaries. See the Wasmer documentation to see how to install it.</p>"},{"location":"reference/tooling/emacs/","title":"Emacs mode","text":""},{"location":"reference/tooling/emacs/#emacs-mode","title":"Emacs Mode","text":"<p>There is an Emacs mode available for Juvix. Currently, it supports syntax highlighting for well-scoped modules.</p> <p>To get started, clone the Juvix Emacs mode repository:</p> <pre><code>git clone https://github.com/anoma/juvix-mode.git</code></pre> <p>To install it add the following lines to your Emacs configuration file:</p> <pre><code>(push \"/path/to/juvix-mode/\" load-path)\n(require 'juvix-mode)</code></pre> <p>Make sure that Juvix is installed in your <code>PATH</code>.</p> <p>The Juvix major mode will be activated automatically for <code>.juvix</code> files.</p>"},{"location":"reference/tooling/emacs/#keybindings","title":"Keybindings","text":"Key Function Name Description <code>C-c C-l</code> <code>juvix-load</code> Runs the scoper and adds semantic syntax highlighting <code>M-.</code> <code>juvix-goto-definition</code> Go to the definition of symbol at point <code>C-c C-f</code> <code>juvix-format-buffer</code> Format the current buffer"},{"location":"reference/tooling/emacs/#emacs-installation","title":"Emacs installation","text":"<p>Most Linux distributions contain an Emacs package which can be installed with your package manager (<code>sudo apt install emacs</code> on Ubuntu). On macOS, it is recommended to install Emacs Plus via Homebrew: <code>brew install emacs-plus</code>. Using the Emacs Homebrew casks is not recommended.</p>"},{"location":"reference/tooling/emacs/#common-problems","title":"Common problems","text":"<ul> <li>Error \"Symbol's value as variable is void: sh:1:\"</li> </ul> <p>Make sure the juvix executable is on the Emacs' <code>exec-path</code>. Note   that <code>exec-path</code> may be different from your shell's <code>PATH</code>. This is   particularly common on macOS with Emacs launched from GUI instead of   the terminal.</p> <p>The easiest way to resolve this issue is to install the   exec-path-from-shell   package (available on MELPA). Alternatively, one may set <code>exec-path</code>   to match shell <code>PATH</code> by following the instructions from   EmacsWiki.</p>"},{"location":"reference/tooling/testing/","title":"Testing","text":""},{"location":"reference/tooling/testing/#dependencies","title":"Dependencies","text":"<p>See Installing dependencies for instructions on how to set up the testing environment for the WASM compiler tests.</p>"},{"location":"reference/tooling/testing/#running","title":"Running","text":"<p>Run tests using:</p> <pre><code>make test</code></pre> <p>Or using <code>Stack</code>:</p> <pre><code>stack test</code></pre> <p>To run tests, ignoring all the WASM tests:</p> <pre><code>stack test --ta '-p \"! /slow tests/\"'</code></pre>"},{"location":"tutorials/emacs/","title":"Juvix Emacs mode tutorial","text":"<p>First, follow the instructions in the Emacs Mode Reference to install the Juvix Emacs mode. Once you've successfully set it up, create a file <code>Hello.juvix</code> with the following content.</p> <pre><code></code></pre> <p>Type Ctrl+C+Ctrl+L to run the scoper and highlight the syntax.</p> <p>If you make a mistake in your program, it is automatically underlined in red with the error message popping up when you hover the mouse pointer over the underlined part.</p> <p>For example, in the following program the identifier <code>printStringLna</code> should be underlined with the error message \"Symbol not in scope\".</p> <pre><code>module Hello;\n\nopen import Stdlib.Prelude;\n\nmain : IO;\nmain := printStringLna \"Hello world!\";\n\nend;</code></pre> <p>If error underlining doesn't work, make sure you have the <code>flycheck</code> mode turned on. It should be turned on automatically when loading <code>juvix-mode</code>, but in case this doesn't work you can enable it with <code>M-x flycheck-mode</code>.</p> <p>Let's extend our program with another definition.</p> <pre><code>module Hello;\n  import Stdlib.Prelude open;\n\n  main : IO := printStringLn \"Hello world!\";\nend;</code></pre> <p>Place the cursor on the <code>print</code> call in the function clause of <code>main</code> and press <code>M-.</code>. The cursor will jump to the definition of <code>print</code> above. This also works across files and for definitions from the standard library. You can try using <code>M-.</code> to jump to the definition of <code>printStringLn</code>.</p> <p>One more feature of the Juvix Emacs mode is code formatting. To format the content of the current buffer, type Ctrl+C+Ctrl+F.</p>"},{"location":"tutorials/learn/","title":"Juvix tutorial","text":"<p>Welcome to the Juvix tutorial! This concise guide will introduce you to essential language features, while also serving as an introduction to functional programming. By the end of this tutorial, you'll have a strong foundation in Juvix's core concepts, ready to explore its advanced capabilities. Let's get started on your Juvix journey!</p>"},{"location":"tutorials/learn/#juvix-repl","title":"Juvix REPL","text":"<p>After installing Juvix, launch the Juvix REPL:</p> <pre><code>juvix repl</code></pre> <p>The response should be similar to:</p> <pre><code>Juvix REPL version 0.3: https://juvix.org. Run :help for help\nOK loaded: ./.juvix-build/stdlib/Stdlib/Prelude.juvix\nStdlib.Prelude&gt;</code></pre> <p>Currently, the REPL supports evaluating expressions but it does not yet support adding new definitions. To see the list of available REPL commands type <code>:help</code>.</p>"},{"location":"tutorials/learn/#basic-expressions","title":"Basic expressions","text":"<p>You can try evaluating simple arithmetic expressions in the REPL:</p> <pre><code>Stdlib.Prelude&gt; 3 + 4\n7\nStdlib.Prelude&gt; 1 + 3 * 7\n22\nStdlib.Prelude&gt; div 35 4\n8\nStdlib.Prelude&gt; mod 35 4\n3\nStdlib.Prelude&gt; sub 35 4\n31\nStdlib.Prelude&gt; sub 4 35\n0</code></pre> <p>By default, Juvix operates on non-negative natural numbers. Natural number subtraction is implemented by the function <code>sub</code>. Subtracting a bigger natural number from a smaller one yields <code>0</code>.</p> <p>You can also try boolean expressions</p> <pre><code>Stdlib.Prelude&gt; true\ntrue\nStdlib.Prelude&gt; not true\nfalse\nStdlib.Prelude&gt; true &amp;&amp; false\nfalse\nStdlib.Prelude&gt; true || false\ntrue\nStdlib.Prelude&gt; if true 1 0\n1</code></pre> <p>and strings, pairs and lists:</p> <pre><code>Stdlib.Prelude&gt; \"Hello world!\"\n\"Hello world!\"\nStdlib.Prelude&gt; (1, 2)\n(1, 2)\nStdlib.Prelude&gt; 1 :: 2 :: nil\n1 :: 2 :: nil</code></pre> <p>In fact, you can use all functions and types from the Stdlib.Prelude module of the standard library, which is preloaded by default.</p> <pre><code>Stdlib.Prelude&gt; length (1 :: 2 :: nil)\n3\nStdlib.Prelude&gt; null (1 :: 2 :: nil)\nfalse\nStdlib.Prelude&gt; swap (1, 2)\n(2, 1)</code></pre>"},{"location":"tutorials/learn/#files-modules-and-compilation","title":"Files, modules and compilation","text":"<p>Currently, the REPL does not support adding new definitions. To define new functions or data types, you need to put them in a separate file and either load the file in the REPL with <code>:load file.juvix</code>, evaluate it with the shell command <code>juvix eval file.juvix</code>, or compile it to a binary executable with <code>juvix compile file.juvix</code>.</p> <p>To conveniently edit Juvix files, an Emacs mode and a VSCode extension are available.</p> <p>A Juvix file must declare a module whose name corresponds exactly to the name of the file. For example, a file <code>Hello.juvix</code> must declare a module <code>Hello</code>:</p> <pre><code>-- Hello world example. This is a comment.\nmodule Hello;\n  -- Import the standard library prelude, including the 'String' type\n  import Stdlib.Prelude open;\n\n  main : String := \"Hello world!\";\nend;</code></pre> <p>A file compiled to an executable must define the zero-argument function <code>main</code> which is evaluated when running the program. The definition of <code>main</code> can have any non-function type, e.g., <code>String</code>, <code>Bool</code> or <code>Nat</code>. The generated executable prints the result of evaluating <code>main</code>.</p>"},{"location":"tutorials/learn/#data-types-and-functions","title":"Data types and functions","text":"<p>To see the type of an expression, use the <code>:type</code> REPL command:</p> <pre><code>Stdlib.Prelude&gt; :type 1\nNat\nStdlib.Prelude&gt; :type true\nBool</code></pre> <p>The types <code>Nat</code> and <code>Bool</code> are defined in the standard library.</p> <p>The type <code>Bool</code> has two constructors <code>true</code> and <code>false</code>.</p> <pre><code>  type Bool :=\n    | true\n    | false;</code></pre> <p>The constructors of a data type can be used to build elements of the type. They can also appear as patterns in function definitions. For example, the <code>not</code> function is defined in the standard library by:</p> <pre><code>  not : Bool -&gt; Bool\n    | true := false\n    | false := true;</code></pre> <p>The type of the definition is specified after the colon. In this case, <code>not</code> is a function from <code>Bool</code> to <code>Bool</code>. The type is followed by two function clauses which specify the function result depending on the shape of the arguments. When a function call is evaluated, the first clause that matches the arguments is used.</p> <p>In contrast to languages like Python, Java or C/C++, Juvix doesn't require parentheses for function calls. All the arguments are just listed after the function. The general pattern for function application is: <code>func arg1 arg2 arg3 ...</code></p> <p>Initial arguments that are matched against variables or wildcards in all clauses can be moved to the left of the colon. For example,</p> <pre><code>  or' (x : Bool) : Bool -&gt; Bool\n    | true := true\n    | _ := x;</code></pre> <p>is equivalent to</p> <pre><code>  or' : Bool -&gt; Bool -&gt; Bool\n    | _ true := true\n    | x _ := x;</code></pre> <p>If there is only one clause and all arguments are to the left of the colon, the pipe <code>|</code> should be omitted:</p> <pre><code>  id (x : Bool) : Bool := x;</code></pre> <p>A more complex example of a data type is the <code>Nat</code> type from the standard library:</p> <pre><code>  type Nat :=\n    | zero : Nat\n    | suc : Nat -&gt; Nat;</code></pre> <p>The constructor <code>zero</code> represents <code>0</code> and <code>suc</code> represents the successor function \u2013 <code>suc n</code> is the successor of <code>n</code>, i.e., <code>n+1</code>. For example, <code>suc zero</code> represents <code>1</code>. The number literals <code>0</code>, <code>1</code>, <code>2</code>, etc., are just shorthands for appropriate expressions built using <code>suc</code> and <code>zero</code>.</p> <p>The constructors of a data type specify how the elements of the type can be constructed. For instance, the above definition specifies that an element of <code>Nat</code> is either:</p> <ul> <li><code>zero</code>, or</li> <li><code>suc n</code> where <code>n</code> is an element of <code>Nat</code>, i.e., it is constructed by   applying <code>suc</code> to appropriate arguments (in this case the argument   of <code>suc</code> has type <code>Nat</code>).</li> </ul> <p>Any element of <code>Nat</code> can be built with the constructors in this way \u2013 there are no other elements. Mathematically, this is an inductive definition, which is why the data type is called inductive.</p> <p>Constructors can either by specified by listing their types after colons like in the above definition of <code>Nat</code>, or with a shorter ADT syntax like in the definition of <code>Bool</code>. The ADT syntax is similar to data type definition syntax in functional languages like Haskell or OCaml: one lists the types of constructor arguments separated by spaces. In this syntax, the <code>Nat</code> type could be defined by</p> <pre><code>  type Nat :=\n    | zero\n    | suc Nat;</code></pre> <p>If implemented directly, the above unary representation of natural numbers would be extremely inefficient. The Juvix compiler uses a binary number representation under the hood and implements arithmetic operations using corresponding machine instructions, so the performance of natural number arithmetic is similar to other programming languages. The <code>Nat</code> type is a high-level presentation of natural numbers as seen by the user who does not need to worry about low-level arithmetic implementation details.</p> <p>One can use <code>zero</code> and <code>suc</code> in pattern matching, like any other constructors:</p> <pre><code>  syntax operator + additive;\n  + : Nat -&gt; Nat -&gt; Nat\n    | zero b := b\n    | (suc a) b := suc (a + b);</code></pre> <p>The <code>syntax operator + additive</code> declares <code>+</code> to be an operator with the <code>additive</code> fixity. The <code>+</code> is an ordinary function, except that function application for <code>+</code> is written in infix notation. The definitions of the clauses of <code>+</code> still need the prefix notation on the left-hand sides.</p> <p>The <code>a</code> and <code>b</code> in the patterns on the left-hand sides of the clauses are variables which match arbitrary values of the corresponding type. They can be used on the right-hand side to refer to the values matched. For example, when evaluating</p> <pre><code>(suc (suc zero)) + zero</code></pre> <p>the second clause of <code>+</code> matches, assigning <code>suc zero</code> to <code>a</code> and <code>zero</code> to <code>b</code>. Then the right-hand side of the clause is evaluated with <code>a</code> and <code>b</code> substituted by these values:</p> <pre><code>suc (suc zero + zero)</code></pre> <p>Again, the second clause matches, now with both <code>a</code> and <code>b</code> being <code>zero</code>. After replacing with the right-hand side, we obtain:</p> <pre><code>suc (suc (zero + zero))</code></pre> <p>Now the first clause matches and finally we obtain the result</p> <pre><code>suc (suc zero)</code></pre> <p>which is just <code>2</code>.</p> <p>The function <code>+</code> is defined like above in the standard library, but the Juvix compiler treats it specially and generates efficient code using appropriate CPU instructions.</p>"},{"location":"tutorials/learn/#pattern-matching","title":"Pattern matching","text":"<p>The patterns in function clauses do not have to match on a single constructor \u2013 they may be arbitrarily deep. For example, here is an (inefficient) implementation of a function which checks whether a natural number is even:</p> <pre><code>  even : Nat -&gt; Bool\n    | zero := true\n    | (suc zero) := false\n    | (suc (suc n)) := even n;</code></pre> <p>This definition states that a natural number <code>n</code> is even if either <code>n</code> is <code>zero</code> or, recursively, <code>n-2</code> is even.</p> <p>If a subpattern is to be ignored, then one can use a wildcard <code>_</code> instead of naming the subpattern.</p> <pre><code>  isPositive : Nat -&gt; Bool\n    | zero := false\n    | (suc _) := true;</code></pre> <p>The above function could also be written as:</p> <pre><code>    isPositive : Nat -&gt; Bool\n      | zero := false\n      | _ := true;</code></pre> <p>It is not necessary to define a separate function to perform pattern matching. One can use the <code>case</code> syntax to pattern match an expression directly.</p> <pre><code>Stdlib.Prelude&gt; case (1, 2) | (suc _, zero) := 0 | (suc _, suc x) := x | _ := 19\n1</code></pre> <p>It is possible to name subpatterns with <code>@</code>.</p> <pre><code>Stdlib.Prelude&gt; case 3 | suc n@(suc _) := n | _ := 0\n2</code></pre>"},{"location":"tutorials/learn/#comparisons-and-conditionals","title":"Comparisons and conditionals","text":"<p>To use the comparison operators on natural numbers, one needs to import the <code>Stdlib.Data.Nat.Ord</code> module. The comparison operators are not in <code>Stdlib.Prelude</code> to avoid clashes with user-defined operators for other data types. The functions available in <code>Stdlib.Data.Nat.Org</code> include: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>/=</code>, <code>min</code>, <code>max</code>.</p> <p>For example, one may define the function <code>max3</code> by:</p> <pre><code>  import Stdlib.Prelude open;\n  import Stdlib.Data.Nat.Ord open;\n\n  max3 (x y z : Nat) : Nat := if (x &gt; y) (max x z) (max y z);</code></pre> <p>The conditional <code>if</code> is a special function which is evaluated lazily, i.e., first the condition (the first argument) is evaluated, and then depending on its truth-value one of the branches (the second or the third argument) is evaluated and returned.</p> <p>By default, evaluation in Juvix is eager (or strict), meaning that the arguments to a function are fully evaluated before applying the function. Only <code>if</code>, <code>||</code> and <code>&amp;&amp;</code> are treated specially and evaluated lazily. These special functions cannot be partially applied (see Partial application and higher-order functions below).</p>"},{"location":"tutorials/learn/#local-definitions","title":"Local definitions","text":"<p>Juvix supports local definitions with let-expressions.</p> <pre><code>  f (a : Nat) : Nat :=\n    let\n      x : Nat := a + 5;\n      y : Nat := a * 7 + x;\n    in x * y;</code></pre> <p>The variables <code>x</code> and <code>y</code> are not visible outside <code>f</code>.</p> <p>One can also use multi-clause definitions in <code>let</code>-expressions, with the same syntax as definitions inside a module. For example:</p> <pre><code>  even : Nat -&gt; Bool :=\n    let\n      even' : Nat -&gt; Bool\n        | zero := true\n        | (suc n) := odd' n;\n      odd' : Nat -&gt; Bool\n        | zero := false\n        | (suc n) := even' n;\n    in even';</code></pre> <p>The functions <code>even'</code> and <code>odd'</code> are not visible outside <code>even</code>.</p>"},{"location":"tutorials/learn/#recursion","title":"Recursion","text":"<p>Juvix is a purely functional language, which means that functions have no side effects and all variables are immutable. An advantage of functional programming is that all expressions are referentially transparent \u2013 any expression can be replaced by its value without changing the meaning of the program. This makes it easier to reason about programs, in particular to prove their correctness. No errors involving implicit state are possible, because the state is always explicit.</p> <p>In a functional language, there are no imperative loops. Repetition is expressed using recursion. In many cases, the recursive definition of a function follows the inductive definition of a data structure the function analyses. For example, consider the following inductive type of lists of natural numbers:</p> <pre><code>  type NList :=\n    | nnil : NList\n    | ncons : Nat -&gt; NList -&gt; NList;</code></pre> <p>An element of <code>NList</code> is either <code>nnil</code> (empty) or <code>ncons x xs</code> where <code>x : Nat</code> and <code>xs : NList</code> (a list with head <code>x</code> and tail <code>xs</code>).</p> <p>A function computing the length of a list may be defined by:</p> <pre><code>  nlength : NList -&gt; Nat\n    | nnil := 0\n    | (ncons _ xs) := nlength xs + 1;</code></pre> <p>The definition follows the inductive definition of <code>NList</code>. There are two function clauses for the two constructors. The case for <code>nnil</code> is easy \u2013 the constructor has no arguments and the length of the empty list is <code>0</code>. For a constructor with some arguments, one typically needs to express the result of the function in terms of the constructor arguments, usually calling the function recursively on the constructor's inductive arguments (for <code>ncons</code> this is the second argument). In the case of <code>ncons _ xs</code>, we recursively call <code>nlength</code> on <code>xs</code> and add <code>1</code> to the result.</p> <p>Let's consider another example \u2013 a function which returns the maximum of the numbers in a list or 0 for the empty list.</p> <pre><code>  import Stdlib.Data.Nat.Ord open using {max};\n\n  nmaximum : NList -&gt; Nat\n    | nnil := 0\n    | (ncons x xs) := max x (nmaximum xs);</code></pre> <p>Again, there is a clause for each constructor. In the case for <code>ncons</code>, we recursively call the function on the list tail and take the maximum of the result and the list head.</p> <p>For an example of a constructor with more than one inductive argument, consider binary trees with natural numbers in nodes.</p> <pre><code>  type Tree :=\n    | leaf : Nat -&gt; Tree\n    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;</code></pre> <p>The constructor <code>node</code> has two inductive arguments (the second and the third) which represent the left and the right subtree.</p> <p>A function which produces the mirror image of a tree may be defined by:</p> <pre><code>  mirror : Tree -&gt; Tree\n    | (leaf x) := leaf x\n    | (node x l r) := node x (mirror r) (mirror l);</code></pre> <p>The definition of <code>mirror</code> follows the definition of <code>Tree</code>. There are two recursive calls for the two inductive constructors of <code>node</code> (the subtrees).</p>"},{"location":"tutorials/learn/#partial-application-and-higher-order-functions","title":"Partial application and higher-order functions","text":"<p>Strictly speaking, all Juvix functions have only one argument. Multi-argument functions are really functions which return a function which takes the next argument and returns a function taking another argument, and so on for all arguments. The function type former <code>-&gt;</code> (the arrow) is right-associative. Hence, the type, e.g., <code>Nat -&gt; Nat -&gt; Nat</code> when fully parenthesised becomes <code>Nat -&gt; (Nat -&gt; Nat)</code>. It is the type of functions which given an argument of type <code>Nat</code> return a function of type <code>Nat -&gt; Nat</code> which itself takes an argument of type <code>Nat</code> and produces a result of type <code>Nat</code>. Function application is left-associative. For example, <code>f a b</code> when fully parenthesised becomes <code>(f a) b</code>. So it is an application to <code>b</code> of the function obtained by applying <code>f</code> to <code>a</code>.</p> <p>Since a multi-argument function is just a one-argument function returning a function, it can be partially applied to a smaller number of arguments than specified in its definition. The result is an appropriate function. For example, <code>sub 10</code> is a function which subtracts its argument from <code>10</code>, and <code>(+) 1</code> is a function which adds <code>1</code> to its argument. If the function has been declared as an infix operator (like <code>+</code>), then for partial application one needs to enclose it in parentheses.</p> <p>A function which takes a function as an argument is a higher-order function. An example is the <code>nmap</code> function which applies a given function to each element in a list of natural numbers.</p> <pre><code>  nmap (f : Nat -&gt; Nat) : NList -&gt; NList\n    | nnil := nnil\n    | (ncons x xs) := ncons (f x) (nmap f xs);</code></pre> <p>The application</p> <pre><code>nmap \\{ x := div x 2 } lst</code></pre> <p>divides every element of <code>lst</code> by <code>2</code>, rounding down the result. The expression</p> <pre><code>\\{ x := div x 2 }</code></pre> <p>is an unnamed function, or a lambda, which divides its argument by <code>2</code>.</p>"},{"location":"tutorials/learn/#polymorphism","title":"Polymorphism","text":"<p>The type <code>NList</code> we have been working with above requires the list elements to be natural numbers. It is possible to define lists polymorphically, parameterising them by the element type. This is similar to generics in languages like Java, C++ or Rust. Here is the polymorphic definition of lists from the standard library:</p> <pre><code>  syntax operator :: cons;\n  type List A :=\n    | nil : List A\n    | :: : A -&gt; List A -&gt; List A;</code></pre> <p>The constructor <code>::</code> is declared as a right-associative infix operator. The definition has a parameter <code>A</code> which is the element type. Then <code>List Ty</code> is the type of lists with elements of type <code>Ty</code>. For example, <code>List Nat</code> is the type of lists of natural numbers, isomorphic to the type <code>NList</code> defined above.</p> <p>Now one can define the <code>map</code> function polymorphically:</p> <pre><code>  map {A B} (f : A -&gt; B) : List A -&gt; List B\n    | nil := nil\n    | (h :: hs) := f h :: map f hs;</code></pre> <p>This function has two implicit type arguments <code>A</code> and <code>B</code>. These arguments are normally omitted in function application \u2013 they are inferred automatically during type checking. The curly braces indicate that the argument is implicit and should be inferred.</p> <p>In fact, the constructors <code>nil</code> and <code>::</code> also have an implicit argument: the type of list elements. All type parameters of a data type definition become implicit arguments of the constructors.</p> <p>Usually, the implicit arguments in a function application can be inferred. However, sometimes this is not possible and then the implicit arguments need to be provided explicitly by enclosing them in braces:</p> <pre><code>f {implArg1} .. {implArgK} arg1 .. argN</code></pre> <p>For example, <code>nil {Nat}</code> has type <code>List Nat</code> while <code>nil</code> by itself has type <code>{A : Type} -&gt; List A</code>.</p>"},{"location":"tutorials/learn/#tail-recursion","title":"Tail recursion","text":"<p>Any recursive call whose result is further processed by the calling function needs to create a new stack frame to save the calling function environment. This means that each such call will use a constant amount of memory. For example, a function <code>sum</code> implemented as follows will use an additional amount of memory proportional to the length of the processed list:</p> <pre><code>  sum : List Nat -&gt; Nat\n    | nil := 0\n    | (x :: xs) := x + sum xs;</code></pre> <p>This is not acceptable if you care about performance. In an imperative language, one would use a simple loop going over the list without any memory allocation. In pseudocode:</p> <pre><code>var sum : Nat := 0;\n\nwhile (lst /= nil) do\nbegin\n  sum := sum + head lst;\n  lst := tail lst;\nend;\n\nresult := sum;</code></pre> <p>Fortunately, it is possible to rewrite this function to use tail recursion. A recursive call is tail recursive if its result is also the result of the calling function, i.e., the calling function returns immediately after it without further processing. The Juvix compiler guarantees that all tail calls will be eliminated, i.e., that they will be compiled to simple jumps without extra memory allocation. In a tail recursive call, instead of creating a new stack frame, the old one is reused.</p> <p>The following implementation of <code>sum</code> uses tail recursion.</p> <pre><code>  sum' (lst : List Nat) : Nat :=\n    let\n      go (acc : Nat) : List Nat -&gt; Nat\n        | nil := acc\n        | (x :: xs) := go (acc + x) xs;\n    in go 0 lst;</code></pre> <p>The first argument of <code>go</code> is an accumulator which holds the sum computed so far. It is analogous to the <code>sum</code> variable in the imperative loop above. The initial value of the accumulator is 0. The function <code>go</code> uses only constant additional memory overall. The code generated for it by the Juvix compiler is equivalent to an imperative loop.</p> <p>Most imperative loops may be translated into tail recursive functional programs by converting the locally modified variables into accumulators and the loop condition into pattern matching. For example, here is an imperative pseudocode for computing the nth Fibonacci number in linear time. The variables <code>cur</code> and <code>next</code> hold the last two computed Fibonacci numbers.</p> <pre><code>var cur : Nat := 0;\nvar next : Nat := 1;\n\nwhile (n /= 0) do\nbegin\n  tmp := next;\n  next := cur + next;\n  cur := tmp;\n  n := n - 1;\nend;\n\nresult := cur;</code></pre> <p>An equivalent functional program is:</p> <pre><code>    fib : Nat -&gt; Nat :=\n      let\n        go (cur next : Nat) : Nat -&gt; Nat\n          | zero := cur\n          | (suc n) := go next (cur + next) n;\n      in go 0 1;</code></pre> <p>A naive definition of the Fibonacci function runs in exponential time:</p> <pre><code>    fib : Nat -&gt; Nat\n      | zero := 0\n      | (suc zero) := 1\n      | (suc (suc n)) := fib n + fib (suc n);</code></pre> <p>Tail recursion is less useful when the function needs to allocate memory anyway. For example, one could make the <code>map</code> function from the previous section tail recursive, but the time and memory use would still be proportional to the length of the input because of the need to allocate the result list. In fact, a tail recursive <code>map</code> needs to allocate and discard an intermediate list which is reversed in the end to preserve the original element order:</p> <pre><code>    map {A B} (f : A -&gt; B) : List A -&gt; List B :=\n      let\n        go (acc : List B) : List A -&gt; List B\n          | nil := reverse acc\n          | (x :: xs) := go (f x :: acc) xs;\n      in go nil;</code></pre> <p>So we have replaced stack allocation with heap allocation. This actually decreases performance.</p>"},{"location":"tutorials/learn/#conclusion","title":"Conclusion","text":"<ul> <li>Use tail recursion to eliminate stack allocation.</li> <li>Do not use tail recursion to replace stack allocation with heap allocation.</li> </ul>"},{"location":"tutorials/learn/#iteration-over-data-structures","title":"Iteration over data structures","text":"<p>A common use of recursion is to traverse a data structure in a specified order accumulating some values. For example, the tail recursive <code>sum</code> function fits this pattern.</p> <p>Juvix provides special support for data structure traversals with the iterator syntax. The standard library defines several list iterators, among them <code>for</code> and <code>rfor</code>. We can implement the <code>sum</code> function using <code>for</code>:</p> <pre><code>  sum (l : List Nat) : Nat :=\n    for (acc := 0) (x in l) {x + acc};</code></pre> <p>The braces around the body (in <code>{x + acc}</code>) are optional. A recommended style is to use braces if the body is on the same line.</p> <p>The above <code>for</code> iteration starts with the accumulator <code>acc</code> equal to <code>0</code> and goes through the list <code>l</code> from left to right (from beginning to end), at each step updating the accumulator to <code>x + acc</code> where <code>x</code> is the current list element and <code>acc</code> is the previous accumulator value. The final value of the iteration is the final value of the accumulator. The <code>for</code> iterator is tail recursive, i.e., no stack memory is allocated and the whole iteration is compiled to a loop.</p> <p>The <code>rfor</code> iterator is analogous to <code>for</code> except that it goes through the list from right to left (from end to beginning) and is not tail recursive. For example, one can implement <code>map</code> using <code>rfor</code>:</p> <pre><code>  map {A B} (f : A -&gt; B) (l : List A) : List B :=\n    rfor (acc := nil) (x in l) {f x :: acc};</code></pre> <p>The iterators are just ordinary higher-order Juvix functions which can be used with the iterator syntax. In fact, the <code>map</code> function from the standard library can also be used with the iterator syntax. The expression</p> <pre><code>map (x in l) {body}</code></pre> <p>is equivalent to</p> <pre><code>map \\{x := body} l</code></pre> <p>Whenever possible, it is advised to use the standard library iterators instead of manually writing recursive functions. When reasonable, <code>for</code> should be preferred to <code>rfor</code>. The iterators provide a readable syntax and the compiler might be able to optimize them better than manually written recursion.</p>"},{"location":"tutorials/learn/#totality-checking","title":"Totality checking","text":"<p>By default, the Juvix compiler requires all functions to be total. Totality consists of:</p> <ul> <li>termination and   coverage for function declarations,   and</li> <li>strict positivity for user-defined   data types.</li> </ul> <p>The termination check ensures that all functions are structurally recursive, i.e., all recursive call are on structurally smaller values \u2013 subpatterns of the matched pattern. For example, the termination checker rejects the definition</p> <pre><code>    fact (x : Nat) : Nat := if (x == 0) 1 (x * fact (sub x 1));</code></pre> <p>because the recursive call is not on a subpattern of a pattern matched on in the clause. One can reformulate this definition so that it is accepted by the termination checker:</p> <pre><code>    fact : Nat -&gt; Nat\n      | zero := 1\n      | x@(suc n) := x * fact n;</code></pre> <p>Sometimes, such a reformulation is not possible. Then one can use the <code>terminating</code> keyword to forgo the termination check.</p> <pre><code>  terminating\n  log2 (n : Nat) : Nat :=\n    if (n &lt;= 1) 0 (suc (log2 (div n 2)));</code></pre> <p>Coverage checking ensures that there are no unhandled patterns in function clauses or <code>case</code> expressions. For example, the following definition is rejected because the case <code>suc zero</code> is not handled:</p> <pre><code>    even : Nat -&gt; Bool\n      | zero := true\n      | (suc (suc n)) := even n;</code></pre> <p>Since coverage checking forces the user to specify the function for all input values, it may be unclear how to implement functions which are typically partial. For example, the <code>tail</code> function on lists is often left undefined for the empty list. One solution is to return a default value. In the Juvix standard library, <code>tail</code> is implemented as follows, returning the empty list when the argument is empty.</p> <pre><code>  tail {A} : List A -&gt; List A\n    | (_ :: xs) := xs\n    | nil := nil;</code></pre> <p>Another solution is to wrap the result in the <code>Maybe</code> type from the standard library, which allows representing optional values. An element of <code>Maybe A</code> is either <code>nothing</code> or <code>just x</code> with <code>x : A</code>.</p> <pre><code>  type Maybe A :=\n    | nothing : Maybe A\n    | just : A -&gt; Maybe A;</code></pre> <p>For example, one could define the tail function as:</p> <pre><code>    tail' {A} : List A -&gt; Maybe (List A)\n      | (_ :: xs) := just xs\n      | nil := nothing;</code></pre> <p>Then the user needs to explicitly check if the result of the function contains a value or not:</p> <pre><code>case (tail' lst)\n| just x := ...\n| nothing := ...</code></pre>"},{"location":"tutorials/learn/#exercises","title":"Exercises","text":"<p>You have now learnt the very basics of Juvix. To consolidate your understanding of Juvix and functional programming, try doing some of the following exercises. To learn how to write more complex Juvix programs, see the advanced tutorial and the Juvix program examples.</p>"},{"location":"tutorials/learn/#warm-up-exercises","title":"Warm-up exercises","text":""},{"location":"tutorials/learn/#boolean-operators","title":"Boolean operators","text":"<p>Let's start by defining some functions on booleans.</p> <p>The type for booleans is defined in the standard library like this:</p> <pre><code>type Bool :=\n  | true : Bool\n  | false : Bool;</code></pre> <p>Remember that you can import this definition by adding <code>import Stdlib.Prelude open</code> at the beginning of your module.</p> <p>Now, define the logical function <code>not</code> by using pattern matching.</p> <p>Tip</p> <p>The type of your function should be:</p> <pre><code>    not : Bool -&gt; Bool;</code></pre> <p>Now, define the logical functions <code>and</code>, <code>or</code> by using pattern matching as well. Feel free to experiment and see what happens if your patterns are not exhaustive, i.e., if not all the cases are covered.</p> <p>Next, let's define the logical function <code>xor</code>, which should return <code>true</code> if and only if exactly one of its arguments is <code>true</code>. This time, instead of using pattern matching, use the previously defined logical functions.</p> Solution <pre><code>    not : Bool -&gt; Bool\n      | false := true\n      | true := false;\n\n    or : Bool -&gt; Bool -&gt; Bool\n      | false b := b\n      | true _ := true;\n\n    and : Bool -&gt; Bool -&gt; Bool\n      | true b := b\n      | false _ := false;\n\n    xor (a b : Bool) : Bool := and (not (and a b)) (or a b);</code></pre>"},{"location":"tutorials/learn/#the-maybe-type","title":"The <code>Maybe</code> type","text":"<p>The <code>NMaybe</code> type encapsulates an optional natural number (the preceding <code>N</code> stands for <code>Nat</code>). The <code>nnothing</code> constructor is used when the value is missing. On the other hand, the <code>njust</code> constructor is used when the value is present.</p> <pre><code>type NMaybe :=\n  | nnothing : NMaybe\n  | njust : Nat \u2192 NMaybe;</code></pre> <p>Let's define a function <code>isJust : NMaybe -&gt; Bool</code> that returns <code>true</code> when the value is present.</p> Solution <pre><code>    isJust : NMaybe -&gt; Bool\n      | (njust _) := true\n      | nnothing := false;</code></pre> <p>Now let's define a function <code>fromMaybe : Nat -&gt; NMaybe -&gt; Nat</code> that given a <code>NMaybe</code>, returns its value if present and otherwise returns the first argument as a default value.</p> Solution <pre><code>    fromMaybe (d : Nat) : NMaybe -&gt; Nat\n      | (njust n) := n\n      | nnothing := d;</code></pre> <p>It would be useful to have a type that represents optional values of any type. In Juivx, we can define the polymorphic version of <code>NMaybe</code> like this:</p> <pre><code>type Maybe A :=\n  | nothing : Maybe A\n  | just : A \u2192 Maybe A;</code></pre> <p>In this definition, we parameterize the type <code>Maybe</code> with a generic type <code>A</code>.</p> <p>Implement again the <code>fromMaybe</code> function, but now, for the polymorphic <code>Maybe</code> type. Note that in function definitions we must specify the type variables. The definition of <code>fromMaybe</code> begin with:</p> <pre><code>fromMaybe {A} (d : A) : Maybe A -&gt; A</code></pre> <p>Give the implementation.</p> Solution <pre><code>    fromMaybe {A} (d : A) : Maybe A -&gt; A\n      | (just n) := n\n      | nothing := d;</code></pre> <p>Neat! It is indeed very easy to define polymorphic functions in Juvix.</p> <p>To get some more practice, give an implementation for <code>maybe</code> which begins with:</p> <pre><code>maybe {A B} (d : B) (f : A -&gt; B) : Maybe A -&gt; B</code></pre> <p>This should return the value (if present) applied to the function <code>f</code>. Otherwise it should return the default value <code>d</code>.</p> Solution <pre><code>    maybe {A B} (d : B) (f : A -&gt; B) : Maybe A -&gt; B\n      | (just n) := f n\n      | nothing := d;</code></pre>"},{"location":"tutorials/learn/#list-exercises","title":"List exercises","text":"<p>We can define polymorphic lists as follows:</p> <pre><code>import Stdlib.Data.Fixity open;\n\nsyntax operator :: cons;\ntype List A :=\n  | nil : List A\n  | :: : A -&gt; List A -&gt; List A;</code></pre> <p>Let's define a function that returns the first element of a <code>List</code> if it exists.</p> <p>Do you beginning the definition as follows is appropriate? If not, why?</p> <pre><code>head {A} : List A -&gt; A</code></pre> <p>Try to give an implementation for it.</p> Solution <p>As we know, Juvix guarantees that all functions are total. But we cannot return anything when the list is empty. Therefore it makes sense to use the <code>Maybe</code> type that we defined in the previous section. The proper definition of <code>head</code> should be:</p> <pre><code>head {A} : List A -&gt; Maybe A\n  | nil := nothing\n  | (h :: _) := just h;</code></pre> <p>So far we have defined only functions that do not involve looping, but any non-trivial program will require some sort of repetition, so let's tackle that.</p> <p>As stated previously, the only way to express repetition in Juivx is by using recursion. We say that a function is recursive if it is defined in terms of itself, i.e., the name of the function appears in its body.</p> <p>The next exercise is to define a function which returns the last element of a list. This function will need to call itself until it reaches the last element of the list.</p> <pre><code>last {A} : List A -&gt; Maybe A;</code></pre> Solution <pre><code>    last {A} : List A -&gt; Maybe A\n      | nil := nothing\n      | (x :: nil) := just x\n      | (_ :: xs) := last xs;</code></pre> <p>Next, implement a function that concatenates two lists:</p> <pre><code>  concat {A} : List A -&gt; List A -&gt; List A</code></pre> <p>Tip</p> <p>It is enough to pattern match the first list.</p> Solution <pre><code>        concat {A} : List A -&gt; List A -&gt; List A\n          | nil b := b\n          | (a :: as) b := a :: concat as b;</code></pre> <p>Now write a function that concatenates a list of lists.</p> <pre><code>  concatMany {A} : List (List A) -&gt; List A</code></pre> <p>Tip</p> <p><code>concat</code> may be helpful.</p> Solution <pre><code>    concatMany {A} : List (List A) -&gt; List A\n      | nil := nil\n      | (a :: as) := concat a (concatMany as);</code></pre> <p>Can you give an alternative implementation that uses the <code>rfor</code> iterator? What would happen if you used <code>for</code> instead of <code>rfor</code>?</p> Solution <pre><code>    concatMany-iter {A} (m : List (List A)) : List A :=\n      rfor (acc := nil) (l in m)\n        concat l acc;</code></pre> <p>In the previous solution, if you replace <code>rfor</code> by <code>for</code>, the resulting list will be as if the original list was reversed, but each of the nested lists keep their original order.</p> <p>Write a function that reverses a list:</p> <ul> <li>using the <code>for</code> iterator,</li> <li>using tail recursion.</li> </ul> Solution <p>Using the <code>for</code> iterator:</p> <pre><code>    reverse {A} (xs : List A) : List A :=\n      for (acc := nil) (x in xs) {x :: acc};</code></pre> <p>Using tail recursion:</p> <pre><code>    reverse {A} : List A -&gt; List A :=\n      let\n        go (acc : List A) : List A -&gt; List A\n          | nil := acc\n          | (x :: xs) := go (x :: acc) xs;\n      in go nil;</code></pre>"},{"location":"tutorials/learn/#function-composition","title":"Function composition","text":"<p>Let's try a different exercise. Define a function <code>compose</code> that composes two functions <code>f</code> and <code>g</code>. It should take three arguments <code>f</code>, <code>g</code>, <code>x</code> and its only clause's body should be <code>f (g x)</code>.</p> <p>Can you make the <code>compose</code> function polymorphic and as general as possible?</p> Hint <p>The definition should start like this:</p> <pre><code>    compose {A B C} ...</code></pre> Solution <pre><code>    compose {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C :=\n      f (g x);</code></pre> <p>Congratulations! your warm-up is complete!</p>"},{"location":"tutorials/learn/#more-exercises","title":"More exercises","text":""},{"location":"tutorials/learn/#prime-numbers","title":"Prime numbers","text":"<p>Define a function <code>prime : Nat -&gt; Bool</code> which checks if a given natural number is prime.</p> <p>Tip</p> <p>A number is prime if it is greater than 1 and has no divisors other than 1 and itself.</p> Solution <pre><code>  prime (x : Nat) : Bool :=\n    let\n      go : Nat -&gt; Bool\n        | zero := true\n        | (suc zero) := true\n        | n@(suc k) := if (mod x k == 0) false (go k);\n    in case x of {\n      | zero := false\n      | suc zero := false\n      | suc k := go k\n    };</code></pre>"},{"location":"tutorials/learn/#half","title":"Half","text":"<p>Does Juvix accept the following definition?</p> <pre><code>half : Nat -&gt; Nat := if (n &lt; 2) 0 (half (sub n 2) + 1);</code></pre> <p>How can you reformulate this definition so that it is accepted by Juvix?</p> Solution <p>The definition doesn't pass the termination checker. One way to reformulate it is as follows:</p> <pre><code>  half : Nat -&gt; Nat\n    | zero := 0\n    | (suc zero) := 0\n    | (suc (suc n)) := half n + 1;</code></pre>"},{"location":"tutorials/learn/#suffixes","title":"Suffixes","text":"<p>A suffix of a list <code>l</code> is any list which can be obtained from <code>l</code> by removing some initial elements. For example, the suffixes of <code>1 :: 2 :: 3 :: nil</code> are:</p> <ul> <li><code>1 :: 2 :: 3 :: nil</code>,</li> <li><code>2 :: 3 :: nil</code>,</li> <li><code>3 :: nil</code>, and</li> <li><code>nil</code>.</li> </ul> <p>Define a function which computes the list of all suffixes of a given list, arranged in descending order of their lengths.</p> Solution <pre><code>  suffixes {A} : List A -&gt; List (List A)\n    | nil := nil :: nil\n    | xs@(_ :: xs') := xs :: suffixes xs';</code></pre>"},{"location":"tutorials/learn/#tree-map","title":"Tree map","text":"<p>Recall the <code>Tree</code> type from above.</p> <pre><code>  type Tree :=\n    | leaf : Nat -&gt; Tree\n    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;</code></pre> <p>Analogously to the <code>map</code> function for lists, define a function</p> <pre><code>tmap : (Nat -&gt; Nat) -&gt; Tree -&gt; Tree;</code></pre> <p>which applies a function to all natural numbers stored in a tree.</p> Solution <pre><code>    tmap (f : Nat -&gt; Nat) : Tree -&gt; Tree\n      | (leaf x) := leaf (f x)\n      | (node x l r) := node (f x) (tmap f l) (tmap f r);</code></pre>"},{"location":"tutorials/learn/#polymorphic-tree","title":"Polymorphic tree","text":"<p>Modify the <code>Tree</code> type from Exercise 5 to be polymorphic in the element type, and then repeat the previous exercise.</p> Solution <p>Only the types need to be changed.</p> <pre><code>    type Tree A :=\n      | leaf : A -&gt; Tree A\n      | node : A -&gt; Tree A -&gt; Tree A -&gt; Tree A;\n\n    tmap {A B} (f : A -&gt; B) : Tree A -&gt; Tree B\n      | (leaf x) := leaf (f x)\n      | (node x l r) := node (f x) (tmap f l) (tmap f r);</code></pre>"},{"location":"tutorials/learn/#factorial","title":"Factorial","text":"<p>Write a tail recursive function which computes the factorial of a natural number.</p> Solution <pre><code>  fact : Nat -&gt; Nat :=\n    let\n      go (acc : Nat) : Nat -&gt; Nat\n        | zero := acc\n        | n@(suc n') := go (acc * n) n';\n    in go 1;</code></pre>"},{"location":"tutorials/learn/#list-function-compose","title":"List function compose","text":"<p>Define a function</p> <pre><code>comp {A} : List (A -&gt; A) -&gt; A -&gt; A</code></pre> <p>which composes all functions in a list. For example,</p> <pre><code>comp (suc :: (*) 2 :: \\{x := sub x 1} :: nil)</code></pre> <p>should be a function which given <code>x</code> computes <code>2(x - 1) + 1</code>.</p> Solution <pre><code>  comp {A} (fs : List (A -&gt; A)) : A -&gt; A :=\n    for (acc := id) (f in fs) {acc \u2218 f};</code></pre> <p>where <code>\u2218</code> is a composition function from the standard library:</p> <pre><code>syntax operator \u2218 composition;\n\u2218 {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);</code></pre> <p>The <code>\u2218</code> can be typed in Emacs or VSCode with <code>\\o</code>.</p>"},{"location":"tutorials/vscode/","title":"Juvix VSCode extension tutorial","text":"<p>To install the Juvix VSCode extension, click on the \"Extensions\" button in the left panel and search for the \"Juvix\" extension by Heliax.</p> <p>Once you've installed the Juvix extension, you can open a Juvix file. For example, create a <code>Hello.juvix</code> file with the following content.</p> <pre><code></code></pre> <p>Syntax should be automatically highlighted for any file with <code>.juvix</code> extension. You can jump to the definition of an identifier by pressing F12 or control-clicking it. To apply the Juvix code formatter to the current file, use Shift+Ctrl+I.</p> <p>In the top right-hand corner of the editor window you should see several buttons. Hover the mouse pointer over a button to see its description. The functions of the buttons are as follows.</p> <ul> <li>Load file in REPL (Shift+Alt+R). Launches the Juvix REPL in a   separate window and loads the current file into it. You can then   evaluate any definition from the loaded file.</li> <li>Typecheck (Shift+Alt+T). Type-checks the current file.</li> <li>Compile (Shift+Alt+C). Compiles the current file. The resulting   native executable will be left in the directory of the file.</li> <li>Run (Shift+Alt+X). Compiles and runs the current file. The output of   the executable run is displayed in a separate window.</li> <li>Html preview. Generates HTML documentation for the current file and   displays it in a separate window.</li> </ul>"},{"location":"tutorials/workshop/","title":"Juvix Workshop ZKSummit10 version","text":""},{"location":"tutorials/workshop/#introduction","title":"Introduction","text":"<p>In this part of the workshop, we will walk you through the process of installing Juvix, writing a simple program, and executing it. We will also introduce you to the command-line interface (CLI) and how to evaluate Juvix expressions.</p>"},{"location":"tutorials/workshop/#step-1-install-juvix-compiler","title":"Step 1: Install Juvix Compiler","text":"<p>The first step is to obtain a copy of the Juvix compiler. We have several installations listed here. Choose the one that suits you best.</p> <p>For convenience, we will use the Juvix extension in Visual Studio Code which will install Juvix for us.</p>"},{"location":"tutorials/workshop/#step-2-clone-the-repository","title":"Step 2: Clone the Repository","text":"<p>First, clone the following repository:</p> <pre><code>git clone https://github.com/anoma/juvix-workshop</code></pre> <p>Next, open the cloned repository in Visual Studio Code.</p>"},{"location":"tutorials/workshop/#step-3-install-the-juvix-extension","title":"Step 3: Install the Juvix Extension","text":"<p>In the extension tab, search for \"juvix\" and install the extension that features the Tara logo.</p>"},{"location":"tutorials/workshop/#step-4-open-helloworldjuvix-file","title":"Step 4: Open HelloWorld.juvix File","text":"<p>Open the <code>HelloWorld.juvix</code> file. You should get a prompt to install Juvix - click on the prompt and wait for Juvix to install. After reloading the page, full semantic highlighting should appear in the Juvix file.</p> <p>Here's a quick rundown of what you'll see in the file:</p> <ul> <li>The <code>module</code> declaration opens a file, it must have the same name as the file.</li> <li>We import the Juvix standard library; the <code>open</code> keyword at the end means that all the symbols in the imported module are added to the scope of the module unqualified.</li> <li>There is a function called <code>main</code>, which serves as the entry point to the program. It has type <code>IO</code>. The line below defines the body of the function. In this case, it simply calls the <code>printStringLn</code> function from the standard library with a single string argument.</li> </ul> <p>You can see the type of symbols in the code by hovering over them and navigate to the definitions of symbols in the code by CMD+clicking on them. You can also open a REPL session from within the editor itself.</p>"},{"location":"tutorials/workshop/#step-5-use-the-cli","title":"Step 5: Use the CLI","text":"<p>The Juvix compiler can also be driven from the command line. Let's see that in action.</p> <p>In the clone of the repository we made before, change directory to the <code>hello-world</code> project and compile the <code>HelloWorld.juvix</code> source file.</p> <pre><code>cd juvix-workshop\ncd hello-world\njuvix compile HelloWorld.juvix\n./HelloWorld</code></pre> <p>Juvix also has a read-eval-print-loop (REPL) program that can be used to evaluate Juvix expressions. We invoke this by running <code>juvix repl</code> in the terminal.</p> <pre><code>juvix repl</code></pre> <p>Let's evaluate some Juvix expressions to try it out.</p> <pre><code>1 + 1\nprintStringLn \"Hello\"</code></pre> <p>We'll explore more examples in the REPL later. Stay tuned!</p>"},{"location":"tutorials/workshop/#juvix-programming-and-basic-concepts","title":"Juvix Programming and Basic Concepts","text":"<p>In this tutorial, we will introduce you to the basic concepts of Juvix programming language. We'll cover functions, types, pattern matching, recursion, polymorphism, and iterators.</p>"},{"location":"tutorials/workshop/#step-1-create-a-new-file","title":"Step 1: Create a New File","text":"<p>Let's start by creating a new file named <code>Example.juvix</code>. Import and open the standard library. Also, initiate a REPL (Read-Eval-Print Loop) session for this file. The REPL will provide feedback from the compiler as we write the program.</p>"},{"location":"tutorials/workshop/#step-2-functions-in-juvix","title":"Step 2: Functions in Juvix","text":"<p>Juvix is a functional language, which means we can define functions. Unlike languages like Python that use a <code>def</code> keyword to define functions, Juvix doesn't require a keyword.</p> <p>Here's how to define a function:</p> <pre><code>add1 (n : Nat) : Nat;</code></pre> <p>If you see an error in the REPL, it's because we're missing a function clause. The symbol <code>:=</code> separates the arguments from the body of the clause.</p> <pre><code>add1 (n : Nat) : Nat := n + 1;</code></pre> <p>You can evaluate this function in the REPL. In Juvix, we apply a function to its arguments by writing the function next to its arguments, without parentheses.</p> <p>Let's define another function, <code>maximum</code>, which takes two arguments:</p> <pre><code>maximum (n : Nat) (k : Nat) : Nat := if (n &lt; k) k n;</code></pre> <p>Note that calling the function with an argument of the wrong type will result in a type error:</p> <pre><code>maximum 1 true</code></pre> <p>In Juvix, all functions expect precisely one argument. A function that appears to take two arguments actually takes a single argument and returns a new function.</p> <pre><code>maximum3 : Nat -&gt; Nat := maximum 3;</code></pre>"},{"location":"tutorials/workshop/#step-3-types-in-juvix","title":"Step 3: Types in Juvix","text":"<p>Juvix is a typed functional language, allowing you to define types. We've already seen some types like <code>Nat</code>, <code>Int</code>, and <code>Bool</code> that are defined in the standard library.</p> <p>You can inspect their definition by using <code>:def</code> in the REPL:</p> <pre><code>:def Bool</code></pre> <p>Or navigate to their definition using CMD+click.</p> <p>Every type is defined by a number of constructors. For <code>Bool</code>, there are two constructors <code>true</code> and <code>false</code>. Constructors in Juvix simply gather the data of the type together.</p> <p>For instance, let's look at the type <code>Nat</code>, which represents non-negative integers. The <code>zero</code> constructor represents 0, while the <code>suc</code> constructor takes one argument and represents the successor of some other number. This is a recursive datatype because the <code>suc</code> constructor takes another <code>Nat</code>.</p> <pre><code>suc (suc (suc zero))</code></pre>"},{"location":"tutorials/workshop/#step-4-pattern-matching","title":"Step 4: Pattern Matching","text":"<p>We can define functions by pattern matching on the constructors of a type:</p> <pre><code>isZero : Nat -&gt; Bool\n | zero := true;\n | (suc k) := false;</code></pre>"},{"location":"tutorials/workshop/#step-5-recursive-functions","title":"Step 5: Recursive Functions","text":"<p>Recursive types are useful when defining recursive functions. Consider the function <code>even</code>:</p> <pre><code>even : Nat -&gt; Bool\n  | zero := true;\n  | (suc k) := not (even k);</code></pre> <p>Juvix will check that recursive functions will eventually terminate.</p> <pre><code>even : Nat -&gt; Bool\n  | zero := true;\n  | (suc k) := not (even (suc k));</code></pre>"},{"location":"tutorials/workshop/#step-6-polymorphism","title":"Step 6: Polymorphism","text":"<p>Types in Juvix can take arguments, leading to polymorphic types like <code>List Nat</code>, <code>List String</code>, and <code>List (List Bool)</code>.</p> <p>Let's examine the definition of <code>List</code>:</p> <pre><code>:def List\n[1]</code></pre> <p>We can define polymorphic functions by defining a function that takes a type as an argument:</p> <pre><code>length' {A} : List A -&gt; Nat\n  |  nil := 0;\n  | (x :: xs) := suc (length' xs);</code></pre> <p>The type argument can be determined from the other arguments. So Juvix allows you to omit the type arguments by marking them as implicit by wrapping them in curly braces.</p>"},{"location":"tutorials/workshop/#step-7-iterators","title":"Step 7: Iterators","text":"<p>Finally, let's look at iterator syntax in Juvix. This allows us to write folds from functional programming in a more readable and imperative style.</p> <pre><code>sum (xs : List Nat) : Nat := for (acc := 0) (x in xs) x + acc;</code></pre> <p>In this code, we're iterating over a list. Before the iteration begins, <code>acc</code> is set to <code>0</code>. The list is then traversed from beginning to end, and at each step, <code>acc</code> is updated with the value of the body <code>x + acc</code>.</p> <p>There are also iterator syntaxes for <code>map</code> where we apply a function to each element.</p> <pre><code>mult2  (xs : List Nat) : List Nat := map (x in xs) x * 2;</code></pre> <p>And filters</p> <pre><code>filterLarge (xs : List Nat) : List Nat := filter (x in xs) x &lt; 10;</code></pre> <p>You can find more examples of iterators in the standard library, and it's possible to define your own.</p>"},{"location":"tutorials/workshop/#step-8-exercises","title":"Step 8: Exercises","text":"<p>The exercises for this section are in https://github.com/anoma/juvix-workshop/blob/main/exercises/Exercises.juvix. You will find the following content, and your task is to replace the <code>add-solution-here</code> with your solution.</p> Exercises.juvixSolutions.juvix <pre><code>-- See https://docs.juvix.org/dev/tutorials/learn/#exercises for more exercises\nmodule Exercises;\n\nimport Stdlib.Prelude open;\n\nimport Stdlib.Data.Nat.Ord;\nimport Stdlib.Data.Int.Ord as Int;\n\n-- Delete this function when you have completed the exercises\naxiom add-solution-here : {A : Type} -&gt; A;\n\n--- Write a function that computes the exponentation n^m\nexp : Nat -&gt; Nat -&gt; Nat := add-solution-here;\n\n--- Write a function that returns the last element in a list\nlast {A} : List A -&gt; Maybe A := add-solution-here;\n\n--- Write a function that reverses a list\nrev {A} : List A -&gt; List A := add-solution-here;\n\n--- Write a function that computes the maximum element in a list of natural numbers\nmaximum : List Nat -&gt; Nat := add-solution-here;\n\n--- Write a function that computes the list of partial sums of a list of natural numbers\nsums : List Nat -&gt; List Nat := add-solution-here;\n\n--- Write a function that return the first element in a list that satisfies a predicate\nfindFirst {A} : (A -&gt; Bool) -&gt; List A -&gt; Maybe A :=\nadd-solution-here;\n\n--- Write a function that returns the longest initial sublist of elements that satisfy a predicate\ntakeWhile {A} : (A -&gt; Bool) -&gt; List A -&gt; List A :=\nadd-solution-here;\n\n--- Write a function which computes the length of a longest continuous sublist of elements satisfying a predicate\nlongest {A} : (A -&gt; Bool) -&gt; List A -&gt; Nat :=\nadd-solution-here;\n\ntype Tree (A : Type) :=\n| leaf A\n| node (Tree A) (Tree A);\n\n--- Write a function that counts the total number of leaves in a tree\ncountLeaves {A} : Tree A -&gt; Nat := add-solution-here;\n\n--- Write a function which checks if a ;Tree; is balanced.\n--- A ;Tree; is balanced if the number of leaves in the left and right subtree of every\n--- node differ by at most 1.\nisBalanced {A} : Tree A -&gt; Bool := add-solution-here;</code></pre> <pre><code>module Solutions;\n\nimport Stdlib.Prelude open public;\nimport Stdlib.Data.Nat.Ord open public;\n\nimport Stdlib.Data.Int.Ord as Int;\n\n--- Write a function that computes the exponentation n^m\nexp (x : Nat) : Nat -&gt; Nat\n| zero := 1\n| (suc n) := x * exp x n;\n\n--- Write a function that checks if a ;Nat; is prime\nisPrime (n : Nat) : Bool :=\nlet\n    go : Nat -&gt; Bool\n    | zero := true\n    | (suc zero) := true\n    | k@(suc k') := if (mod n k == 0) false (go k');\nin case n of {\n    | zero := false\n    | suc zero := false\n    | suc k := go k\n};\n\n--- Write a function that returns the last element in a list\nlast {A} : List A -&gt; Maybe A\n| nil := nothing\n| (x :: nil) := just x\n| (_ :: xs) := last xs;\n\n--- Write a function that reverses a list\nrev {A : Type} (xs : List A) : List A :=\nfor (acc := nil) (x in xs)\n    x :: acc;\n\n--- Write a function that computes the maximum element in a list of natural numbers\nmaximum (xs : List Nat) : Nat :=\nfor (acc := 0) (x in xs)\n    if (x &gt; acc) x acc;\n\n--- Write a function that computes the list of partial sums of a list of natural numbers\nsums (xs : List Nat) : List Nat :=\nreverse\n    $ fst\n    $ for (acc, s := nil, 0) (x in xs)\n        x + s :: acc, x + s;\n\n--- Write a function that computes the first element in a list that satisfies a predicate\nfindFirst {A} (p : A -&gt; Bool) : List A -&gt; Maybe A\n| nil := nothing\n| (x :: xs) := if (p x) (just x) (findFirst p xs);\n\n--- Write a function that returns the longest initial sublist of elements that satisfy a predicate\ntakeWhile {A} (p : A -&gt; Bool) : List A -&gt; List A\n| nil := nil\n| (x :: xs) := if (p x) (x :: takeWhile p xs) nil;\n\n--- Write a function which computes the length of a longest continuous sublist of elements satisfying a predicate\nlongest {A : Type} (p : A -&gt; Bool) (xs : List A) : Nat :=\n-- `len` is the length of the longest sublist found so far\n-- `len'` is the length of the longest sublist ending at the current element\ncase for (len, len' := 0, 0) (x in xs)\n        if (p x)\n            (len, len' + 1)\n            (max len len', 0) of\n{  len, len' := max len len'};\n\ntype Tree (A : Type) :=\n| leaf A\n| node (Tree A) (Tree A);\n\n--- Write a function that counts the total number of leaves in a tree\ncountLeaves {A} : Tree A -&gt; Nat\n| (leaf _) := 1\n| (node l r) := countLeaves l + countLeaves r;\n\n--- Write a function which checks if a ;Tree; is balanced.\n--- A ;Tree; is balanced if the number of leaves in the left and right subtree of every\n--- node differ by at most 1.\nisBalanced {A} : Tree A -&gt; Bool :=\nlet\n    go : Tree A -&gt;\n    Bool -- returns the value if the given tree is balanced\n    \u00d7 Nat -- returns the number of leaves in the given tree\n    | (leaf _) := true, 1\n    | (node l r) :=\n        case go l, go r of\n        { (isLeftBalance, nl), (isRightBalance, nr) :=\n                (isLeftBalance &amp;&amp; isRightBalance &amp;&amp;\n                    sub nr nl &lt;= 1\n                &amp;&amp; sub nl nr &lt;= 1),\n            nl + nr};\nin fst \u2218 go;</code></pre>"},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/archive/2022/","title":"2022","text":""},{"location":"blog/category/geb/","title":"geb","text":""},{"location":"blog/category/vampir/","title":"vampir","text":""},{"location":"blog/category/language/","title":"language","text":""},{"location":"blog/category/conference/","title":"conference","text":""},{"location":"blog/category/type-system/","title":"type-system","text":""}]}