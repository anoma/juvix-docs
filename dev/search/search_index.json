{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stemmer","stopWordFilter","trimmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"README.html","title":"Juvix a language for intent-centric and declarative decentralized applications","text":"<p>Install Juvix on your machine</p> <p>  Try Juvix now on Codespaces</p> <p>Juvix is an open-source functional language with static typing and strict semantics. It is the programming language for the Anoma's blockchain. The primary purpose of this language is to encode Anoma's intents, enabling private and transparent execution through the Abstract Resource Machine on the Anoma blockchain.</p> <p>Juvix, initially designed for Anoma, provides features typical of any high-level programming language with many more on the horizon. It can compile programs into native executable, WASM, Cairo bytecode and arithmetic circuits facilitating zero-knowledge proofs.</p> <p>Stay tuned for Juvix updates and follow us on  Twitter!</p> <ul> <li> <p> How-to guides</p> <p>Learn how to install Juvix on macOS or Linux, as well as compile and    document your Juvix projects.</p> <p> Quick start</p> <p> How-to guides</p> </li> <li> <p> Tutorials</p> <p>Master the essentials of Juvix through a series of tailored examples, tutorials and technical explanations.</p> <p> Essential Juvix</p> <p> Functional programming with Juvix</p> <p> Tutorials</p> </li> <li> <p> Talks and Workshops</p> <p>A collection of talks and workshop videos showcasing Juvix. Gain valuable insights and inspiration from our presentations at various conferences.</p> <p> Juvix videos</p> </li> <li> <p> Reference</p> <p>Explore the language reference, milestone examples, and tooling documentation!</p> <p> Reference</p> <p> Standard library</p> <p> Packages and projects</p> </li> <li> <p> Blog</p> <p>Check out our blog to discover new features in the upcoming release, along with helpful examples and more.</p> <p> Blog</p> </li> <li> <p> Open Source, GPL3.0</p> <p>Juvix is licensed under GPL3 and available on GitHub.</p> <p> License</p> </li> </ul>"},{"location":"README.html#a-brief-overview-of-what-juvix-is-about","title":"... a brief overview of what Juvix is about","text":""},{"location":"everything.html","title":"Everything","text":"<pre><code><pre>module everything;import README;import tutorials.vscode;import tutorials.emacs;import tutorials.learn;import tutorials.essential;import reference.language.lets;import reference.language.aliases;import reference.language.pragmas;import reference.language.fixity;import reference.language.operators;import reference.language.datatypes;import reference.language.functions;import reference.language.builtins;import reference.language.axioms;import reference.language.traits;import reference.language.records;</pre></code></pre>"},{"location":"juvix-packages.html","title":"Juvix Packages and Projects","text":""},{"location":"juvix-packages.html#quick-start","title":"Quick Start","text":"<p>To install a package, you must sure that you have created the <code>Package.juvix</code> file. You can run <code>juvix init</code> to get a template <code>Package.juvix</code> file. A more detailed description on the usage of <code>Package.juvix</code> can be found in How to setup a Juvix project. For now, one example is provided below. Put the following in your <code>Package.juvix</code> file within the directory of your project.</p> Package.juvix <pre><code>module Package;\n\nimport PackageDescription.V2 open;\n\npackage : Package := defaultPackage@{\ndependencies :=\n[\n  github \"anoma\" \"juvix-stdlib\" \"v0.9.0\"\n]\n};\n</code></pre> <ul> <li> <p> <code>anoma/juvix-stdlib</code></p> DescriptionInstall <p>Shipped with Juvix, the standard library provides a set of useful functions and types for writing Juvix programs.</p> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"juvix-stdlib\" \"v0.9.0\"\n</code></pre> </li> <li> <p> <code>anoma/juvix-test</code></p> DescriptionInstall <p>A unit testing framework for Juvix programs.</p> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"juvix-test\" \"v0.18.0\"\n</code></pre> </li> <li> <p> <code>anoma/juvix-quickcheck</code></p> DescriptionInstall <p>This package provides property-based testing for the Juvix programming language inspired by the popular Haskell library, QuickCheck.</p> <ul> <li> Automated testing: Generate random test cases to validate properties of Juvix code.</li> </ul> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"juvix-quickcheck\" \"v0.18.0\"\n</code></pre> </li> </ul>"},{"location":"juvix-packages.html#projects-using-juvix","title":"Projects using Juvix","text":"<ul> <li> <p> Anoma App Library</p> DescriptionInstall <p>A library for intent-centric application development.</p> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"anoma-app-patterns\" \"v0.5.0\"\n</code></pre> </li> </ul> <p>Please let us know if you are using Juvix in your project. Opening an issue or a pull request to add it to this list.</p> <p>Check out other examples of Juvix programs in the examples/milestone.</p>"},{"location":"talks.html","title":"Talks and workshops","text":"<p>On this page you will find a collection of our talks and workshop videos showcasing Juvix.</p>"},{"location":"talks.html#2023","title":"2023","text":"<ul> <li>Veronika Romashkina (2023, July 10). Juvix: Towards a Functional Programming Language for Decentralized Applications and Beyond [Video]. Retrieved from YouTube. Link to the video</li> </ul>"},{"location":"talks.html#2022","title":"2022","text":"<ul> <li>Paul Cadman (2022, July 20). Juvix [Video]. Retrieved from YouTube. Link to the video</li> </ul>"},{"location":"blog/index.html","title":"Juvix Blog","text":"<p>Welcome! Join us in our cozy corner as we explore functional programming and next-generation distributed apps, sharing insights on Juvix, its development, and discussing related concepts. Stay tuned for our upcoming events and let's embark on this exciting journey together!</p>"},{"location":"blog/iterators.html","title":"Iterator syntax","text":"<p>A common pattern in functional programming is the traversal of data structures, particularly lists, in a specified order accumulating some values. If you've used languages like Haskell or OCaml, you must have come across the \"fold left\" (<code>foldl</code>) and \"fold right\" (<code>foldr</code>) higher-order functions which implement this pattern. These functions are also available in Juvix. In this blog post, I describe an iterator syntax I designed for Juvix which allows expressing folds (and maps, filters and more) in a readable manner.</p> <p>The next paragraph discusses some issues with using fold functions directly. Don't worry if you've never heard of folds - just skip this paragraph and the rest of the blog post will teach you how to use them in a nice iterator syntax.</p> <p>The problem with folds is that they are hard to read and understand, which results in code that is difficult to maintain. From a fold application, e.g., <code>foldr \\{acc x := body} a xs</code>, it is not always immediately apparent how the list traversal proceeds. This is especially the case when the function argument is big and spans several lines - then the initial value <code>a</code> of the accumulator and the list <code>xs</code> are syntactically \"disconnected\" from the accumulator variable <code>acc</code> and the current list element <code>x</code>. Personally, I also find it hard to remember which argument is which - this differs between different functional languages. I'm not the first person who noticed this problem. For example, the unreadability of folds was one of the motivations behind introducing a monadic <code>for .. in</code> notation in Lean 4.</p>","tags":["iterators","syntax"]},{"location":"blog/iterators.html#the-essence-of-folds","title":"The essence of folds","text":"<p>The anatomy of a fold (left or right) is simple.</p> <ol> <li> <p>We have an accumulator variable <code>acc</code> which we initialise to some value <code>a</code>.</p> </li> <li> <p>We go through a data structure (list) in some specified order (left-to-right    or right-to-left).</p> </li> <li> <p>At each step, we receive the current value of the accumulator <code>acc</code> and the    current element <code>x</code>. From those we need to compute the new value of <code>acc</code>.</p> </li> <li> <p>After going through all elements, the final value of <code>acc</code> is the result of    the fold expression.</p> </li> </ol>","tags":["iterators","syntax"]},{"location":"blog/iterators.html#the-for-notation","title":"The for-notation","text":"<p>The Juvix standard library defines two iterators on lists which correspond to list folds:</p> <ul> <li><code>for</code> as a syntactic sugar for fold left (<code>foldl</code>),</li> <li><code>rfor</code> as a syntactic sugar for fold right (<code>foldr</code>).</li> </ul> <p>Iterator application has the syntax:</p> <pre><code>for (acc := a) (x in xs) {body}\n</code></pre> <p>If <code>body</code> is an atom, the braces can be omitted.</p> <p>The above <code>for</code> iteration starts with the accumulator <code>acc</code> equal to <code>a</code> and goes through the list <code>xs</code> from left to right (from beginning to end), at each step updating the accumulator to the result of evaluating <code>body</code>. The variables <code>acc</code>, <code>x</code> are locally bound in <code>body</code> where they denote the previous accumulator value (<code>acc</code>) and the current element (<code>x</code>). The final value of the accumulator becomes the value of the entire <code>for</code> expression.</p> <p>For example, the following code computes the sum of all numbers in the list <code>xs</code>:</p> <pre><code>for (acc := 0) (x in xs) {x + acc}\n</code></pre> <p>Product of all numbers in a list:</p> <pre><code>for (acc := 1) (x in xs) {x * acc}\n</code></pre> <p>Reversing a list:</p> <pre><code>for (acc := nil) (x in xs) {x :: acc}\n</code></pre> <p>Counting odd numbers in a list:</p> <pre><code>for (acc := 0) (x in xs) {\n  if\n    | mod x 2 == 0 := acc\n    | else := acc + 1\n}\n</code></pre> <p>Sum of squares of positive numbers in a list:</p> <pre><code>for (acc := 0) (x in xs) {\n  if\n   | x &gt; 0 := acc + x * x\n   | else := acc\n}\n</code></pre> <p>The <code>for</code> iterator is complemented by the <code>rfor</code> iterator which goes through the list from right to left (from end to beginning).</p> <p>For example, the following code concatenates all lists from a list of lists:</p> <pre><code>rfor (acc := nil) (x in xs) {x ++ acc}\n</code></pre> <p>If we used the <code>for</code> iterator above, the order of concatenations would be reversed.</p> <p>Applying a function <code>f</code> to each element in a list may be implemented with:</p> <pre><code>rfor (acc := nil) (x in xs) {f x :: acc}\n</code></pre> <p>Filtering a list with a predicate <code>p</code>:</p> <pre><code>rfor (acc := nil) (x in xs) {\n  if\n    | p x := x :: acc\n    | else := acc\n}\n</code></pre> <p>The above keeps only the elements that satisfy <code>p</code>. The order of the elements would be reversed if we used <code>for</code> instead of <code>rfor</code>.</p>","tags":["iterators","syntax"]},{"location":"blog/iterators.html#maps-filters-and-more","title":"Maps, filters and more","text":"<p>If you're familiar with the <code>map</code> and <code>filter</code> higher-order functions, you probably noticed that the last two examples above provide their implementations using <code>rfor</code>. In fact, one can use the iterator notation directly with <code>map</code> and <code>filter</code>, and several other list functions from the standard library. In this case, there are no explicit accumulators in the notation.</p> <p>The expression</p> <pre><code>map (x in xs) {body}\n</code></pre> <p>is equivalent to (assuming <code>acc</code> doesn't occur in <code>body</code>)</p> <pre><code>rfor (acc := nil) (x in xs) {(body) :: acc}\n</code></pre> <p>or if you're familiar with the standard <code>map</code> function:</p> <pre><code>map \\{x := body} xs\n</code></pre> <p>Similarly, one can use the notation</p> <pre><code>filter (x in xs) {p x}\n</code></pre> <p>to filter <code>xs</code> with the predicate <code>p</code>.</p> <p>Other functions that can be used with the iterator syntax are <code>all</code> and <code>any</code> which check whether <code>all</code>, resp. <code>any</code>, elements <code>x</code> in a list satisfy <code>body</code> (which would of course refer to <code>x</code>):</p> <pre><code>all (x in xs) {body}\n\nany (x in xs) {body}\n</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators.html#multiple-accumulators","title":"Multiple accumulators","text":"<p>In fact, the <code>acc</code> and <code>x</code> in the iterator syntax don't need to be variables - they can be arbitrary patterns. This is especially useful in conjunction with pairs, allowing to effectively operate on multiple accumulators.</p> <p>For example, to compute the largest and the second-largest element of a list of non-negative numbers one can use:</p> <pre><code>for (n, n' := 0, 0) (x in lst) {\n  if\n    | x &gt;= n := (x, n)\n    | x &gt; n' := (n, x)\n    | else := (n, n')\n}\n</code></pre> <p>where <code>n</code> is the largest and <code>n'</code> the second-largest element found so far.</p> <p>One can also operate on multiple lists simultaneously. For example, the following computes the dot product of the lists <code>xs</code>, <code>ys</code> (assuming they have equal lengths):</p> <pre><code>for (acc := 0) (x, y in zip xs ys) {x * y + acc}\n</code></pre> <p>The <code>zip</code> function creates a list of pairs of elements in the two lists, e.g.,</p> <pre><code>zip (1 :: 2 :: nil) (3 :: 4 :: nil) = (1, 3) :: (2, 4) :: nil\n</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators.html#declaring-iterators","title":"Declaring iterators","text":"<p>Iterator syntax can be enabled for any identifier <code>func</code> with the declaration:</p> <pre><code>syntax iterator func;\n</code></pre> <p>Then any iterator application of the form</p> <pre><code>func (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}\n</code></pre> <p>is automatically replaced by</p> <pre><code>func \\{acc1 .. accn x1 .. xk := body} acc1 .. accn xs1 .. xsk\n</code></pre> <p>The replacement is entirely syntactic and happens before type-checking.</p> <p>It is possible to restrict the number of initialisers (<code>acci := ai</code>) and ranges (<code>xi in xsi</code>) accepted:</p> <pre><code>syntax iterator func {init: n, range: k};\n</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators.html#further-reading","title":"Further reading","text":"<p>More information on iterators can be found in the Juvix language reference and the Juvix tutorial.</p>","tags":["iterators","syntax"]},{"location":"blog/strictly-positive-data-types.html","title":"Stay Positive","text":"<p>Let us explore the concept of strictly positive inductive data types, a critical requirement within the Juvix framework for classifying a data type as well-typed.</p> <p>An inductive type is considered strictly positive if it either:</p> <ol> <li>Does not appear within the argument types of its constructors, or</li> <li>Appears strictly positively within the argument types of its constructors.</li> </ol> <p>A name is considered strictly positive for an inductive type if it never appears in a negative position within the argument types of its constructors. The term negative position denotes instances located to the left of an arrow in a type constructor argument.</p>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types.html#example","title":"Example","text":"<p>Consider the following data type <code>X</code> where <code>A</code> and <code>B</code> are types in scope:</p> <pre><code>  type X :=\n    | c0 : (B -&gt; X) -&gt; X\n    | c1 : (X -&gt; A) -&gt; X;\n</code></pre> <p>In this example, the type <code>X</code> occurs strictly positively in the constructor <code>c0</code>, but negatively in the constructor <code>c1</code> in the type argument <code>X -&gt; A</code>. Therefore, <code>X</code> is not strictly positive.</p> <p>Positive parameters can also be described as those that do not occur in negative positions. For instance, the type <code>B</code> in the <code>c0</code> constructor above appears to the left of the arrow <code>B-&gt;X</code>, placing <code>B</code> in a negative position. It is essential to consider negative parameters when verifying strictly positive data types, as they might enable the definition of non-strictly positive data types.</p> <p>Let us consider another example:</p> <pre><code>  type T0 (A : Type) := c0 : (A -&gt; T0 A) -&gt; T0 A;\n</code></pre> <pre><code>  type T1 := c1 : T0 T1 -&gt; T1;\n</code></pre> <p>In this example, the type <code>T0</code> is strictly positive, while the type <code>T1</code> is not. It is only after unfolding the type application <code>T0 T1</code> in the data constructor <code>c1</code> that we can determine <code>T1</code> occurs in a negative position due to <code>T0</code>. More specifically, the type parameter <code>A</code> of <code>T0</code> is negative.</p>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types.html#bypassing-the-strict-positivity-condition","title":"Bypassing the Strict Positivity Condition","text":"<p>To bypass the positivity check in a data type declaration, you can annotate it with the <code>positive</code> keyword. Alternatively, you can use the CLI global flag <code>--no-positivity</code> when type checking a <code>Juvix</code> file.</p> <pre><code>  positive\n  type T0 (A : Type) := c0 : (T0 A -&gt; A) -&gt; T0 A;\n</code></pre>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types.html#examples-of-non-strictly-positive-data-types","title":"Examples of Non-Strictly Positive Data Types","text":"<ul> <li>The <code>Bad</code> data type is not strictly positive due to the negative parameter <code>A</code>   of <code>Tree</code>.</li> </ul> <pre><code>  type Tree (A : Type) :=\n    | leaf : Tree A\n    | node : (A -&gt; Tree A) -&gt; Tree A;\n</code></pre> <pre><code>  type Bad := bad : Tree Bad -&gt; Bad;\n</code></pre> <ul> <li><code>A</code> is a negative parameter.</li> </ul> <pre><code>  type B (A : Type) := b : (A -&gt; B (B A -&gt; A)) -&gt; B A;\n</code></pre>","tags":["type-system","inductive-types"]},{"location":"explanations/index.html","title":"Index","text":"<p>Welcome to the Explanations section! In this part, we will dive into various coding concepts and techniques that are essential for every developer. We will cover a wide range of topics, from basic programming principles to more advanced subjects.</p>"},{"location":"explanations/typetheory.html","title":"Type theory","text":""},{"location":"explanations/totality/coverage.html","title":"Coverage checking","text":""},{"location":"explanations/totality/positive.html","title":"Strictly positive data types","text":""},{"location":"explanations/totality/termination.html","title":"Termination","text":"<p>To prevent inconsistencies arising from function declarations, Juvix mandates that every function passes its termination checker. Nevertheless, this requirement can be challenging to meet; thus, we provide users with two distinct methods for bypassing this check:</p>"},{"location":"explanations/totality/termination.html#keyword","title":"Keyword","text":"<p>Utilize the terminating keyword to annotate function type signatures as terminating. In the following example we mark the function <code>fun</code> as terminating.</p> <pre><code>terminating\nfun : A \u2192 B;\n</code></pre> <p>Note</p> <p>Annotating a function with the <code>terminating</code> keyword indicates that all of its function clauses meet the termination checker's criteria. For mutual recursive functions, to bypass the termination checker, all involved functions must be annotated as <code>terminating</code>.</p>"},{"location":"explanations/totality/termination.html#cli-flag","title":"CLI flag","text":"<p>You can disable the termination checking by utilizing the global CLI flag <code>--no-termination</code>.</p> <pre><code>juvix --no-termination typecheck MyProgram.juvix\n</code></pre> <p>Note</p> <p>Please note that our termination checker has certain limitations, as it only accepts a subset of recursive functions. The algorithm used in the termination checker is a minor adaptation of the one employed for checking termination in the Foetus language.</p>"},{"location":"howto/index.html","title":"How-to guides","text":"<ul> <li>Installing Juvix</li> <li>Compiling programs</li> <li>Setting up a project</li> <li>Contributing</li> <li>Judoc documentation tool</li> </ul>","boost":4},{"location":"howto/compilation.html","title":"Program Compilation","text":"","boost":5},{"location":"howto/compilation.html#example-hello-world","title":"Example: Hello World","text":"<p>A Juvix file must declare a module with the same name as the file. For instance, <code>HelloWorld.juvix</code> should declare a module <code>HelloWorld</code>:</p> <pre><code>-- This is a comment.\nmodule Hello;\n\n  -- Importing the 'String' type from standard library prelude\n  import Stdlib.Prelude open;\n\n  main : String := \"Hello world!\";\n</code></pre> <p>The zero-argument function <code>main</code> is evaluated when running the program and must be defined in a file compiled to an executable.</p> <p>To compile <code>HelloWorld.juvix</code>, type:</p> <pre><code>juvix compile native HelloWorld.juvix\n</code></pre>","boost":5},{"location":"howto/compilation.html#compilation-targets","title":"Compilation Targets","text":"<p>Juvix supports several targets, including <code>native</code>, <code>wasi</code> (for web assembly), <code>anoma</code> and <code>cairo</code> among others. To see the full list use:</p> <pre><code>juvix compile --help\n</code></pre>","boost":5},{"location":"howto/compilation.html#juvix-projects","title":"Juvix Projects","text":"<p>A Juvix project is a collection of Juvix modules in one main directory containing a <code>Package.juvix</code> metadata file. Each module's name must match its file path, relative to the project's root directory. For instance, if the file is <code>root/Data/List.juvix</code>, the module should be called <code>Data.List</code>.</p> <p>To initialize a Juvix project interactively in the current directory, use <code>juvix init</code>.</p> <p>To verify correct project root detection by Juvix, run, for instance,</p> <pre><code>juvix dev root\n</code></pre> <p>Refer to: Modules Reference.</p>","boost":5},{"location":"howto/contributing.html","title":"Contributing to Juvix","text":"<p>Thank you for considering contributing to Juvix! We welcome all contributions, big or small, of any kind. We appreciate any help/feedback we can get.</p>"},{"location":"howto/contributing.html#getting-started","title":"Getting Started","text":"<p>Make sure you have followed the installation instructions and have a working Juvix installation. You can also use the web-based development environment ready to the Juvix development, Juvix Github Codespace</p> <ol> <li>Fork the repository.</li> <li>Clone your forked repository to your local machine.</li> <li>Install Stack and just if you haven't already.</li> <li>Build the project by running <code>just build</code>. To install the binaries to your    local <code>~/.local/bin</code>, run <code>just install</code>.</li> <li>Run the tests by running <code>stack test</code>.</li> <li>Make sure to install the pre-commit binary, so you can run the    pre-commit hooks by running <code>make precommit</code> in the root directory of the    project. All the Pull Requests will be checked by the pre-commit hooks.</li> </ol>"},{"location":"howto/contributing.html#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your changes: <code>git checkout -b my-branch-name</code>. In    case you are working on an issue, please name your branch after the issue    number, e.g. <code>issue-123</code>.</li> <li>Make your changes and commit them with a descriptive message.</li> <li>Push your changes to your forked repository: <code>git push origin    my-branch-name</code>.</li> <li>Submit a pull request to the main repository with a concise description of    your changes.</li> <li>Make sure that your pull request passes all the tests and pre-commit hooks.</li> </ol>"},{"location":"howto/contributing.html#haskell-code-style","title":"Haskell Code Style","text":"<p>We value readability and maintainability over saving lines of code. The best source of truth for the Juvix code style is the existing codebase. We strongly encourage you to look at the existing code and follow the same style. Open an issue if you have any questions.</p> <p>Some basic guidelines when writing code:</p> <ul> <li>Use clear and descriptive names for variables, functions, and types.</li> <li>Keep functions short and focused on a single task. Separate functions when   they start to get too long.</li> <li>Use comments to explain complex or non-obvious code.</li> <li>Run <code>make format</code> to format your code with <code>ormolu</code>.</li> </ul>"},{"location":"howto/contributing.html#testing","title":"Testing","text":"<p>Please include tests for any new functionality or bug fixes. The tests are located in the <code>test</code> directory, the tests are written in Haskell and use the tasty framework. To run the tests, run <code>stack test</code>. If you are changing the CLI, please also update the smoke tests in the <code>tests/smoke</code> directory.</p>"},{"location":"howto/contributing.html#code-review","title":"Code Review","text":"<p>All pull requests will be reviewed by at least one member of the development team. Feedback may be provided on the code itself, as well as on the tests and documentation.</p> <p>Thank you for contributing to Juvix!</p>"},{"location":"howto/installing.html","title":"Installing Juvix","text":"","boost":5},{"location":"howto/installing.html#prerequisites","title":"Prerequisites","text":"<p>You need Clang / LLVM version 13 or later. Note that on macOS the preinstalled clang does not support the <code>wasm</code> target, so use e.g. <code>brew install llvm</code> instead.</p> <p>For the <code>wasm</code> and <code>risc0-rust</code> targets additional optional dependencies are needed. See below for instructions on how to install them.</p>","boost":5},{"location":"howto/installing.html#shell-script","title":"Shell script","text":"<p>We provide a shell script that installs the Juvix compiler binary for Linux and macOS using the GitHub release page.</p> <p>Copy and paste the following command into your terminal to install Juvix.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSfL https://get.juvix.org | sh\n</code></pre> <p>In VSCode, install Juvix automatically with the Juvix VSCode   extension.</p>","boost":5},{"location":"howto/installing.html#macos","title":"MacOS","text":"<p>The easiest way to install Juvix on MacOS is by using Homebrew.</p> <p>To install the homebrew-juvix tap, run:</p> <pre><code>brew tap anoma/juvix\n</code></pre> <p>To install Juvix, run:</p> <pre><code>brew install juvix\n</code></pre> <p>Helpful information can also be obtained by running:</p> <pre><code>brew info juvix\n</code></pre>","boost":5},{"location":"howto/installing.html#linux-x86_64","title":"Linux x86_64","text":"<p>A Juvix compiler binary executable for Linux x86_64 is available on the Juvix release page.</p> <p>To install this executable, download and unzip the linked file and move it to a directory on your shell's <code>PATH</code>.</p> <p>For example if <code>~/.local/bin</code> is on your shell's <code>PATH</code>, you can install Juvix as follows:</p> <pre><code>cd /tmp\ncurl https://api.github.com/repos/anoma/juvix/releases/latest \\\n  | grep \"browser_download_url.*linux\" \\\n  | cut -d : -f2,3 | tr -d \\\" \\\n  | xargs curl -L -o linux_release.zip\nunzip linux_release.zip\nmv juvix ~/.local/bin/juvix\n</code></pre>","boost":5},{"location":"howto/installing.html#building-juvix-from-source","title":"Building Juvix from source","text":"<p>To install Juvix from source you must clone the GitHub repository. Then Juvix can be installed with the following commands. We assume you have Stack and GNU Make installed.</p> <pre><code>git clone --recursive https://github.com/anoma/juvix.git\ncd juvix\nmake install\n</code></pre> <p>The C compiler and linker paths can be specified as options to the <code>make install</code> command, e.g.</p> <pre><code>make install CC=path/to/clang LIBTOOL=path/to/llvm-ar\n</code></pre> <p>On macOS, you can alternatively run the following command for Homebrew. The flag <code>--HEAD</code> used below is optional \u2013 use it to build the latest version of Juvix in the <code>main</code> branch on GitHub.</p> <pre><code>brew install --build-from-source --HEAD juvix --verbose\n</code></pre>","boost":5},{"location":"howto/installing.html#building-the-project-with-cabal","title":"Building the project with <code>cabal</code>","text":"<p>We recommend using the <code>stack</code> build tool with this project.</p> <p>If you prefer the <code>cabal</code> build tool instead, then you need to generate the <code>juvix.cabal</code> file using hpack before running <code>cabal build</code>.</p> <p>You also need to compile the runtime first:</p> <pre><code>make runtime\ncabal build\n</code></pre>","boost":5},{"location":"howto/installing.html#installing-optional-dependencies","title":"Installing optional dependencies","text":"","boost":5},{"location":"howto/installing.html#webassembly","title":"WebAssembly","text":"<p>If you want to compile to WebAssembly, you need to install:</p> <ul> <li>wasmer</li> <li>wasi-sdk</li> <li>wasm-ld - the LLVM linker for WASM. On Linux   and newer versions of macOS, you may need to install the <code>lld</code>   package. On older macOS versions, this is installed as part of   <code>llvm</code>.</li> </ul> <p>To install <code>wasi-sdk</code> you need to download <code>libclang_rt</code> and <code>wasi-sysroot</code> precompiled archives from the wasi-sdk release page and:</p> <ol> <li> <p>Extract the <code>libclang_rt.builtins-wasm32-wasi-*.tar.gz</code> archive in     the <code>clang</code> installation root (for example <code>/usr/lib/clang/13</code> on     Ubuntu or <code>`brew --prefix llvm`</code> on macOS).</p> <p>For example on macOS with <code>homebrew clang</code>:</p> </li> </ol> <pre><code>cd `brew --prefix llvm`\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/libclang_rt.builtins-wasm32-wasi-15.0.tar.gz -OL\ntar xf libclang_rt.builtins-wasm32-wasi-15.0.tar.gz\n</code></pre> <ol> <li> <p>Extract the <code>wasi-sysroot-*.tar.gz</code> archive on your local system and     set <code>WASI_SYSROOT_PATH</code> to its path.</p> <p>For example:</p> </li> </ol> <pre><code>cd ~\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/wasi-sysroot-15.0.tar.gz -OL\ntar xf wasi-sysroot-15.0.tar.gz\nexport WASI_SYSROOT_PATH=~/wasi-sysroot\n</code></pre>","boost":5},{"location":"howto/installing.html#risc-zero","title":"RISC Zero","text":"<p>If you want to compile to RISC Zero via Rust, using the <code>risc0-rust</code> target, you need to have Rust and cargo installed. To compile the Rust code generated by Juvix for RISC Zero, and then generate and verify the proof, you need to install the RISC Zero Rust toolchain.</p> <p>Checking your setup</p> <p>Run <code>juvix doctor</code> in your terminal to validate your setup.</p>","boost":5},{"location":"howto/project.html","title":"How to setup a Juvix project","text":"<p>A Juvix project is a collection of Juvix modules plus some extra metadata gathered in a <code>Package.juvix</code> file. The most convenient way to create a Juvix project is to run the command:</p> <pre><code>      juvix init\n</code></pre>","boost":5},{"location":"howto/project.html#packagejuvix-file","title":"Package.juvix file","text":"<p>A project is rooted in a directory. The root is set by creating a <code>Package.juvix</code>. The simplest <code>Package.juvix</code> file, which uses the default configuration, is:</p> <pre><code>module Package;\n\nimport PackageDescription.V2 open;\n\npackage : Package := defaultPackage;\n</code></pre> <p>You can override the default options by passing arguments to <code>defaultPackage</code>:</p> <pre><code>package : Package :=\n  defaultPackage@{\n    name := \"my-package\";\n    version := mkVersion 0 1 0;\n    main := just \"Main.juvix\";\n  };\n</code></pre> <p>You can check the documentation of the <code>Package</code> type or the <code>defaultPackage</code> function by using the go-to-definition feature in your IDE.</p> <p>The arguments are explained below. All of them are optional.</p> <ul> <li>name: This is the name assigned to the project. The name must not be empty   and cannot exceed 100 characters. Lower case letters, digits and hyphen <code>-</code>   are acceptable characters. The first letter must not be a hyphen.   Summarizing, it must match the following regexp: <code>[a-z0-9][a-z0-9-]{0,99}</code>.   The default is <code>\"my-project\"</code>.</li> <li>version: The version of the project. It must follow the   SemVer specification. If unspecified, the default version is \"0.0.0\".</li> <li>main: The main module of the project used as entry point.</li> <li>dependencies: The dependencies of the project are given as a   list. See below for more information. If unspecified, the default is <code>defaultStdlib</code>.</li> </ul> <p>Note</p> <p>A Juvix module belongs to a Juvix project if it is   placed in the directory subtree of the root directory. This rule has two   exceptions:</p> <ol> <li>Modules in a hidden directory are not part of the      project. E.g., if the root of a project is <code>dir</code>, then the module      <code>dir/.d/Lib.juvix</code> does not belong to the project rooted in <code>dir</code>.</li> <li>A <code>Package.juvix</code> file shadows other <code>Package.juvix</code> files in parent      directories. E.g. if the root of a project is <code>dir</code> and the files      <code>dir/Package.juvix</code> and <code>dir/nested/Package.juvix</code> exist, then the module      <code>dir/nested/Lib.juvix</code> would belong to the project in <code>dir/nested</code>.</li> </ol> <p>Note</p> <p>Any Juvix module outside of a project is considered a standalone module and lives in its own (global) project. In other words, there is no need to create a <code>Package.juvix</code> file for a standalone module.</p>","boost":5},{"location":"howto/project.html#package-dependencies","title":"Package dependencies","text":"<p>In <code>Package.juvix</code>, the <code>Package</code> type includes a dependencies field, which lists other Juvix packages required by the project, with each dependency represented as an element of the <code>Dependency</code> type.</p> <p>Your project's code can use modules from dependent packages via Juvix <code>import</code> statements.</p> <p>There are three types of dependencies, all illustrated in the following snippet:</p> <pre><code>package : Package :=\n  defaultPackage@{\n    name := \"my-package\";\n    version := mkVersion 0 1 0;\n    dependencies :=\n      [\n        defaultStdlib;\n        git \"my-dependency\" \"https://my-git-repo-url\" \"my-git-ref\";\n        path \"a/path/to/a/juvix/package\";\n      ];\n  };\n</code></pre>","boost":5},{"location":"howto/project.html#git-dependencies","title":"Git Dependencies","text":"<p>A <code>git</code> dependency is a Juvix package located at the root of an external git repository. You can specify such a dependency in two ways:</p> <ol> <li>By using the <code>git</code> constructor of the <code>Dependency</code> type, you can declare the dependency by providing its name (used to name the directory where the repository is cloned), the git repository URL, and the specific reference (like a version tag or branch). For example:</li> </ol> <pre><code>git \"juvix-quickcheck\" \"https://github.com/anoma/juvix-quickcheck\" \"v0.15.0\"\n</code></pre> <ol> <li>By using the <code>github</code> function, which is a convenient method for packages hosted on GitHub. This function requires the GitHub organization name, the repository name, and the reference you're targeting. For example:</li> </ol> <pre><code>github \"anoma\" \"juvix-quickcheck\" \"v0.15.0\"\n</code></pre> <p>Note</p> <p>The values of the <code>name</code> fields must be unique among the git blocks in the dependencies list.</p>","boost":5},{"location":"howto/project.html#path-dependencies","title":"Path Dependencies","text":"<p>A <code>path</code> dependency is a Juvix package located on your local filesystem. You can refer to such dependencies using absolute or relative paths. For example:</p> <pre><code>path \".deps/a/juvix/package\"\n</code></pre>","boost":5},{"location":"howto/project.html#the-built-in-juvix-standard-library-defaultstdlib","title":"The built-in Juvix standard library - <code>defaultStdlib</code>","text":"<p>The Juvix standard library is included with the Juvix compiler, and you can depend on it by using the <code>defaultStdlib</code> constructor.</p>","boost":5},{"location":"howto/project.html#behaviour-of-git-dependencies","title":"Behaviour of Git dependencies","text":"<p>When dependencies for a package are registered, at the beginning of the compiler pipeline, all remote dependencies are processed:</p> <ol> <li>If it does not already exist, the remote dependency is cloned to    <code>.juvix-build/deps/$name</code></li> <li><code>git fetch</code> is run in the clone</li> <li><code>git checkout</code> at the specified <code>ref</code> is run in the clone</li> </ol> <p>Note</p> <ul> <li>Remote dependencies of transitive dependencies are also processed.</li> <li>The <code>git fetch</code> step is required for the case where the remote is updated.</li> </ul> <p>Lock file</p> <ul> <li>A lock file, juvix.lock.yaml is generated in the same directory as <code>Package.juvix</code>. This file is used to     determine if any dependency needs to be updated. If the <code>ref</code> in the     lock file does not match the <code>ref</code> in the package file, it is considered out of date.</li> </ul>","boost":5},{"location":"howto/project.html#fixing-errors","title":"Fixing errors","text":"<ul> <li>Juvix parse or typechecker errors will be reported by the Juvix compiler.</li> <li>Duplicate <code>name</code> values in the dependencies list is an error thrown when the package file is processed.</li> <li>The <code>ref</code> does not exist in the clone or the clone directory is otherwise   corrupt. An error with a suggestion to <code>juvix clean</code> is given. The package   file path is used as the location in the error message.</li> <li>Other <code>git</code> command errors (command not found, etc.), a more verbose error is   given with the arguments that were passed to the git command.</li> </ul>","boost":5},{"location":"howto/quick-start.html","title":"Quick Start","text":"<p>To install Juvix, follow the instructions in the installation guide.</p> <p>After installation, run <code>juvix --help</code> to see the list of commands.</p> <p>Run Juvix doctor to check your system setup:</p> <pre><code>juvix doctor\n</code></pre>","boost":5},{"location":"howto/quick-start.html#cli-usage-examples","title":"CLI Usage Examples","text":"<p>Create a new package:</p> <pre><code>juvix init\n</code></pre> <p>Evaluate a source file:</p> <pre><code>juvix eval path/to/source.juvix\n</code></pre> <p>Compile a source file into a native executable:</p> <pre><code>juvix compile native path/to/source.juvix\n</code></pre> <p>Compile a source file into a Nockma binary:</p> <pre><code>juvix compile anoma path/to/source.juvix\n</code></pre> <p>Launch the REPL:</p> <pre><code>juvix repl\n</code></pre> <p>Typecheck a source file:</p> <pre><code>juvix typecheck path/to/source.juvix\n</code></pre> <p>Generate HTML representations of a source file and its imports:</p> <pre><code>juvix html --recursive path/to/source.juvix\n</code></pre>","boost":5},{"location":"howto/quick-start.html#the-hello-world-example","title":"The Hello World example","text":"<p>This is the Juvix source code of the traditional Hello World program.</p> <pre><code>-- HelloWorld.juvix\nmodule HelloWorld;\n\nimport Stdlib.Prelude open;\n\nmain : IO := printStringLn \"hello world!\";\n</code></pre> <p>To compile and run a binary generated by Juvix, save the source code to a file called <code>HelloWorld.juvix</code> and run the following command from the directory containing it:</p> <pre><code>juvix compile native HelloWorld.juvix\n./HelloWorld\n</code></pre> <p>You should see the output: <code>hello world!</code>.</p> <p>You can also evaluate the file without compiling it first by executing</p> <pre><code>juvix eval HelloWorld.juvix\n</code></pre> <p>The output should be the same : <code>hello world!</code>.</p>","boost":5},{"location":"reference/index.html","title":"Reference","text":"","boost":4},{"location":"reference/index.html#language-reference","title":"Language reference","text":"<ul> <li>Functions</li> <li>Builtins</li> <li>Data types</li> <li>Records</li> <li>Traits</li> <li>Modules</li> <li>Local definitions</li> <li>Control structures</li> <li>Comments</li> <li>Pragmas</li> <li>Axioms</li> </ul>","boost":4},{"location":"reference/index.html#syntax-extensions","title":"Syntax extensions","text":"<ul> <li>Aliases</li> <li>Iterators</li> <li>Fixities</li> <li>Operators</li> </ul>","boost":4},{"location":"reference/index.html#libraries-and-projects","title":"Libraries and projects","text":"<ul> <li>Standard library</li> <li>Example programs</li> </ul>","boost":4},{"location":"reference/index.html#tooling","title":"Tooling","text":"<ul> <li>Documentation tool</li> <li>Command line interface</li> <li>Doctor</li> <li>Emacs mode</li> <li>Haskell test suite</li> </ul>","boost":4},{"location":"reference/index.html#compiler-implementation","title":"Compiler implementation","text":"<ul> <li>Compiler pipeline</li> </ul>","boost":4},{"location":"reference/benchmarks.html","title":"Benchmarks","text":""},{"location":"reference/compiler.html","title":"Compiler implementation","text":"<p>For readers interested in the internal workings of the Juvix compiler, the following technical reports describe important parts of the compilation pipeline.</p> Title Doi/url Date Compiling Juvix to Cairo assembly 10.5281/zenodo.13739343 Sep 10, 2024 The Core language of Juvix 10.5281/zenodo.8297159 Aug 29, 2023 Rethinking VampIR 10.5281/zenodo.8262815 Aug 29, 2023 Geb Pipeline 10.5281/zenodo.8262747 Aug 21, 2023 Juvix to VampIR Pipeline 10.5281/zenodo.8268823 Aug 14, 2023"},{"location":"reference/examples.html","title":"Examples of programs written in Juvix","text":"<p>The following links are clickable versions of their corresponding Juvix program. The sources can be found in the examples/milestone directory in the Juvix repository. The webpages can be generated by running the following command:</p> <pre><code>juvix html --recursive FileName.juvix\n</code></pre> <ul> <li>HelloWorld.juvix</li> <li>Fibonacci.juvix</li> <li>Hanoi.juvix</li> <li>PascalsTriangle.juvix</li> <li>Collatz.juvix</li> <li>TicTacToe.juvix</li> </ul>"},{"location":"reference/judoc.html","title":"Native Documentation Tool","text":"<p>Inspired by Haddock and Agda, Juvix has its own documentation tool called Judoc.</p> <p>Judoc is used to document parts of your code. You can attach Judoc blocks to the following entities:</p> <ul> <li>A module.</li> <li>A type definition.</li> <li>A constructor definition.</li> <li>A function definition.</li> <li>An axiom definition.</li> </ul> <p>In order to attach documentation to any of these entities, write blocks of documentation before them:</p> <ol> <li>For modules:</li> </ol> <pre><code>--- This module is cool\nmodule Cool;\n..\n</code></pre> <ul> <li>For type definitions:</li> </ul> <pre><code>--- Unary representation of natural numbers\ntype Nat : Type :=\n  | --- Nullary constructor representing number 0\n    zero : Nat\n  | --- Unary constructor representing the successor of a natural number\n    suc : Nat -&gt; Nat;\n</code></pre> <ul> <li>For functions (and likewise for axioms):</li> </ul> <pre><code>--- The polymorphic identity function\nid {A} (x : A) : A := x;\n</code></pre>"},{"location":"reference/judoc.html#block","title":"Block","text":"<p>A block can be one of:</p> <ol> <li>A paragraph.</li> <li>An example.</li> </ol> <p>Blocks are separated by a line with only <code>---</code>. For instance, this is a sequence of two blocks:</p> <pre><code>--- First block\n---\n--- Second block\n</code></pre> <p>Note that the following is a single block since it lacks the <code>---</code> separator:</p> <pre><code>--- First block\n\n--- Still first block\n</code></pre> <p>Alternatively, you can use block Judoc comments for that:</p> <pre><code>{-- First block\n\nSecond block\n---}\n</code></pre>"},{"location":"reference/judoc.html#paragraph","title":"Paragraph","text":"<p>A paragraph is a non-empty sequence of lines.</p> <p>For instance, the following is a paragraph with two lines:</p> <pre><code>--- First line\n--- Second line\n</code></pre> <p>Note that a rendered paragraph will have have no line breaks. If you want to have line breaks, you will need to split the paragraph. Hence, the paragraph above will be rendered as</p> <pre><code>First line Second line\n</code></pre>"},{"location":"reference/judoc.html#line","title":"Line","text":"<p>A line starts with <code>---</code> and is followed by a non-empty sequence of atoms.</p> <p>For instance, the following is a valid line:</p> <pre><code>--- A ;Pair Int Bool; contains an ;Int; and a ;Bool;\n</code></pre>"},{"location":"reference/judoc.html#atom","title":"Atom","text":"<p>An atom is either:</p> <ol> <li>A string of text (including spaces but not line breaks).</li> <li>An inline Juvix expression surrounded by <code>;</code>.</li> </ol> <p>For instance, the following are valid atoms:</p> <ol> <li><code>I am some text.</code></li> <li><code>;Pair Int Bool;</code></li> </ol>"},{"location":"reference/judoc.html#example","title":"Example","text":"<pre><code>--- &gt;&gt;&gt; someExpression ;\n</code></pre> <p>The <code>someExpression</code> can span multiple lines and it must be ended with a <code>;</code>. For instance:</p> <pre><code>--- &gt;&gt;&gt; 1\n        + 2\n        + 3;\n</code></pre>"},{"location":"reference/stdlib.html","title":"Standard library","text":"<p>The Juvix standard library contains common functions that can be used in Juvix programs.</p>"},{"location":"reference/language/index.html","title":"Index","text":"","boost":4},{"location":"reference/language/index.html#language-reference","title":"Language reference","text":"<ul> <li>Functions</li> <li>Builtins</li> <li>Data types</li> <li>Records</li> <li>Traits</li> <li>Modules</li> <li>Local definitions</li> <li>Control structures</li> <li>Comments</li> <li>Pragmas</li> <li>Axioms</li> </ul>","boost":4},{"location":"reference/language/index.html#syntax-extensions","title":"Syntax extensions","text":"<ul> <li>Aliases</li> <li>Iterators</li> <li>Fixities</li> <li>Operators</li> </ul>","boost":4},{"location":"reference/language/index.html#libraries-and-projects","title":"Libraries and projects","text":"<ul> <li>Standard library</li> <li>Example programs</li> </ul>","boost":4},{"location":"reference/language/index.html#tooling","title":"Tooling","text":"<ul> <li>Documentation tool</li> <li>Command line interface</li> <li>Doctor</li> <li>Emacs mode</li> <li>Haskell test suite</li> </ul>","boost":4},{"location":"reference/language/index.html#compiler-implementation","title":"Compiler implementation","text":"<ul> <li>Compiler pipeline</li> </ul>","boost":4},{"location":"reference/language/aliases.html","title":"Aliases in Juvix","text":"<p>Aliases in Juvix allow to create shorthand or substitute names for existing ones. This can greatly enhance readability and maintainability of the code.</p>","boost":3},{"location":"reference/language/aliases.html#syntax","title":"Syntax","text":"<p>The syntax for creating an alias is as follows:</p> <pre><code>syntax alias &lt;newName&gt; := &lt;originalName&gt;;\n</code></pre> <p>Once declared, these aliases can be used interchangeably with the original name. They can be employed in various contexts such as pattern matching, qualification, and module opening.</p>","boost":3},{"location":"reference/language/aliases.html#use-of-aliases","title":"Use of Aliases","text":"<p>One of the key features of aliases in Juvix is their ability to be forward referenced. This means you can use an alias before it has been officially declared in your code. This can be particularly useful when you want to use a more intuitive or shorter name for something that is defined later in the code.</p> <p>For instance, consider the following example where we define the alias <code>Boolean</code> for the <code>Bool</code> type. We also alias the named constructors <code>true</code> and <code>false</code> for the Boolean type as <code>\u22a4</code> (top) and <code>\u22a5</code> (bottom) respectively.</p> <pre><code><pre>syntax alias Boolean := Bool;syntax alias \u22a5 := false;syntax alias \u22a4 := true;type Bool :=  | false  | true;not : Boolean -&gt; Boolean  | \u22a5 := \u22a4  | \u22a4 := \u22a5;</pre></code></pre> <p>In addition to global scope, aliases can also be used in local definitions. The following <code>let</code> expression demonstrates this usage.</p> <pre><code><pre>not2 (b : Boolean) : Boolean :=  let    syntax alias yes := \u22a4;    syntax alias no := \u22a5;  in case b of       | no := yes       | yes := no;</pre></code></pre> <p>Just like any other name, aliases can be exported from a module to be used elsewhere. Here's how to do it:</p> <pre><code><pre>module ExportAlias;  syntax alias Binary := Bool;  syntax alias one := \u22a4;  syntax alias zero := \u22a5;end;open ExportAlias;syntax operator || logical;|| : Binary -&gt; Binary -&gt; Binary  | zero b := b  | one _ := one;</pre></code></pre> <p>The versatility of aliases extends beyond types to terms, including functions (operators). For example, the binary <code>||</code> function can be aliased as <code>or</code> as shown below:</p> <pre><code><pre>syntax alias or := ||;newor (a b c : Binary) : Binary := (a or b) or c;</pre></code></pre>","boost":3},{"location":"reference/language/axioms.html","title":"Axiom","text":"<p>Axioms or postulates are used to introduce new terms or types without defining them. This is done using the <code>axiom</code> keyword.</p> <pre><code>axiom &lt;name&gt; : &lt;type&gt;;\n</code></pre>","boost":3},{"location":"reference/language/axioms.html#usage","title":"Usage","text":"<p>Consider a scenario where you want to create a program that assumes A as a type, and there exists a term x that belongs to this type A. The syntax for such a program would be as follows:</p> <pre><code><pre>axiom A : Type;axiom x : A;</pre></code></pre>","boost":3},{"location":"reference/language/axioms.html#important-considerations","title":"Important Considerations","text":"<p>It is crucial to understand that terms introduced by the <code>axiom</code> keyword do not contain any computational content. This implies that they are merely abstract concepts without any inherent operational value.</p> <p>Consequently, programs that include axioms (which are not marked as builtins) cannot be compiled to most targets.</p>","boost":3},{"location":"reference/language/builtins.html","title":"Built-ins","text":"<p>Juvix has support for the built-in natural numbers type and a few functions that are compiled to efficient primitives.</p>","boost":3},{"location":"reference/language/builtins.html#built-in-inductive-definitions","title":"Built-in inductive definitions","text":"<pre><code><pre>builtin nattype Nat :=  | zero : Nat  | suc : Nat \u2192 Nat;</pre></code></pre>","boost":3},{"location":"reference/language/builtins.html#builtin-function-definitions","title":"Builtin function definitions","text":"<pre><code><pre>syntax operator + additive;builtin nat-plus+ : Nat \u2192 Nat \u2192 Nat  | zero b := b  | (suc a) b := suc (a + b);</pre></code></pre>","boost":3},{"location":"reference/language/builtins.html#builtin-axiom-definitions","title":"Builtin axiom definitions","text":"<pre><code><pre>builtin IOaxiom IO : Type;builtin nat-printaxiom printNat : Nat \u2192 IO;</pre></code></pre>","boost":3},{"location":"reference/language/comments.html","title":"Commenting in Juvix","text":"<p>Comments provide a way to document code for better understanding and readability. In Juvix, the comment syntax is similar to that of <code>Haskell</code>.</p>","boost":3},{"location":"reference/language/comments.html#syntax-of-comments","title":"Syntax of Comments","text":"<p>There are several types of comments you can use in Juvix. These include inline comments, region comments, Judoc inline comments, and Judoc block comments.</p>","boost":3},{"location":"reference/language/comments.html#inline-comment","title":"Inline Comment","text":"<p>Inline comments start with two hyphens (<code>--</code>). They extend to the end of the line.</p> <pre><code>-- This is an inline comment!\n</code></pre>","boost":3},{"location":"reference/language/comments.html#region-comment","title":"Region Comment","text":"<p>Region comments are multi-line comments. They start with <code>{-</code> and end with <code>-}</code>.</p> <pre><code>{-\n    This is a region comment spanning multiple lines!\n-}\n</code></pre>","boost":3},{"location":"reference/language/comments.html#judoc-inline-comments","title":"Judoc Inline Comments","text":"<p>Judoc inline comments are used specifically to document functions and types. They begin with three hyphens (<code>---</code>). For more information on using Judoc comments, refer to the Judoc documentation.</p> <pre><code>--- This is a Judoc inline comment used for documenting functions or types!\n</code></pre>","boost":3},{"location":"reference/language/comments.html#judoc-block-comments","title":"Judoc Block Comments","text":"<p>Similar to region comments, Judoc block comments span multiple lines. They start with <code>{ --</code> and end with <code>-- }</code>. For more information on using Judoc comments, refer to the Judoc documentation.</p> <pre><code>{--\n    This is a Judoc block comment used for documenting larger code blocks!\n--}\n</code></pre>","boost":3},{"location":"reference/language/control.html","title":"Control Structures","text":"<p>Juvix uses control structures such as case expressions, if expressions and lazy built-ins to manage the flow of execution.</p>","boost":3},{"location":"reference/language/control.html#case-expressions","title":"Case Expressions","text":"<p>A case expression in Juvix enables the execution of different actions based on the pattern of the input expression. It provides a way to match complex patterns and perform corresponding operations.</p> <p>A case expression in Juvix is defined as follows:</p> <pre><code>case &lt;expression&gt; of {\n  | &lt;pattern1&gt; := &lt;branch1&gt;\n  ..\n  | &lt;patternN&gt; := &lt;branchN&gt;\n}\n</code></pre> <p>The braces are optional when there is no ambiguity.</p> <p>In this syntax:</p> <ul> <li><code>&lt;expression&gt;</code> is the value against which you want to match patterns.</li> <li><code>&lt;pattern1&gt;</code> through <code>&lt;patternN&gt;</code> are the patterns you're checking the   given expression against.</li> <li><code>&lt;branch1&gt;</code> through <code>&lt;branchN&gt;</code> are the respective actions or results that   will be returned when their corresponding patterns match the input expression.</li> </ul> <p>For instance:</p> <pre><code>Stdlib.Prelude&gt; case 2 of { | zero := 0 | suc x := x }\n</code></pre> <p>In this example, the input expression is <code>2</code>. The case expression checks this input against each pattern (<code>zero</code> and <code>suc x</code>) in order. Since <code>2</code> does not match the pattern <code>zero</code>, it moves on to the next pattern <code>suc x</code>. This pattern matches the input <code>2</code> with <code>x</code> equal to <code>1</code> (<code>2</code> is just notation for <code>suc 1</code>). Therefore, the corresponding branch <code>x</code> is executed, and <code>1</code> is returned.</p> <p>Thus, when evaluated, this expression returns <code>1</code>.</p>","boost":3},{"location":"reference/language/control.html#if-expressions","title":"If Expressions","text":"<p>If expressions allow to select a branch based on boolean conditions. In Juvix, a single if expression can have multiple conditions and it is required to end with an else branch. The syntax of if expressions is:</p> <pre><code>if\n  | &lt;expression-1&gt; := &lt;branch-1&gt;\n  ..\n  | &lt;expression-n&gt; := &lt;branch-n&gt;\n  | else := &lt;branch-else&gt;\n</code></pre> <p>The boolean expressions <code>&lt;expression-1&gt;</code>, ..., <code>&lt;expression-n&gt;</code> are evaluated in order until one of them evaluates to <code>true</code>. If <code>&lt;expression-k&gt;</code> is the first one which evaluates to <code>true</code>, then <code>&lt;branch-k&gt;</code> is evaluated as the result of the <code>if</code> expression. If none of <code>&lt;expression-1&gt;</code>, ..., <code>&lt;expression-n&gt;</code> evaluate to <code>true</code>, then <code>&lt;branch-else&gt;</code> is the result.</p> <p>Here is an example of <code>if</code> expression use:</p> <pre><code><pre>cmp (x y : Nat) : Int :=  if     | x == y := 0    | x &lt; y := -1    | else := 1;</pre></code></pre>","boost":3},{"location":"reference/language/control.html#lazy-built-in-functions","title":"Lazy Built-in Functions","text":"<p>Juvix provides several lazily evaluated built-in functions in its standard library. These functions do not evaluate their arguments until absolutely necessary. They are required to be always fully applied.</p> <p>Here are some examples of these functions:</p> <ul> <li> <p><code>ite condition branch1 branch2</code>: This function first evaluates the <code>condition</code>.   If the condition is true, it returns <code>branch1</code>; otherwise, it returns   <code>branch2</code>.</p> </li> <li> <p><code>a || b</code>: This is a lazy disjunction operator. It first evaluates <code>a</code>. If <code>a</code>   is true, it returns true; otherwise, it evaluates and returns <code>b</code>.</p> </li> <li> <p><code>a &amp;&amp; b</code>: This is a lazy conjunction operator. It first evaluates <code>a</code>. If <code>a</code>   is false, it returns false; otherwise, it evaluates and returns <code>b</code>.</p> </li> <li> <p><code>a &gt;&gt;&gt; b</code>: This function sequences two IO actions and is lazy in the second   argument.</p> </li> </ul>","boost":3},{"location":"reference/language/datatypes.html","title":"Defining Data Types in Juvix","text":"<p>A crucial aspect of any programming language is the ability to define custom data types. In Juvix, these are known as inductive types. An inductive type is a type with elements constructed from a finite set of constructors.</p> <p>As a first example, consider the data type <code>Bool</code> with two constructors <code>true</code> and <code>false</code>.</p> <pre><code><pre>type Bool :=  | true : Bool  | false : Bool;</pre></code></pre>","boost":3},{"location":"reference/language/datatypes.html#syntax-of-data-type-declaration","title":"Syntax of Data Type Declaration","text":"","boost":3},{"location":"reference/language/datatypes.html#general-declaration","title":"General Declaration","text":"<p>The declaration of a data type in Juvix consists of the keyword <code>type</code>, followed by a unique name, optional type parameters, and constructors.</p> <pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n    | &lt;constructor1&gt; : &lt;type1&gt;\n    | ...\n    | &lt;constructorn&gt; : &lt;typen&gt;;\n</code></pre> <p>In this syntax:</p> <ul> <li><code>&lt;name&gt;</code> represents a unique name for the declared data type.</li> <li><code>&lt;type-parameters&gt;</code> denote optional type parameters in the form <code>A B C ...</code> or   with typing information <code>(A : Type)</code>.</li> <li><code>&lt;constructor1&gt;</code> through <code>&lt;constructorn&gt;</code> are the constructors of the data   type. Each constructor has a unique name and a type, which can be a function type with   the type of the declared data type in the target.</li> </ul> <p>While there are variations in the syntax for declaring a data type (see the ADT syntax and record syntax), the most general syntax is the one outlined above.</p> <p>Note</p> <p>A data type declaration implicitly declares a module with the same name as the data type, containing the symbols of the constructors, and the type of the data type itself. One can open this module to access these symbols or hide it to prevent access to them.</p>","boost":3},{"location":"reference/language/datatypes.html#examples-of-data-types","title":"Examples of data types","text":"<p>The <code>Unit</code> type has a single constructor named <code>unit</code>.</p> <pre><code><pre>type Unit := unit : Unit;</pre></code></pre> <p>Below is a declaration of the <code>Nat</code> type unary natural numbers. It introduces two constructors: <code>zero</code> and <code>suc</code>. For instance, <code>suc zero</code> represents one, while <code>suc (suc zero)</code> represents two.</p> <pre><code><pre>type Nat :=  | zero : Nat  | suc : Nat -&gt; Nat;</pre></code></pre> <p>These constructors can be used as regular functions or as patterns in pattern matching. Here is an example of a function adding two natural numbers:</p> <pre><code><pre>syntax operator + additive;+ : Nat -&gt; Nat -&gt; Nat  | zero b := b  | (suc a) b := suc (a + b);</pre></code></pre>","boost":3},{"location":"reference/language/datatypes.html#adt-syntax","title":"ADT syntax","text":"<p>As an alternative to the above syntax, we can use a more familiar and compact syntax for declaring data types. This syntax is similar to the ADT syntax in Haskell, OCaml or other functional languages.</p> <pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n  | &lt;constructor1&gt; &lt;arg1-1&gt; ... &lt;arg1-n&gt;\n  | ...\n  | &lt;constructorN&gt; &lt;argn-1&gt; ... &lt;argn-n&gt;;\n</code></pre> <p>Instead of specifying the type of each constructor, we only provide the types of constructor arguments.</p> <p>If a constructor as above has no arguments, then its type is the data type being declared. If the constructor has arguments, then its type is the function type from the types of the arguments to the data type being declared.</p> <p>For example, the <code>Nat</code> type can be declared as follows:</p> <pre><code><pre>type Nat :=  | Z  | S Nat;</pre></code></pre> <p>Another example is the <code>List</code> type, which is polymorphic in the type of its elements.</p> <pre><code><pre>type List A :=  | Nil  | Cons A (List A);</pre></code></pre>","boost":3},{"location":"reference/language/datatypes.html#polymorphic-data-type","title":"Polymorphic data type","text":"<p>A data type can have type parameters. When a data type has a type parameter <code>A</code>, it is referred to as polymorphic in <code>A</code>.</p> <p>A classic example of this concept is the <code>List</code> type, which is polymorphic in the type of its list elements.</p> <pre><code><pre>syntax operator :: cons;type List (A : Type) :=  | nil : List A  | :: : A -&gt; List A -&gt; List A;</pre></code></pre> <p>The following function determines whether an element is in a list or not.</p> <pre><code><pre>isElem {A} (eq : A -&gt; A -&gt; Bool) (s : A) : List A -&gt; Bool  | nil := false  | (x :: xs) := eq s x || isElem eq s xs;</pre></code></pre> <p>For more examples of inductive types and how to use them, see the Juvix standard library.</p>","boost":3},{"location":"reference/language/fixity.html","title":"Fixities","text":"<p>Fixities in Juvix refer to the precedence and associativity of operators. A fixity declaration is defined using the <code>syntax</code> keyword followed by <code>fixity</code>. It specifies how an operator should be parsed in relation to other operators.</p>","boost":3},{"location":"reference/language/fixity.html#syntax-of-fixity-declaration","title":"Syntax of Fixity Declaration","text":"<p>The syntax for a fixity declaration varies based on the operator's arity, associativity, and precedence.</p>","boost":3},{"location":"reference/language/fixity.html#arity-declaration","title":"Arity Declaration","text":"<p>For an operator with no specified precedence or associativity, the arity can be declared as follows:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt;;\n</code></pre> <p>In this syntax,</p> <ul> <li><code>&lt;name&gt;</code> represents the operator name, and</li> <li><code>&lt;arity&gt;</code> can either be <code>none</code>, <code>unary</code>, or <code>binary</code>.</li> </ul> <p>This declaration is equivalent to:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {};\n</code></pre>","boost":3},{"location":"reference/language/fixity.html#associativity-declaration","title":"Associativity Declaration","text":"<p>For an operator with no specified precedence, its associativity can be declared as:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; { assoc := &lt;associativity&gt; };\n</code></pre> <p>Here, <code>&lt;associativity&gt;</code> can either be <code>left</code>, <code>right</code>, or <code>none</code>.</p>","boost":3},{"location":"reference/language/fixity.html#precedence-declaration","title":"Precedence Declaration","text":"<p>For an operator with no specified associativity, its precedence can be declared relative to other operators.</p> <ul> <li>If it has equal precedence to another operator:</li> </ul> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; { same := otherOperatorName };\n</code></pre> <ul> <li>If it has higher precedence than other operators:</li> </ul> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {\n    above := [otherOperatorName1;...; otherOperatorNameN] };\n</code></pre> <ul> <li>If it has lower precedence than other operators:</li> </ul> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {\n    below := [otherOperatorName1;...; otherOperatorNameN] };\n</code></pre>","boost":3},{"location":"reference/language/fixity.html#associativity-and-precedence-declaration","title":"Associativity and Precedence Declaration","text":"<p>For an operator with both associativity and precedence:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {\n    assoc := &lt;associativity&gt;;\n    above := [otherOperatorName1;...; otherOperatorNameN]\n    };\n</code></pre>","boost":3},{"location":"reference/language/fixity.html#operator-alias-fixity","title":"Operator Alias Fixity","text":"<p>In Juvix, when an operator is aliased, the new alias automatically inherits the fixity of the original operator. This behavior ensures consistency and predictability when using aliases in place of their corresponding operators.</p> <p>Consider a scenario where the <code>or</code> operator is an alias of the <code>||</code> operator. The <code>or</code> operator will inherit the fixity of the <code>||</code> operator by default.</p> <pre><code><pre>syntax alias or := ||;newor (a b c : Bool) : Bool := (a or b) or c;</pre></code></pre> <p>However, if you want to override this behavior, you can declare the alias with <code>none</code> as its fixity. Make sure to import <code>Stdlib.Data.Fixity</code>.</p> <pre><code><pre>import Stdlib.Data.Fixity open;syntax operator or none;syntax alias or := ||;or3 (a b c : Bool) : Bool := or (or a b) c;</pre></code></pre>","boost":3},{"location":"reference/language/fixity.html#examples-of-fixity-declarations","title":"Examples of Fixity Declarations","text":"<p>Here are some examples of common fixity declarations for operators in Juvix's standard library.</p> <pre><code><pre>syntax fixity rapp := binary {assoc := right};syntax fixity lapp := binary {assoc := left; same := rapp};syntax fixity seq := binary {assoc := left; above := [lapp]};syntax fixity functor := binary {assoc := right};syntax fixity logical := binary {assoc := right; above := [seq]};syntax fixity comparison := binary {assoc := none; above := [logical]};syntax fixity pair := binary {assoc := right};syntax fixity cons := binary {assoc := right; above := [pair]};syntax fixity step := binary {assoc := right};syntax fixity range := binary {assoc := right; above := [step]};syntax fixity additive := binary {  assoc := left;  above := [comparison; range; cons];};syntax fixity multiplicative := binary {assoc := left; above := [additive]};syntax fixity composition := binary {assoc := right; above := [multiplicative]};</pre></code></pre>","boost":3},{"location":"reference/language/functions.html","title":"Function Declarations in Juvix","text":"<p>In Juvix, a function declaration is composed of a type signature and the body of the function. The type signature specifies the types of the arguments and the return type of the function. Constants are considered to be functions with no arguments. The body of a function can either be a single expression or a set of function clauses when pattern matching is employed.</p>","boost":3},{"location":"reference/language/functions.html#syntax-of-function-declarations","title":"Syntax of Function Declarations","text":"<p>The syntax for a function declaration has the following form:</p> <pre><code>&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt; := &lt;body&gt;;\n</code></pre> <p>Function declarations in Juvix can have variations related to named and implicit arguments.</p>","boost":3},{"location":"reference/language/functions.html#named-arguments","title":"Named Arguments","text":"<p>A named argument is an argument whose name is specified in the function type signature before the colon. This name is then available within the scope of the function's body.</p> <pre><code>&lt;funName&gt; (&lt;argName&gt; : &lt;argType&gt;) : &lt;returnType&gt; := &lt;body&gt;;\n</code></pre> <p>For example, consider the function <code>multiplyByTwo</code> which takes a <code>Nat</code> (natural number) and returns a <code>Nat</code>. The argument is named <code>n</code> and is used in the function's body to return <code>2 * n</code>.</p> <pre><code><pre>multiplyByTwo (n : Nat) : Nat := 2 * n;</pre></code></pre> <p>The argument <code>n</code> can then be provided to <code>multiplyByTwo</code> explicitly by name:</p> <pre><code><pre>four : Nat :=  multiplyByTwo@{    n := 2;  };</pre></code></pre>","boost":3},{"location":"reference/language/functions.html#default-values","title":"Default Values","text":"<p>We can assign default values to function arguments. This feature allows a function to operate without explicit argument values by using the provided defaults.</p> <p>To specify a default value for an argument, use the <code>:=</code> operator followed by the desired value. In the following example, <code>x</code> and <code>y</code> are given default values of <code>0</code> and <code>1</code>, respectively:</p> <pre><code><pre>f {x : Nat := 0} {y : Nat := 1} : Nat := x + y;</pre></code></pre> <p>When calling this function without providing values for <code>x</code> and <code>y</code>, such as <code>f</code>, the function will use the default values and return <code>1</code>.</p> <p>Note</p> <p>Here are some key points to remember about using default argument values in Juvix:</p> <ol> <li> <p>No Referencing Previous Arguments: Default values cannot refer to   previous arguments. Therefore, the following code would result in a scope   error:</p> <pre><code>f {n : Nat := 0} {m : Nat := n + 1} ....\n</code></pre> </li> <li> <p>Function-Specific Feature: Only functions can have default values. Other   constructs or types do not support this feature.</p> </li> <li> <p>Left-Hand Side Limitation: Only arguments on the left-hand side (LHS) of   the <code>:</code> can have default values. The following syntax is invalid:</p> <pre><code>f : {n : Nat := 0} := ...\n</code></pre> </li> </ol>","boost":3},{"location":"reference/language/functions.html#pattern-matching-in-function-declarations","title":"Pattern Matching in Function Declarations","text":"<p>A function may consist of one or more function clauses instead of a single expression. This is applicable when the function's argument is a data type and we want to pattern match on that argument.</p> <p>The syntax for a function declaration using pattern matching is as follows:</p> <pre><code>&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat1&gt; := &lt;body1&gt;\n    | ...\n    | &lt;patN&gt; := &lt;bodyN&gt;;\n</code></pre> <p>Here <code>&lt;pat1&gt;</code> through <code>&lt;patN&gt;</code> are patterns that are matched against the argument of the function. The corresponding body is evaluated when the pattern matches.</p> <p>For instance, consider the following function with two clauses:</p> <pre><code><pre>neg : Bool -&gt; Bool  | true := false  | false := true;</pre></code></pre> <p>When <code>neg</code> is called with <code>true</code>, the first clause is used and the function returns <code>false</code>. Similarly, when <code>neg</code> is called with <code>false</code>, the second clause is used and the function returns <code>true</code>.</p> <p>Note that one may pattern match multiple arguments at once. The syntax in for two arguments is as follows and can be extended to more arguments.</p> <pre><code>&lt;funName&gt; : &lt;argType1&gt; -&gt; &lt;argType2&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat-1-1&gt; &lt;pat-1-2&gt; := &lt;body1&gt;\n    | ...\n    | &lt;pat-n-1&gt; &lt;pat-n-2&gt; := &lt;bodyN&gt;;\n</code></pre> <p>Note</p> <p>Initial function arguments that match variables or wildcards in all clauses can be moved to the left of the colon in the function definition. For example,</p> <p><pre><code><pre>add (n : Nat) : Nat -&gt; Nat  | zero := n  | (suc m) := suc (add n m);</pre></code></pre></p> <p>is equivalent to</p> <p><pre><code><pre>add : Nat -&gt; Nat -&gt; Nat  | n zero := n  | n (suc m) := suc (add n m);</pre></code></pre></p> <p>If there is only one clause without any patterns, the pipe <code>|</code> must be omitted.</p> <p><pre><code><pre>multiplyByTwo (n : Nat) : Nat := n;</pre></code></pre></p>","boost":3},{"location":"reference/language/functions.html#mutually-recursive-functions","title":"Mutually Recursive Functions","text":"<p>Functions in Juvix can depend on each other recursively. In the following example, a function checks if a number is <code>even</code> by calling another function that verifies if the number is <code>odd</code>.</p> <pre><code><pre>isOdd : Nat -&gt; Bool  | zero := false  | (suc n) := isEven n;isEven : Nat -&gt; Bool  | zero := true  | (suc n) := isOdd n;</pre></code></pre> <p>Identifiers don't need to be defined before they are used, allowing for mutually recursive functions/types without any special syntax. However, exceptions exist. A symbol <code>f</code> cannot be forward-referenced in a statement <code>s</code> if a local module, \\import statement, or open statement exists between <code>s</code> and the definition of <code>f</code>.</p> <p>Functions with zero arguments (variable definitions) are not recursive. For example, in the following <code>let</code>, the variable <code>x</code> is not defined recursively but assigned the value of the function argument <code>x</code> increased by <code>1</code>. For example, the value of <code>g 2</code> is <code>3</code>.</p> <pre><code><pre>g (x : Nat) : Nat :=  let    x := x + 1;  in x;</pre></code></pre>","boost":3},{"location":"reference/language/functions.html#anonymous-functions-lambdas","title":"Anonymous Functions (Lambdas)","text":"<p>Anonymous functions or lambdas can be defined using the following syntax:</p>","boost":3},{"location":"reference/language/functions.html#syntax-of-lambda-declarations","title":"Syntax of <code>lambda</code> declarations","text":"<pre><code>\\{ | pat1 .. patN_1 := clause1\n   | ..\n   | pat1 .. patN_M := clauseM }\n</code></pre> <p>The initial pipe <code>|</code> is optional. You can use either <code>\\</code> or the Unicode alternative <code>\u03bb</code> to denote an anonymous function.</p> <p>An anonymous function lists all clauses of a function without naming it. Any function declaration can be converted to use anonymous functions:</p> <pre><code><pre>multiplyByTwo : Nat -&gt; Nat := \\{n := 2 * n};</pre></code></pre>","boost":3},{"location":"reference/language/iterators.html","title":"Iterators","text":"<p>Any identifier can be declared as an iterator. The syntax to define an iterator is:</p> <pre><code>syntax iterator &lt;name&gt;;\n</code></pre> <p>or</p> <pre><code>syntax iterator &lt;name&gt; {init := &lt;initVal&gt;;  range := &lt;ranges&gt;};\n</code></pre> <p>where <code>n</code> and <code>k</code> specify the number of initializers (of the form <code>acc := a</code>) and ranges (of the form <code>x in xs</code>) in iterator application. If the number of initializers or ranges is not specified, then any number is allowed in iterator application.</p> <p>An application of an iterator <code>iter</code> has the general form</p> <pre><code>iter (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}\n</code></pre> <p>where <code>acci</code>, <code>xi</code> are patterns, <code>ai</code>, <code>xsi</code> are expressions, and <code>body</code> is an expression which can refer to the variables bound by the <code>acci</code>, <code>xi</code>. The braces around <code>body</code> are optional when <code>body</code> is an atom.</p> <p>The iterator application syntax is equivalent to</p> <pre><code>iter \\{acc1 .. accn x1 .. xk := body} a1 .. an xs1 .. xsk\n</code></pre>","boost":3},{"location":"reference/language/lets.html","title":"Local Definitions","text":"<p>Local definitions in Juvix are facilitated by the <code>let</code> expression. This feature is particularly beneficial for defining identifiers that are exclusive to a single scope.</p>","boost":3},{"location":"reference/language/lets.html#syntax-of-let-expression","title":"Syntax of <code>let</code> Expression","text":"<p>The basic syntax of a <code>let</code> binding is as follows:</p> <pre><code>let &lt;name&gt; : &lt;type&gt; := &lt;term&gt;;\nin &lt;body&gt;\n</code></pre> <p>In this syntax:</p> <ul> <li><code>{name}</code> refers to the name of the variable you want to define and should be a   valid identifier of type <code>&lt;type&gt;</code>.</li> <li><code>{term}</code> is the value or computation assigned to the identifier.</li> <li><code>{body}</code> represents the section of code where this local definition is valid.</li> </ul> <p>Here's an example:</p> <pre><code><pre>value : Nat :=  let    x : Nat := 5;  in x * x;</pre></code></pre> <p>In this case, <code>x</code> is the identifier, <code>5</code> is the expression, and <code>x * x</code> is the body. The result of this code would be <code>25</code>.</p> <p>In case of simple let-bindings as above, the type may be omitted:</p> <pre><code><pre>value' : Nat :=  let    x := 5;  in x * x;</pre></code></pre> <p>In fact, Juvix allows multiple definitions in a single let-expression with the syntax of the definitions exactly the same as for top-level function definitions. For example:</p> <pre><code><pre>sum (lst : List Nat) : Nat :=  let    go (acc : Nat) : List Nat -&gt; Nat      | nil := acc      | (x :: xs) := go (acc + x) xs;  in go 0 lst;</pre></code></pre> <p>Another example with multiple definitions:</p> <pre><code><pre>isEven (n : Nat) : Bool :=  let    isEven' : Nat -&gt; Bool      | zero := true      | (suc n) := isOdd' n;    isOdd' : Nat -&gt; Bool      | zero := false      | (suc n) := isEven' n;  in isEven' n;</pre></code></pre> <p>The functions <code>isEven'</code> and <code>isOdd'</code> are not visible outside the body of <code>isEven</code>.</p>","boost":3},{"location":"reference/language/modules.html","title":"Module System","text":"<p>Modules facilitate the division of programs into separate files. In Juvix, this is achieved through top modules and local modules. Top modules are defined at the file's top, while local modules are nested within another module. Local modules also serve to organize different scopes within a file.</p>","boost":3},{"location":"reference/language/modules.html#syntax-of-module-declaration","title":"Syntax of <code>module</code> declaration","text":"<p>The syntax for defining a module is:</p> <pre><code>module &lt;name&gt;;\n  &lt;body&gt;\nend;\n</code></pre> <p>In this syntax:</p> <ul> <li> <p><code>&lt;name&gt;</code> represents the module's name.</p> </li> <li> <p><code>&lt;body&gt;</code> is a sequence of Juvix statements (declarations of data types, functions, traits,   etc.).</p> </li> <li> <p>The <code>end</code> keyword is used to close the module definition.</p> </li> </ul> <p>The <code>end</code> keyword is optional if the module definition is the last statement in the file.</p> <p>For instance, to define a module named <code>Data.List</code>, we write:</p> <pre><code>module Data.List;\n&lt;body&gt;\n</code></pre>","boost":3},{"location":"reference/language/modules.html#top-module-naming-convention","title":"Top module naming convention","text":"<p>Top modules that belong to a project must follow a naming convention. That is, if <code>dir</code> is the root of a project, then the module in <code>dir/Data/List.juvix</code> must be named <code>Data.List</code>.</p>","boost":3},{"location":"reference/language/modules.html#import-and-open-statements","title":"Import and open statements","text":"<p>In order to access the definitions from another modules we use an import statement. To import some module named <code>Data.List</code> we will write</p> <pre><code>import Data.List;\n</code></pre> <p>Now, we can access the definitions in the imported module using qualified names. E.g., <code>Data.List.sort</code>.</p> <p>It is possible to import modules and give them a more convenient name thus:</p> <pre><code>import Data.List as List;\n</code></pre>","boost":3},{"location":"reference/language/modules.html#open-statements","title":"Open statements","text":"<p>If we want to access the contents of a module without the need to qualify the names, we use an open statement. The syntax is as follows:</p> <pre><code>open Data.List;\n</code></pre> <p>Now we can simply write <code>sort</code>.</p> <p>It is important to remember that when we open a module, that module must be in scope, i.e., it must either be imported or defined as a local module.</p> <p>Since importing and opening a module is done often, there is special syntax for that. The following statement:</p> <pre><code>import Data.List open;\n</code></pre> <p>Is equivalent to this:</p> <pre><code>import Data.List;\nopen Data.List;\n</code></pre> <p>In general, we can combine any import statement and open statement that refer to the same module. The syntax is <code>&lt;import statement&gt; &lt;open statement without module name&gt;</code>.</p> <p>When opening a module, if we want to open an explicit subset of its definitions, we must use the <code>using</code> keyword thus:</p> <pre><code>open Data.List using {List; sort; reverse};\n</code></pre> <p>We can also rename symbols in an open statement thus:</p> <pre><code>open Data.List using {List; sort as listSort; reverse as reverseList};\n</code></pre> <p>If we want to open all definitions of a module minus a subset, we use the <code>hiding</code> keyword thus:</p> <pre><code>open Data.List hiding {head; tail};\n</code></pre> <p>Sometimes you might want to open or hide the type constructors of a data type. Recall that each data type defines a module containing names linked to its type constructors. For example, if you want to hide the type constructors of a data type, you must use the <code>hiding</code> keyword and module keyword as follows:</p> <pre><code>import Stdlib.Prelude open hiding {module List};\n</code></pre>","boost":3},{"location":"reference/language/modules.html#reexport-modules","title":"Reexport modules","text":"<p>All opened definitions are available under the current module, but they are not exported by default. Meaning that if another module imports the current module, it will only be able to access the definitions defined there but not those which have been opened. If we want opened definitions to be exported, we must use the <code>public</code> keyword thus:</p> <pre><code>module Prelude;\n\nimport Data.List open public;\n</code></pre> <p>Now, from another module we can access definitions in <code>Data.List</code> through the <code>Prelude</code> module.</p> <pre><code>module MyModule;\n\nimport Prelude open;\n\n-- List, sort, reverse, etc. are now in scope\n</code></pre>","boost":3},{"location":"reference/language/modules.html#local-modules","title":"Local modules","text":"<p>Juvix modules have a hierarchical structure. So far we have discussed top level modules, which have a one-to-one correspondence with files in the filesystem. On the other hand, local modules are defined within another module. They can be useful to group definitions within a file.</p> <p>The syntax for local modules is as follows:</p> <pre><code>module Path.To.TopModule;\n\nmodule ModuleName;\n  &lt;body&gt;\nend;\n</code></pre> <p>Local module names cannot contain the <code>.</code> character.</p> <p>After the definition of a local module, we can access its definitions by using qualified names. Local modules can be opened by open statements in the same way as top modules.</p> <p>Local modules inherit the scope of the parent module. Some shadowing rules apply, and they probably follow your intuition:</p> <ol> <li>Opening or defining a symbol shadows inherited instances of that symbol.</li> <li>Opening a symbol does not shadow a defined instance of that symbol in the    current module.</li> <li>Conversely, defining a symbol in the current module does not shadow an    opened instance of that symbol.</li> </ol> <p>As a consequence of 2 and 3, using a symbol that is both defined and opened locally will result in an ambiguity error. In order to solve that, the symbol that was opened would need to be used qualified instead.</p>","boost":3},{"location":"reference/language/operators.html","title":"Operator Syntax","text":"<p>The <code>syntax</code> keyword followed by <code>operator</code> declares a function to be an operators. These operators often have distinct associativity and precedence from regular functions. The operator declaration associates a term with one fixity which define its arity and potentially its precedence and associativity. The operator syntax declaration has to precede the term declaration.</p> <pre><code>syntax operator &lt;name&gt; &lt;fixity&gt;;\n</code></pre> <p>Here <code>&lt;fixity&gt;</code> is a previously declared fixity. Note that there are already many common fixities included in the standard library. See common fixities for more information.</p> <p>For instance, we can define the <code>\u00d7</code> operator as a binary operator:</p> <pre><code><pre>syntax fixity product := binary;syntax operator \u00d7 product;type \u00d7 (a : Type) (b : Type) := , : a \u2192 b \u2192 a \u00d7 b;</pre></code></pre>","boost":3},{"location":"reference/language/pragmas.html","title":"Pragmas in Juvix","text":"<p>Pragmas in Juvix are used to provide additional information to the compiler about how to handle specific identifiers or modules. They offer a way to control the compilation process and can be associated with identifiers by placing a pragma comment just before the identifier declaration. The pragmas do not have any semantic significance, i.e., removing all pragmas can affect efficiency but should have no effect on the meaning of programs.</p>","boost":3},{"location":"reference/language/pragmas.html#syntax-of-pragmas","title":"Syntax of pragmas","text":"<p>The syntax for a pragma associated to an identifier is as follows:</p> <pre><code>{-# pragma_name: pragma_value #-}\nidentifier : Type;\n</code></pre> <p>For instance, the subsequent code associates the <code>inline</code> pragma with a value of <code>true</code> to the identifier <code>f</code>.</p> <pre><code><pre>{-# inline: true #-}f : Nat -&gt; Nat  | x := x;</pre></code></pre> <p>Multiple pragmas can be linked with a single identifier, delineated by commas:</p> <pre><code><pre>{-# inline: true, unroll: 100 #-}g : Nat -&gt; Nat  | x := x;</pre></code></pre> <p>Pragmas associated with a module are inherited by all definitions within the module, unless explicitly overridden. For example,</p> <pre><code><pre>{-# inline: true #-}module M;  f : Nat -&gt; Nat := &lt;body-f&gt;;    g : Nat -&gt; Nat := &lt;body-g&gt;;  {-# inline: false #-}  h : Nat -&gt; Nat := &lt;body-h&gt;;end;</pre></code></pre> <p>In this scenario, inlining is enabled for <code>f</code>, <code>g</code> and disabled for <code>h</code>.</p> <p>Pragmas are mappings in YAML syntax, except that the outermost braces are not mandatory for the top-level mapping if it's on a single line. If the compiler encounters any unrecognized pragmas, they will be disregarded to ensure backwards compatibility. Although pragmas influence the compilation process, they don't carry any semantic significance - eliminating all pragmas should not alter the meaning of the program.</p>","boost":3},{"location":"reference/language/pragmas.html#available-pragmas","title":"Available Pragmas","text":"<p>Herein, we enumerate all currently recognized pragmas in Juvix. In the descriptions below, <code>b</code> symbolizes a boolean (<code>true</code> or <code>false</code>), and <code>n</code> symbolizes a non-negative number.</p>","boost":3},{"location":"reference/language/pragmas.html#inlining-functions","title":"Inlining Functions","text":"<ul> <li><code>inline: b</code></li> </ul> <p>This pragma specifies whether a function should be inlined. If set to <code>true</code>,   the function will invariably be inlined when fully applied. If set to <code>false</code>,   the function will never be inlined, which also disables automatic inlining.</p>","boost":3},{"location":"reference/language/pragmas.html#inlining-partial-applications","title":"Inlining Partial Applications","text":"<ul> <li><code>inline: n</code></li> </ul> <p>This variant of the <code>inline</code> pragma specifies that a partial application of   the function with at least <code>n</code> explicit arguments should always be inlined.   For example:</p> <pre><code><pre>{-# inline: 2 #-}compose {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);</pre></code></pre> <p>In the expression <code>compose f g</code>, the function <code>compose</code> will be inlined, but   in <code>compose f</code>, it won't be.</p>","boost":3},{"location":"reference/language/pragmas.html#mandatory-inlining","title":"Mandatory inlining","text":"<ul> <li><code>inline: always</code></li> </ul> <p>This pragma specifies that a function should always be inlined,   regardless of the optimization level or how many arguments it is   applied to. This pragma should be used sparingly. It is intended   mainly for (standard) library developers.</p>","boost":3},{"location":"reference/language/pragmas.html#case-value-inlining","title":"Case value inlining","text":"<ul> <li><code>inline: case</code></li> </ul> <p>This pragma specifies that a function should be inlined whenever it   is matched on. Using this pragma makes most sense with small   functions that directly return a constructor application.</p>","boost":3},{"location":"reference/language/pragmas.html#unrolling-recursion","title":"Unrolling Recursion","text":"<ul> <li><code>unroll: n</code></li> </ul> <p>This pragma sets the maximum recursion unrolling depth to <code>n</code>. It only affects   the <code>vampir</code> and <code>geb</code> backends.</p>","boost":3},{"location":"reference/language/pragmas.html#naming-function-arguments-for-generated-code","title":"Naming Function Arguments for Generated Code","text":"<ul> <li><code>argnames: [arg1, .., argn]</code></li> </ul> <p>This pragma sets the names of function arguments in the generated output to   <code>arg1</code>,..,<code>argn</code>. This is primarily useful with the <code>vampir</code> backend to name   VampIR input variables.</p>","boost":3},{"location":"reference/language/pragmas.html#formatting","title":"Formatting","text":"<ul> <li><code>format: b</code></li> </ul> <p>This pragma enables or disables formatting for the specified module. Adding   the <code>format: false</code> pragma before a module makes the formatter ignore the   module and output it verbatim.</p>","boost":3},{"location":"reference/language/pragmas.html#specializing-function-arguments","title":"Specializing Function Arguments","text":"<ul> <li><code>specialize: [arg1, .., argn]</code> or <code>specialize-args: [arg1, .., argn]</code></li> </ul> <p>This pragma specifies that the arguments <code>arg1</code>, ..., <code>argn</code> should   be specialized in each fully applied function occurrence. Only   explicit and instance arguments can be specialized. The arguments   can be specified by name or by their position in the argument list   (ignoring implicit arguments). For example, with the definition</p> <pre><code><pre>{-# specialize: [f] #-}map {A B} (f : A -&gt; B) : List A -&gt; List B  | nil := nil  | (x :: xs) := f x :: map f xs;</pre></code></pre> <p>any occurrence of <code>map g lst</code> with <code>g : T -&gt; T'</code> not a variable will   be replaced by an application <code>map_g lst</code> of a new function <code>map_g</code>   defined as:</p> <pre><code><pre>map_g : List T -&gt; List T'  | nil := nil  | (x :: xs) := g x :: map_g xs;</pre></code></pre> <p>The argument <code>f</code> can also be specified as the first non-implicit argument:</p> <pre><code>{-# specialize: [1] #-}\n</code></pre> <ul> <li><code>specialize-by: [v1,..,vn]</code></li> </ul> <p>This pragma specifies that a local function should be specialized by   the values of the variables <code>v1,..,vn</code> from the surrounding   context. This is commonly used to specialize local functions by some   arguments of the enclosing function. For example, given</p> <pre><code><pre>{-# inline: true #-}funa {A} (f : A -&gt; A) (a : A) : A :=  let    {-# specialize-by: [f] #-}    go : Nat -&gt; A      | zero := a      | (suc n) := f (go n);  in go 10;</pre></code></pre> <p>wherever the function <code>funa</code> gets inlined with a particular value <code>v</code>   for <code>f</code>, the function <code>go</code> will be specialized with that value <code>v</code>   substituted for <code>f</code>. Without the <code>specialize-by</code> pragma, after   inlining <code>f</code> the function <code>g</code> would have an additional argument <code>f</code>   -- the value <code>v</code> would be passed to <code>g</code> through this argument instead   of being \"pasted\" into the body of <code>g</code>.</p> <ul> <li><code>specialize: b</code></li> </ul> <p>When provided before a type or a value (zero-argument function)   definition, this pragma specifies whether values of the type or the   given value should always be used to specialize functions. For   example,</p> <pre><code><pre>{-# specialize: true #-}traittype Natural N :=  mkNatural@{    + : N -&gt; N -&gt; N;    * : N -&gt; N -&gt; N;    fromNat : Nat -&gt; N;  };</pre></code></pre> <p>will result in specializing any function applied to an argument of   type <code>Natural N</code> for some <code>N</code>.</p> <p>Declaring</p> <pre><code><pre>{-# specialize: true #-}instancenaturalNatI : Natural Nat := &lt;body&gt;;</pre></code></pre> <p>will result in specializing any function applied to <code>naturalNatI</code>.</p> <p>Declaring</p> <pre><code><pre>{-# specialize: false #-}naturalNatI : Natural Nat := &lt;body&gt;;</pre></code></pre> <p>will prevent specializing functions applied to <code>naturalNatI</code>, even   if the argument to which it is provided was declared for   specialization with <code>specialize</code> or <code>specialize-args</code>.</p>","boost":3},{"location":"reference/language/records.html","title":"Records","text":"<p>Records are a special kind of data type. Each data constructor within a record has named type arguments. Records are smilar to structures from languages such as C++ or Java, or to records in database systems.</p>","boost":3},{"location":"reference/language/records.html#record-declaration","title":"Record declaration","text":"<p>In the context of record types, a field is a named argument of an inductive type constructor.</p> <p>The general syntax for declaring a record type is as follows:</p> <pre><code>trait\ntype &lt;record name&gt; &lt;type parameters&gt; :=\n    | &lt;type-constructor-1&gt;@{\n        &lt;field1-1&gt; : &lt;type-1-1&gt;;\n        ...\n        &lt;field1-n&gt; : &lt;type-1-n&gt;\n        }\n    | ...\n    | &lt;type-constructor-n&gt;@{\n        &lt;fieldn-1&gt; : &lt;type-n-1&gt;;\n        ...\n        &lt;fieldn-n&gt; : &lt;type-n-n&gt;\n    };\n</code></pre> <p>In this syntax:</p> <ul> <li> <p><code>&lt;record name&gt;</code> is a unique identifier for the declared record type. This name should be unique within its scope and it is case sensitive.</p> </li> <li> <p><code>&lt;type parameters&gt;</code> are optional and represent the generic parameters that the   record type may take, see data types for more information.   They allow for greater flexibility and reusability of the record type.</p> </li> <li> <p><code>&lt;type-constructor-k&gt;</code> is the <code>k</code>th constructors of the record type. Each constructor can have a different set of fields.</p> </li> <li> <p><code>&lt;field1-1&gt;</code>, <code>&lt;field1-n&gt;</code>, <code>&lt;fieldn-1&gt;</code>, <code>&lt;fieldn-n&gt;</code> are the names of the fields in each constructor. These names should be unique within their constructor.</p> </li> <li> <p><code>&lt;type-1-n&gt;</code>, <code>&lt;type-n-1&gt;</code>, <code>&lt;type-n-n&gt;</code> represent the type of the corresponding field.</p> </li> </ul> <p>Typically, a record has exactly one constructor. The record declaration syntax, however, can be used to define arbitrary inductive types with named constructor arguments.</p>","boost":3},{"location":"reference/language/records.html#examples","title":"Examples","text":"<p>We declare the <code>newType</code> record type with the <code>mkNewtype</code> type constructor and one field <code>f</code>.</p> <pre><code><pre>type T := constructT : T;type newtype :=  mkNewtype@{    f : T;  };</pre></code></pre> <p>Consider the <code>Pair</code> record type that models pairs of values. The <code>Pair</code> type has a single <code>mkPair</code> constructor that takes two arguments <code>fst</code> and <code>snd</code> of type <code>A</code> and <code>B</code> respectively.</p> <pre><code><pre>type Pair (A B : Type) :=  mkPair@{    fst : A;    snd : B;  };</pre></code></pre> <p>Here is a declaration of a \"record\" with multiple constructors.</p> <pre><code><pre>type EnumRecord :=  | C1@{      c1a : T;      c1b : T;    }  | C2@{      c2a : T;      c2b : T;    };</pre></code></pre>","boost":3},{"location":"reference/language/records.html#record-creation","title":"Record creation","text":"<p>To create a value of type <code>Pair</code> from above, use the <code>mkPair</code> type constructor and provide values for each field.</p> <pre><code><pre>p1 : Pair T T :=  mkPair@{    fst := constructT;    snd := constructT;  };</pre></code></pre> <p>An pair of <code>EnumRecord</code>s can be created as follows.</p> <pre><code><pre>p2 : Pair EnumRecord EnumRecord :=  mkPair@{    fst :=      C1@{        c1a := constructT;        c1b := constructT;      };    snd :=      C2@{        c2a := constructT;        c2b := constructT;      };  };</pre></code></pre>","boost":3},{"location":"reference/language/records.html#record-projections","title":"Record projections","text":"<p>For single-constructor records, an implicit module named <code>&lt;record name&gt;</code> is defined with record projections, i.e., functions which allow to access the values of corresponding record fields. The record projection for field <code>f</code> in record <code>R</code> is referred to by <code>R.f</code>.</p> <p>For example, a new pair equal to <code>p1</code> defined above can be created using values retrieved with record projections.</p> <pre><code><pre>p1' : Pair T T :=  mkPair@{    fst := Pair.fst p1;    snd := Pair.snd p1;  };</pre></code></pre> <p>By default, the record projections are qualified by the record type name. To access the fields without specifying the type name, use the <code>open</code> keyword to bring record projection names into scope.</p> <pre><code><pre>open Pair;flipP : Pair T T := mkPair (snd p1) (fst p1);</pre></code></pre>","boost":3},{"location":"reference/language/records.html#record-update","title":"Record update","text":"<p>The values of record fields can be updated. For example consider a pair of natural numbers:</p> <pre><code><pre>natPair : Pair Nat Nat :=  mkPair@{    fst := 1;    snd := 2;  };</pre></code></pre> <p>We can update the value of the <code>fst</code> field from <code>1</code> to <code>2</code> as follows:</p> <pre><code><pre>updatedNatPair : Pair Nat Nat := natPair@Pair{fst := 2};</pre></code></pre>","boost":3},{"location":"reference/language/records.html#record-puns","title":"Record puns","text":"<p>When using records, one often defines variables with the same names as record fields, e.g.,</p> <pre><code><pre>p3 : Pair Nat Nat :=  let    fst := 1;    snd := 2;  in mkPair@{       fst := fst;       snd := snd;     };</pre></code></pre> <p>With record punning, the assignment to a record field of a variable with the same name can be simplified by omitting the assignment right-hand side and the assignment symbol. For example, the above definition of <code>p3</code> can be abbreviated to:</p> <pre><code><pre>p3' : Pair Nat Nat :=  let    fst := 1;    snd := 2;  in mkPair@{       fst;       snd;     };</pre></code></pre>","boost":3},{"location":"reference/language/records.html#record-patterns","title":"Record patterns","text":"<p>Record syntax can be used in pattern matching, e.g.,</p> <pre><code><pre>f : Pair Nat Nat -&gt; Nat  | mkPair@{fst := zero; snd} := snd  | mkPair@{fst} := fst;</pre></code></pre>","boost":3},{"location":"reference/language/syntax.html","title":"Module","text":"<pre><code>module &lt;name&gt;;\n  &lt;body&gt;\nend;\n</code></pre>"},{"location":"reference/language/syntax.html#alias","title":"Alias","text":"<pre><code>syntax alias &lt;newName&gt; := &lt;originalName&gt;;\n</code></pre>"},{"location":"reference/language/syntax.html#fixity","title":"Fixity","text":"<pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt;;\n</code></pre>"},{"location":"reference/language/syntax.html#axiom","title":"Axiom","text":"<pre><code>axiom &lt;name&gt; : &lt;type&gt;;\n</code></pre>"},{"location":"reference/language/syntax.html#function","title":"Function","text":"<pre><code>&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt; := &lt;body&gt;;\n</code></pre> <pre><code>&lt;funName&gt; (&lt;argName&gt; : &lt;argType&gt;) : &lt;returnType&gt; := &lt;body&gt;;\n</code></pre> <pre><code>&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat1&gt; := &lt;body1&gt;\n    | ...\n    | &lt;patN&gt; := &lt;bodyN&gt;;\n</code></pre> <p>It may have multiple patterns:</p> <pre><code>&lt;funName&gt; : &lt;argType1&gt; -&gt; &lt;argType2&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat-1-1&gt; &lt;pat-1-2&gt; := &lt;body1&gt;\n    | ...\n    | &lt;pat-n-1&gt; &lt;pat-n-2&gt; := &lt;bodyN&gt;;\n</code></pre> <p>Lambdas</p> <pre><code>\\{ | pat1 .. patN_1 := clause1\n   | ..\n   | pat1 .. patN_M := clauseM }\n</code></pre>"},{"location":"reference/language/syntax.html#data-types","title":"Data Types","text":"<pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n    | &lt;constructor1&gt; : &lt;type1&gt;\n    | ...\n    | &lt;constructorn&gt; : &lt;typen&gt;;\n</code></pre>"},{"location":"reference/language/syntax.html#traits-and-records","title":"Traits and Records","text":"<pre><code>[trait]\ntype &lt;record name&gt; &lt;type parameters&gt; :=\n    | &lt;type-constructor-1&gt;@{\n        &lt;field1-1&gt; : &lt;type-1-1&gt;;\n        ...\n        &lt;field1-n&gt; : &lt;type-1-n&gt;\n        }\n    | ...\n    | &lt;type-constructor-n&gt;@{\n        &lt;fieldn-1&gt; : &lt;type-n-1&gt;;\n        ...\n        &lt;fieldn-n&gt; : &lt;type-n-n&gt;\n    };\n</code></pre> <p>Instances:</p> <pre><code>instance\n&lt;term&gt; : &lt;trait&gt; := &lt;trait constructor&gt;@{\n    field1 := &lt;term1&gt;;\n    ...\n    fieldn := &lt;termn&gt;;\n};\n</code></pre>"},{"location":"reference/language/syntax.html#let","title":"Let","text":"<pre><code>let &lt;name&gt; : &lt;type&gt; := &lt;term&gt;;\nin &lt;body&gt;\n</code></pre>"},{"location":"reference/language/syntax.html#iterator","title":"Iterator","text":"<pre><code>syntax iterator &lt;name&gt;;\n</code></pre> <pre><code>syntax iterator &lt;name&gt; {init := &lt;initVal&gt;;  range := &lt;ranges&gt;};\n</code></pre> <pre><code>iter (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}\n</code></pre>"},{"location":"reference/language/syntax.html#pragmas","title":"Pragmas","text":"<pre><code>{-# pragma_name: pragma_value #-}\nidentifier : Type;\n</code></pre>"},{"location":"reference/language/syntax.html#control","title":"Control","text":""},{"location":"reference/language/syntax.html#case","title":"Case","text":"<pre><code>case &lt;expression&gt; of {\n  | &lt;pattern1&gt; := &lt;branch1&gt;\n  ..\n  | &lt;patternN&gt; := &lt;branchN&gt;\n}\n</code></pre>"},{"location":"reference/language/syntax.html#if","title":"If","text":"<pre><code>if\n  | &lt;expression-1&gt; := &lt;branch-1&gt;\n  ..\n  | &lt;expression-n&gt; := &lt;branch-n&gt;\n  | else := &lt;branch-else&gt;\n</code></pre>"},{"location":"reference/language/traits.html","title":"Traits","text":"<p>A trait is a special type of record that can be used to define a set of functions that must be implemented for a given type.</p>","boost":3},{"location":"reference/language/traits.html#trait-declarations","title":"Trait declarations","text":"<p>Traits are declared using the <code>trait</code> keyword, followed by a record type declaration.</p> <pre><code>trait\ntype &lt;record name&gt; &lt;type parameters&gt; :=\n    | &lt;type-constructor-1&gt;@{\n        &lt;field1-1&gt; : &lt;type-1-1&gt;;\n        ...\n        &lt;field1-n&gt; : &lt;type-1-n&gt;\n        }\n    | ...\n    | &lt;type-constructor-n&gt;@{\n        &lt;fieldn-1&gt; : &lt;type-n-1&gt;;\n        ...\n        &lt;fieldn-n&gt; : &lt;type-n-n&gt;\n    };\n</code></pre> <p>For example, the following defines a trait <code>Show</code>. Any type <code>A</code> that implements <code>Show</code> must provide a function <code>show</code> that takes an <code>A</code> and returns a <code>String</code>.</p> <pre><code><pre>traittype Show A :=  mkShow@{    show : A -&gt; String;  };</pre></code></pre>","boost":3},{"location":"reference/language/traits.html#instance-declarations","title":"Instance declarations","text":"<p>An instance of a trait is a value of the corresponding record type, which must implement all methods stipulated by the trait.</p> <p>To indicate that a given global definition declares an instance of a trait, we use the <code>instance</code> keyword. To create the instance record, we use the trait constructor of the corresponding record type.</p> <pre><code>instance\n&lt;term&gt; : &lt;trait&gt; := &lt;trait constructor&gt;@{\n    field1 := &lt;term1&gt;;\n    ...\n    fieldn := &lt;termn&gt;;\n};\n</code></pre> <p>For example, we could define three instances of <code>Show</code> for <code>String</code>, <code>Bool</code>, and <code>Nat</code> as follows:</p> <pre><code><pre>instanceshowStringI : Show String :=  mkShow@{    show := id;  };instanceshowBoolI : Show Bool :=  mkShow@{    show (x : Bool) : String :=      if         | x := \"true\"        | else := \"false\";  };instanceshowNatI : Show Nat :=  mkShow@{    show := natToString;  };</pre></code></pre>","boost":3},{"location":"reference/language/traits.html#instance-arguments","title":"Instance arguments","text":"<p>The following a bit more involved example defines an instance of <code>Show</code> for the type of lists:</p> <pre><code><pre>showList {A} {{Show A}} : List A -&gt; String  | nil := \"nil\"  | (h :: t) := Show.show h ++str \" :: \" ++str showList t;instanceshowListI {A} {{Show A}} : Show (List A) :=  mkShow@{    show := showList;  };</pre></code></pre> <p>The second argument of <code>showList</code> of type <code>Show A</code> is an instance argument, which is indicated by enclosing the argument type in double braces. When calling a function, the instance arguments are typically not provided explicity but inferred with instance resolution.</p> <p>The above instance definition could be written more compactly:</p> <pre><code>instance\nshowListI {A} {{Show A}} : Show (List A) :=\n   mkShow@{\n     show : List A -&gt; String\n       | nil := \"nil\"\n       | (h :: t) := Show.show h ++str \" :: \" ++str show t;\n   };\n</code></pre> <p>In the body of <code>show</code>, the qualified <code>Show.show</code> refers to the trait projection, i.e., the record projection associated with the trait <code>Show</code>, while unqualified <code>show</code> refers to the function being defined recursively. One uses trait projections to automatically infer appropriate instance arguments.</p> <p>In contrast to record projections for non-trait types, the first non-parameter argument of a trait projection is an instance argument and not ordinary explicit argument. For example, the type signature of <code>Show.show</code> is:</p> <pre><code>Show.show {A} : {{Show A}} -&gt; List A -&gt; String\n</code></pre>","boost":3},{"location":"reference/language/traits.html#instance-resolution","title":"Instance resolution","text":"<p>Instance resolution is the search for a declared instance matching a given trait type. The search includes all locally accessible instance variables and all instances declared with the <code>instance</code> keyword. If there is no matching instance or there is an ambiguity (more than one instance matches), then instance resolution fails.</p> <p>For example, in</p> <pre><code><pre>showNatList (lst : List Nat) : String := Show.show lst;</pre></code></pre> <p>the implicitly inferred instance value of type <code>Show (List Nat)</code> for <code>Show.show lst</code> is <code>showListI {{showNatI}}</code>. In the first instance resolution step, we see that <code>Show (List Nat)</code> matches the type <code>Show (List A)</code> of the instance <code>showListI</code>. The type parameter <code>A</code> is treated as a variable that can match any type, <code>Nat</code> in particular. Since <code>showListI</code> has an instance argument of type <code>Show A</code>, a matching instance must be inferred for <code>Show Nat</code> in the second step. We see that <code>showNatI</code> of type <code>Show Nat</code> is a matching instance. Since in both steps there was no ambiguity (only one instance matched), instance resolution succeeds.</p> <p>To prevent looping during instance search, we need to ensure that the trait parameters in instance types are structurally decreasing. Therefore, the following instance is rejected:</p> <pre><code>type Box A := box A;\n\ntrait\ntype T A := mkT@{pp : A -&gt; A};\n\ninstance\nboxT {A} {{T (Box A)}} : T (Box A) := mkT (\\{x := x});\n</code></pre> <p>We check whether each parameter is a strict subterm of some trait parameter in the target. This ordering is included in the finite multiset extension of the subterm ordering, hence terminating.</p>","boost":3},{"location":"reference/language/traits.html#matching-on-implicit-instances","title":"Matching on implicit instances","text":"<p>It is possible to manually provide an instance and to match on implicit instances, as shown below:</p> <pre><code><pre>f {A} {{Show A}} (x : A) : String := Show.show x;f' {A} : {{Show A}} -&gt; A -&gt; String  | {{mkShow s}} x := s x;f'' {A} : {{Show A}} -&gt; A -&gt; String  | {{M}} x := Show.show {{M}} x;</pre></code></pre>","boost":3},{"location":"reference/language/traits.html#example","title":"Example","text":"<p>Using the <code>Show</code> trait and the function <code>printStringLn</code> and <code>IO</code> from the standard library, we could use the instances of <code>Show</code> as follows:</p> <pre><code><pre>main : IO :=  printStringLn (Show.show true)    &gt;&gt;&gt; printStringLn (f false)    &gt;&gt;&gt; printStringLn (Show.show 3)    &gt;&gt;&gt; printStringLn (Show.show [true; false])    &gt;&gt;&gt; printStringLn (Show.show [1; 2; 3])    &gt;&gt;&gt; printStringLn (f' [1; 2])    &gt;&gt;&gt; printStringLn (f'' [true; false])    &gt;&gt;&gt; printStringLn (Show.show [\"a\"; \"b\"; \"c\"; \"d\"]);</pre></code></pre>","boost":3},{"location":"reference/language/traits.html#instance-coercions","title":"Instance coercions","text":"<p>A coercion from trait <code>T</code> to <code>T'</code> can be declared with the syntax <pre><code>coercion instance\ncoeName {A} {{T A}} : T' A := ...\n</code></pre> Coercions can be seen as instances with special resolution rules.</p>","boost":3},{"location":"reference/language/traits.html#coercion-resolution-rules","title":"Coercion resolution rules","text":"<ul> <li>If a non-coercion instance can be applied in a single instance resolution step, no coercions are considered. No ambiguity results if there exists some coercion which could be applied, but a non-coercion instance exists - the non-coercion instances have priority.</li> <li>If no non-coercion instance can be applied in a single resolution step, all minimal coercion paths which lead to an applicable non-coercion instance are considered. If there is more than one, ambiguity is reported.</li> </ul>","boost":3},{"location":"reference/language/traits.html#examples","title":"Examples","text":"<p>The following type-checks because:</p> <ol> <li>There is no non-coercion instance found for <code>U String</code>.</li> <li>There are two minimal coercion paths <code>U</code> &lt;- <code>U1</code> and <code>U</code> &lt;- <code>U2</code>, but only one of them (<code>U</code> &lt;- <code>U2</code>) ends in an applicable non-coercion instance (<code>instU2</code> for <code>U2 String</code>).</li> </ol> <pre><code><pre>traittype U A :=  mkU@{    pp : A -&gt; A;  };traittype U1 A :=  mkU1@{    pp : A -&gt; A;  };traittype U2 A :=  mkU2@{    pp : A -&gt; A;  };coercion instancefromU1toU {A} {{U1 A}} : U A :=  mkU@{    pp := U1.pp;  };coercion instancefromU2toU {A} {{U2 A}} : U A :=  mkU@{    pp := U2.pp;  };instanceinstU2 : U2 String := mkU2 id;printMain : IO := printStringLn (U.pp \"X\");</pre></code></pre> <p>The following results in an ambiguity error because:</p> <ol> <li>There is no non-coercion instance found for <code>T Unit</code>.</li> <li>There are two minimal coercion paths <code>T</code> &lt;- <code>T1</code> and <code>T</code> &lt;- <code>T2</code>, both of which end in applicable non-coercion instances.</li> </ol> <pre><code>trait\ntype T A := mkT { pp : A \u2192 A };\n\ntrait\ntype T1 A := mkT1 { pp : A \u2192 A };\n\ntrait\ntype T2 A := mkT2 { pp : A \u2192 A };\n\ninstance\nunitT1 : T1 Unit := mkT1 (pp := \u03bb{_ := unit});\n\ninstance\nunitT2 : T2 Unit := mkT2 (pp := \u03bb{_ := unit});\n\ncoercion instance\nfromT1toT {A} {{T1 A}} : T A := mkT@{\n  pp := T1.pp\n};\n\ncoercion instance\nfromT2toT {A} {{T2 A}} : T A := mkT@{\n  pp := T2.pp\n};\n\nmyUnit : Unit := T.pp unit;\n</code></pre> <p>The following type-checks, because there exists a non-coercion instance for <code>T2 String</code>, so the coercion <code>fromT1toT2</code> is ignored during instance resolution.</p> <pre><code><pre>traittype T1 A :=  mkT1@{    pp : A -&gt; A;  };traittype T2 A :=  mkT2@{    pp : A -&gt; A;  };instanceinstT1 {A} : T1 A :=  mkT1@{    pp := id;  };coercion instancefromT1toT2 {A} {{M : T1 A}} : T2 A :=  mkT2@{    pp := T1.pp {{M}};  };instanceinstT2 : T2 String :=  mkT2@{    pp (s : String) : String := s ++str \"!\";  };myString : String := T2.pp \"a\";</pre></code></pre>","boost":3},{"location":"reference/tooling/CLI.html","title":"CLI","text":""},{"location":"reference/tooling/CLI.html#usage","title":"Usage","text":"<pre><code>juvix [Global options] ((-v|--version) | (-h|--help) | COMPILER_CMD | UTILITY_CMD)\n</code></pre>"},{"location":"reference/tooling/CLI.html#informative-options","title":"Informative options","text":"<ul> <li><code>-v,--version</code> Print the version and exit</li> <li><code>--numeric-version</code> Show only the version number</li> <li><code>-h,--help</code> Show this help text</li> </ul>"},{"location":"reference/tooling/CLI.html#global-command-flags","title":"Global Command flags","text":"<ul> <li><code>--no-colors</code> Disable globally ANSI formatting</li> <li><code>--vscode</code> Enable VSCode compatible output</li> <li><code>--show-name-ids</code> Show the unique number of each identifier when   pretty printing</li> <li><code>--no-termination</code> Disable termination checking</li> <li><code>--no-positivity</code> Disable positivity checking for inductive types</li> <li><code>--no-coverage</code> Disable coverage checking for patterns</li> <li><code>--no-stdlib</code> Do not use the standard library</li> <li><code>--internal-build-dir BUILD_DIR</code> Directory for compiler internal output</li> <li><code>--stdin</code> Read from Stdin</li> <li><code>--offline</code> Disable access to network resources</li> <li><code>--log-level LOG_LEVEL</code>  Determines how much log the compiler produces.error &lt; warn &lt; info &lt; progress &lt; verbose &lt; debug</li> <li><code>--dev-show-thread-ids</code> [DEV] Show the thread id when compiling a module</li> <li><code>-N,--threads THREADS</code> Number of physical threads to run (default: auto)</li> </ul>"},{"location":"reference/tooling/CLI.html#main-commands","title":"Main Commands","text":"<ul> <li><code>html</code> Generate HTML output from a Juvix file</li> <li><code>typecheck</code> Typecheck a Juvix file</li> <li><code>compile</code> Compile a Juvix file</li> <li><code>eval</code> Evaluate a Juvix file</li> </ul>"},{"location":"reference/tooling/CLI.html#utility-commands","title":"Utility Commands","text":"<ul> <li><code>doctor</code> Perform checks on your Juvix development environment</li> <li><code>init</code> Interactively initialize a Juvix project in the current   directory</li> <li><code>repl</code> Run the Juvix REPL</li> <li><code>format</code> Format a Juvix file or Juvix project</li> <li><code>clean</code> Delete build artifacts</li> </ul>"},{"location":"reference/tooling/CLI.html#dev-commands","title":"Dev Commands","text":"<pre><code>juvix dev COMMAND\n</code></pre> <ul> <li><code>compile</code> Compile a Juvix file to an internal language</li> <li><code>parse</code> Parse a Juvix file</li> <li><code>scope</code> Parse and scope a Juvix file</li> <li><code>highlight</code> Highlight a Juvix file</li> <li><code>core</code> Subcommands related to JuvixCore</li> <li><code>asm</code> Subcommands related to JuvixAsm</li> <li><code>root</code> Show the root path for a Juvix project</li> <li><code>termination</code> Subcommands related to termination checking</li> <li><code>internal</code> Subcommands related to Internal</li> <li><code>casm</code> Subcommands related to Cairo Assembly</li> <li><code>anoma</code> Subcommands related to Anoma</li> <li><code>nockma</code> Subcommands related to Nockma</li> <li><code>runtime</code> Subcommands related to the Juvix runtime</li> <li><code>repl</code> Run the Juvix dev REPL</li> </ul>"},{"location":"reference/tooling/CLI.html#cli-auto-completion-scripts","title":"CLI Auto-completion Scripts","text":"<p>The Juvix CLI can generate auto-completion scripts. Follow the instructions below for your shell.</p> <p>Note</p> <p>NB: You may need to restart your shell after installing the completion script.</p>"},{"location":"reference/tooling/CLI.html#bash","title":"Bash","text":"<p>Add the following line to your bash init script (for example <code>~/.bashrc</code>).</p> <pre><code>eval \"$(juvix --bash-completion-script juvix)\"\n</code></pre>"},{"location":"reference/tooling/CLI.html#fish","title":"Fish","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --fish-completion-script juvix\n  &gt; ~/.config/fish/completions/juvix.fish\n</code></pre>"},{"location":"reference/tooling/CLI.html#zsh","title":"ZSH","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --zsh-completion-script juvix &gt; $DIR_IN_FPATH/_juvix\n</code></pre> <p>where <code>$DIR_IN_FPATH</code> is a directory that is present on the ZSH FPATH variable (which you can inspect by running <code>echo $FPATH</code> in the shell).</p>"},{"location":"reference/tooling/doctor.html","title":"Doctor","text":""},{"location":"reference/tooling/doctor.html#juvix-doctor","title":"Juvix Doctor","text":"<p>The <code>juvix doctor</code> command can help you to troubleshoot problems with your development environment. For each problem the doctor finds they'll be a link to a section on this page to help you fix it.</p>"},{"location":"reference/tooling/doctor.html#could-not-find-the-clang-command","title":"Could not find the clang command","text":"<p>The Juvix compiler uses the Clang compiler version 13 or later to generate binaries. You need to have Clang available on your system <code>$PATH</code>.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor.html#macos","title":"MacOS","text":"<p>Use Homebrew:</p> <pre><code>brew install llvm\n</code></pre>"},{"location":"reference/tooling/doctor.html#debian-ubuntu-linux","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install clang lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor.html#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S llvm lld\n</code></pre>"},{"location":"reference/tooling/doctor.html#could-not-find-the-wasm-ld-command","title":"Could not find the wasm-ld command","text":"<p>The Juvix compiler requires <code>wasm-ld</code> (the Wasm linker) to produce WebAssembly binaries. If you don't want to compile to WebAssembly, you can ignore this message.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor.html#macos_1","title":"MacOS","text":"<pre><code>brew install lld\n</code></pre>"},{"location":"reference/tooling/doctor.html#debian-ubuntu-linux_1","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor.html#arch-linux_1","title":"Arch Linux","text":"<pre><code>sudo pacman -S lld\n</code></pre>"},{"location":"reference/tooling/doctor.html#newer-clang-version-required","title":"Newer Clang version required","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor.html#clang-does-not-support-the-wasm32-target","title":"Clang does not support the wasm32 target","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor.html#clang-does-not-support-the-wasm32-wasi-target","title":"Clang does not support the wasm32-wasi target","text":"<p>Juvix optionally uses WASI - The Wasm System Interface to produce binaries that can be executed using a Wasm runtime. The files necessary to setup Clang with <code>wasm32-wasi</code> support are available at wasi-sdk.</p> <p>You can ignore this message if you don't want to compile to WebAssembly.</p> <p>To install the <code>wasm32-wasi</code> target for Clang you need to do two things:</p>"},{"location":"reference/tooling/doctor.html#install-libclang_rtbuiltins-wasm32a-into-your-clang-distribution","title":"Install <code>libclang_rt.builtins-wasm32.a</code> into your Clang distribution","text":"<ol> <li> <p>Obtain <code>libclang_rt.builtins-wasm32-wasi-16.0.tar.gz</code> from the     wasi-sdk     releases page.</p> </li> <li> <p>Untar the file and place the file     <code>lib/wasi/libclang_rt.builtins-wasm32.a</code> into your Clang     distribution directory.</p> <p>On MacOS, if you installed llvm using homebrew you can find the Clang distribution directory using <code>brew --prefix llvm</code>. You should then place the builtins file at <code>`brew --prefix llvm`/lib/wasi/libclang_rt.builtins-wasm32.a</code>.</p> <p>On Linux the Clang distribution directory will be something like <code>/usr/lib/clang/13.0.1</code> where <code>13.0.1</code> is the version of Clang that you have installed. You should then place the builtins file at <code>/usr/lib/clang/13.0.1/lib/wasi/libclang_rt.builtins-wasm32</code>.</p> </li> </ol>"},{"location":"reference/tooling/doctor.html#download-the-wasi-sysroot-and-set-wasi_sysroot_path","title":"Download the WASI sysroot and set <code>WASI_SYSROOT_PATH</code>","text":"<ol> <li>Obtain <code>wasi-sysroot-16.0.tar.gz</code> from the wasi-sdk     releases page.</li> <li>Untar the file and set the environment variable <code>WASI_SYSROOT_PATH</code>     to that location.</li> </ol>"},{"location":"reference/tooling/doctor.html#environment-variable-wasi_sysroot_path-is-not-set","title":"Environment variable <code>WASI_SYSROOT_PATH</code> is not set","text":"<p>Set the <code>WASI_SYSROOT_PATH</code> to the directory where you installed the <code>wasi-sdk</code> sysroot files. See installing the WASI sysroot.</p> <p>You can ignore this message if you don't want to compile to WebAssembly.</p>"},{"location":"reference/tooling/doctor.html#could-not-find-the-wasmer-command","title":"Could not find the wasmer command","text":"<p>The Juvix test suite uses Wasmer as a Wasm runtime to execute compiled Wasm binaries. See the Wasmer documentation to see how to install it.</p> <p>You can ignore this message if you don't want to compile to WebAssembly.</p>"},{"location":"reference/tooling/emacs.html","title":"Emacs mode","text":""},{"location":"reference/tooling/emacs.html#emacs-mode","title":"Emacs Mode","text":"<p>There is an Emacs mode available for Juvix. Currently, it supports syntax highlighting for well-scoped modules.</p> <p>To get started, clone the Juvix Emacs mode repository:</p> <pre><code>git clone https://github.com/anoma/juvix-mode.git\n</code></pre> <p>To install it add the following lines to your Emacs configuration file:</p> <pre><code>(push \"/path/to/juvix-mode/\" load-path)\n(require 'juvix-mode)\n</code></pre> <p>Make sure that Juvix is installed in your <code>PATH</code>.</p> <p>The Juvix major mode will be activated automatically for <code>.juvix</code> files.</p>"},{"location":"reference/tooling/emacs.html#keybindings","title":"Keybindings","text":"Key Function Name Description <code>C-c C-l</code> <code>juvix-load</code> Runs the scoper and adds semantic syntax highlighting <code>M-.</code> <code>juvix-goto-definition</code> Go to the definition of symbol at point <code>C-c C-f</code> <code>juvix-format-buffer</code> Format the current buffer"},{"location":"reference/tooling/emacs.html#emacs-installation","title":"Emacs installation","text":"<p>Most Linux distributions contain an Emacs package which can be installed with your package manager (<code>sudo apt install emacs</code> on Ubuntu). On macOS, it is recommended to install Emacs Plus via Homebrew: <code>brew install emacs-plus</code>. Using the Emacs Homebrew casks is not recommended.</p>"},{"location":"reference/tooling/emacs.html#common-problems","title":"Common problems","text":"<ul> <li>Error \"Symbol's value as variable is void: sh:1:\"</li> </ul> <p>Make sure the juvix executable is on the Emacs' <code>exec-path</code>. Note   that <code>exec-path</code> may be different from your shell's <code>PATH</code>. This is   particularly common on macOS with Emacs launched from GUI instead of   the terminal.</p> <p>The easiest way to resolve this issue is to install the   exec-path-from-shell   package (available on MELPA). Alternatively, one may set <code>exec-path</code>   to match shell <code>PATH</code> by following the instructions from   EmacsWiki.</p>"},{"location":"reference/tooling/testing.html","title":"Testing","text":""},{"location":"reference/tooling/testing.html#dependencies","title":"Dependencies","text":"<p>See Installing dependencies for instructions on how to set up the testing environment for the WASM compiler tests.</p>"},{"location":"reference/tooling/testing.html#running","title":"Running","text":"<p>Run tests using:</p> <pre><code>make test\n</code></pre> <p>Or using <code>Stack</code>:</p> <pre><code>stack test\n</code></pre> <p>To run only quick tests, ignoring all slow tests:</p> <pre><code>stack test --ta '-p \"! /slow tests/\"'\n</code></pre>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<ul> <li>Essential Juvix</li> <li>Functional programming with Juvix</li> <li>Juvix VSCode extension</li> <li>Juvix Emacs mode</li> </ul>","boost":4},{"location":"tutorials/emacs.html","title":"Juvix Emacs mode tutorial","text":"<p>First, follow the instructions in the Emacs Mode Reference to install the Juvix Emacs mode. Once you've successfully set it up, create a file <code>Hello.juvix</code> with the following content.</p> <pre><code><pre>module Hello;  import Stdlib.Prelude open;    main : String := \"Hello world!\";end;</pre></code></pre> <p>The name of the top module must coincide with the file name.</p> <p>Type Ctrl+C+Ctrl+L to run the scoper and highlight the syntax.</p> <p>If you make a mistake in your program, it is automatically underlined in red with the error message popping up when you hover the mouse pointer over the underlined part.</p> <p>For example, in the following program the identifier <code>printStringLna</code> should be underlined with the error message \"Symbol not in scope\".</p> <pre><code>module Hello-Print;\n  import Stdlib.Prelude open;\n\n  main : IO := printStringLna \"Hello world!\";\nend;\n</code></pre> <p>If error underlining doesn't work, make sure you have the <code>flycheck</code> mode turned on. It should be turned on automatically when loading <code>juvix-mode</code>, but in case this doesn't work you can enable it with <code>M-x flycheck-mode</code>.</p> <p>Let's extend our program with another definition in the file <code>Hello-Print.juvix</code>.</p> <pre><code><pre>module Hello-Print;  import Stdlib.Prelude open;    main : IO := printStringLn \"Hello world!\";end;</pre></code></pre> <p>Place the cursor on the <code>print</code> call in the function clause of <code>main</code> and press <code>M-.</code>. The cursor will jump to the definition of <code>print</code> above. This also works across files and for definitions from the standard library. You can try using <code>M-.</code> to jump to the definition of <code>printStringLn</code>.</p> <p>One more feature of the Juvix Emacs mode is code formatting. To format the content of the current buffer, type Ctrl+C+Ctrl+F.</p>"},{"location":"tutorials/essential.html","title":"Essential Juvix","text":"<p>Welcome to the essential Juvix tutorial! This brief guide will introduce you to basic Juvix language features and allow you to quickly get up to speed with programming in Juvix. After working through this tutorial, you should be able to write simple Juvix programs and have a basic understanding of common patterns and language concepts. Let's get started on your Juvix journey!</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#juvix-repl","title":"Juvix REPL","text":"<p>After installing Juvix, launch the Juvix REPL:</p> <pre><code>juvix repl\n</code></pre> <p>The response should be similar to:</p> <pre><code>Juvix REPL version 0.6.8: https://juvix.org. Run :help for help\nOK loaded: ./.juvix-build/stdlib/Stdlib/Prelude.juvix\nStdlib.Prelude&gt;\n</code></pre> <p>Currently, the REPL supports evaluating expressions but it does not yet support adding new definitions. To see the list of available REPL commands type <code>:help</code>.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#basic-expressions","title":"Basic expressions","text":"<p>You can try evaluating simple arithmetic expressions in the REPL:</p> <pre><code>Stdlib.Prelude&gt; 3 + 4\n7\nStdlib.Prelude&gt; 1 + 3 * 7\n22\nStdlib.Prelude&gt; div 35 4\n8\nStdlib.Prelude&gt; mod 35 4\n3\nStdlib.Prelude&gt; sub 35 4\n31\nStdlib.Prelude&gt; sub 4 35\n0\n</code></pre> <p>By default, Juvix operates on non-negative natural numbers. Natural number subtraction is implemented by the function <code>sub</code>. Subtracting a bigger natural number from a smaller one yields <code>0</code>.</p> <p>You can also try boolean expressions</p> <pre><code>Stdlib.Prelude&gt; true\ntrue\nStdlib.Prelude&gt; not true\nfalse\nStdlib.Prelude&gt; true &amp;&amp; false\nfalse\nStdlib.Prelude&gt; true || false\ntrue\nStdlib.Prelude&gt; if | true := 1 | else := 0\n1\n</code></pre> <p>and strings, pairs and lists:</p> <pre><code>Stdlib.Prelude&gt; \"Hello world!\"\n\"Hello world!\"\nStdlib.Prelude&gt; (1, 2)\n1, 2\nStdlib.Prelude&gt; [1; 2; 3]\n1 :: 2 :: 3 :: nil\n</code></pre> <p>The parentheses around pairs, as in <code>(1, 2)</code>, are in fact optional when no ambiguity arises. The notation <code>[a; b; c]</code> is an abbreviation for <code>a :: b :: c :: nil</code>, where <code>::</code> is a list \"cons\" operator and <code>nil</code> (also <code>[]</code>) denotes the empty list.</p> <p>In fact, you can use all functions and types from the Stdlib.Prelude module of the standard library, which is preloaded by default.</p> <pre><code>Stdlib.Prelude&gt; length [1; 2]\n2\nStdlib.Prelude&gt; isEmpty [1; 2]\nfalse\nStdlib.Prelude&gt; swap (1, 2)\n2, 1\n</code></pre> <p>To see the type of an expression, use the <code>:type</code> REPL command:</p> <pre><code>Stdlib.Prelude&gt; :type 1\nNat\nStdlib.Prelude&gt; :type -1\nInt\nStdlib.Prelude&gt; :type true\nBool\nStdlib.Prelude&gt; :type [1; 2; 3]\nList Nat\nStdlib.Prelude&gt; :type (1, \"A\")\nPair Nat String\n</code></pre> <p>The type <code>List Nat</code> is the type of lists whose elements have type <code>Nat</code>. The type <code>Pair Nat String</code> is the type of pairs whose first component has type <code>Nat</code> and second component has type <code>String</code>.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#files-modules-and-compilation","title":"Files, modules and compilation","text":"<p>Currently, the REPL does not support adding new definitions. To define new functions or data types, you need to put them in a separate file and either load the file in the REPL with <code>:load file.juvix</code>, evaluate it with the shell command <code>juvix eval file.juvix</code>, or compile it to a binary executable with <code>juvix compile native file.juvix</code>. To only type-check a file without evaluating it, use <code>juvix typecheck file.juvix</code>.</p> <p>To conveniently edit Juvix files, an Emacs mode and a VSCode extension are available.</p> <p>A Juvix file must declare a module whose name corresponds exactly to the name of the file. For example, a file <code>Hello.juvix</code> must declare a module <code>Hello</code>:</p> <pre><code><pre>module Hello;  import Stdlib.Prelude open;    main : String := \"Hello world!\";end;</pre></code></pre> <p>A file compiled to an executable must define the zero-argument function <code>main</code> which is evaluated when running the program. The definition of <code>main</code> can have any non-function type, e.g., <code>String</code>, <code>Bool</code>, <code>Nat</code> or <code>Int</code>. The generated executable prints the result of evaluating <code>main</code>.</p> <p>The statement</p> <pre><code><pre>import Stdlib.Prelude open;</pre></code></pre> <p>imports the standard library prelude into the current scope.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#functions","title":"Functions","text":"<p>Function definitions in Juvix look like this:</p> <pre><code><pre>add (x y : Nat) : Nat := x + y;</pre></code></pre> <p>In contrast to many other languages, no function definition keyword like <code>def</code> or <code>fun</code> is required. Just the name of the function needs to be provided, followed by its arguments and the result type. The function body is specified after the assignment symbol (<code>:=</code>). The definition needs to be terminated with a semicolon.</p> <p>Juvix is a statically typed language, which means that the compiler enforces a strict typing discipline with type checking done at compilation time. It is mandatory to specify the types of the function arguments and of the result. When the arguments have different types, they need to be given in separate parenthesized argument groups:</p> <pre><code><pre>addOrMul (shouldMul : Bool) (x y : Nat) : Nat :=  if     | shouldMul := x * y    | else := add x y;</pre></code></pre> <p>As you see above, functions are called by listing their space-separated arguments after the function name: <code>add x y</code> calls <code>add</code> with two arguments <code>x</code> and <code>y</code>. This syntax is different than in mainstream imperative languages, but common in functional languages like OCaml, Haskell or Lean. In Juvix, the expression <code>add (x, y)</code> is a call to the function <code>add</code> with a single argument <code>(x, y)</code> which is a pair of <code>x</code> and <code>y</code>. Using <code>add (x, y)</code> instead of <code>add x y</code> in <code>addOrMul</code> would result in a type error.</p> <p>A \"function\" can have zero arguments. In this way, definitions of functions and constants / variables follow the same syntax:</p> <pre><code><pre>myValue : Nat := 42;</pre></code></pre> <p>Juvix functions can be parameterized by types, similar to generics in Java, Rust, and C++. In functional programming terminology, such functions are called polymorphic - they act uniformly on all types, without relying on type-specific implementations. For example, here is a polymorphic identity function which takes an argument of an arbitrary type <code>A</code> and returns it:</p> <pre><code><pre>id {A} (x : A) : A := x;</pre></code></pre> <p>When calling <code>id</code>, the right type to be substituted for <code>A</code> is inferred automatically by the type checker. For example, in the call <code>id 3</code> the type checker infers that <code>A</code> refers to the type <code>Nat</code>.</p> <p>Note</p> <p>The function <code>id</code> already exists in the standard library, so redefining it in your file may lead to name clashes.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#local-definitions","title":"Local definitions","text":"<p>Local definitions visible only inside a function body are introduced with the <code>let .. in ..</code> syntax:</p> <pre><code><pre>foo (pair : Pair Nat Nat) : Nat :=  let    (x, y) := pair;    bar := 42 + y;    bang (z : Nat) : Nat := z * bar;  in bang (add x bar);</pre></code></pre> <p>The identifiers <code>x</code>, <code>y</code>, <code>bar</code>, and <code>bang</code> are only accessible within the <code>foo</code> function after their declaration. The definitions in a <code>let</code>-block follow the same syntax as top-level definitions. In particular, it is possible to define local functions, like <code>bang</code> above. Type annotations for variables or data structure patterns, like for <code>bar</code> or <code>(x, y)</code> above, can be omitted and automatically inferred by the type checker.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#functional-programming","title":"Functional programming","text":"<p>Juvix is a purely functional language, which means that functions have no side effects and all variables are immutable. Once a variable is assigned a value it cannot be modified - destructive updates are simply absent from the language. Instead of mutating existing variables or data structures, a common functional programming pattern is to \"update\" them by creating new ones.</p> <p>For example, a polymorphic function that swaps the components of a pair could be implemented as follows:</p> <pre><code><pre>swap {A B} (pair : Pair A B) : Pair B A := snd pair, fst pair;</pre></code></pre> <p>Instead of modifying the pair in place, <code>swap</code> returns a new pair with the components swapped. The standard library functions <code>fst</code> and <code>snd</code> return the first and second components of a pair, respectively.</p> <p>Purely functional programming may at first seem exotic to a mainstream imperative programmer, but once assimilated it offers unique advantages. Purity guarantees that all functions are referentially transparent, meaning that they always return the same result for the same arguments. This is not the case in imperative programs, where the result of a function may depend on the implicit global state or the call may have side effects, which is a common source of errors. Functional programs are often more succinct, reliable, and easier to reason about. In particular, formal verification is more manageable for functional than for imperative programs.</p> <p>Functional programming does require a certain shift in the developer's mindset. Nonetheless, the learning curve of a well-designed user-focused purely functional language should not be too steep. Juvix aims to deliver on this promise.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#records","title":"Records","text":"<p>A statically typed programming language would not be very useful without the ability to define new data types. Records with named fields of specified types are among the most common data types. In Juvix, a record type can be defined as follows.</p> <pre><code><pre>type Resource :=  mkResource@{    quantity : Nat;    price : Nat;  };</pre></code></pre> <p>The above defines a record type <code>Resource</code> with two fields <code>quantity</code> and <code>price</code>, both of type <code>Nat</code>. A record of type <code>Resource</code> can be created using the record constructor <code>mkResource</code>:</p> <pre><code><pre>myResource : Resource :=  mkResource@{    quantity := 42;    price := 100;  };</pre></code></pre> <p>The fields of a record can be accessed via their record projections, as demonstrated in the following function with <code>Resource.quantity</code> and <code>Resource.price</code>.</p> <pre><code><pre>totalCost (r : Resource) : Nat := Resource.quantity r * Resource.price r;</pre></code></pre> <p>A record can be \"updated\" by creating a new record with some fields modified:</p> <pre><code><pre>addQuantity (n : Nat) (r : Resource) : Resource :=  r@Resource{quantity := Resource.quantity r + n};</pre></code></pre> <p>The above is equivalent to:</p> <pre><code><pre>addQuantity (n : Nat) (r : Resource) : Resource :=  mkResource@{    quantity := Resource.quantity r + n;    price := Resource.price r;  };</pre></code></pre>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#enumerations-and-inductive-types","title":"Enumerations and inductive types","text":"<p>Enumeration types are defined like this:</p> <pre><code><pre>type Ordering :=  | LessThan  | Equal  | GreaterThan;</pre></code></pre> <p>The above defines a type <code>Ordering</code> with three possible values: <code>LessThan</code>, <code>Equal</code>, and <code>GreaterThan</code>. The values of an enumeration type are its constructors.</p> <p>Distinguishing between different constructors can be achieved using <code>case</code>-expressions:</p> <pre><code><pre>orderingToInt (ord : Ordering) : Int :=  case ord of    | LessThan := -1    | Equal := 0    | GreaterThan := 1;</pre></code></pre> <p>Records and enumerations are special cases of inductive types specified by a number of constructors with arguments. Here is an example of an inductive type with two constructors:</p> <ul> <li><code>Created</code> with one argument <code>commitment</code> of type <code>Nat</code>,</li> <li><code>Consumed</code> with one argument <code>nullifier</code> of type <code>Nat</code>.</li> </ul> <pre><code><pre>type Tag :=  | Created@{      commitment : Nat;    }  | Consumed@{      nullifier : Nat;    };</pre></code></pre> <p>Actually, it is not required to name the arguments of a constructor - their types can be specified in a space-separated sequence instead. The names are often omitted when the constructor has only one argument with the argument being a record and/or the argument name being insignificant.</p> <pre><code><pre>type Commitment :=  mkCommitment@{    commitment : Nat;  };type Nullifier :=  mkNullifier@{    nullifier : Nat;  };type Tag :=  | Created Commitment  | Consumed Nullifier;</pre></code></pre> <p>For most types with multiple constructors, it is considered good practice to wrap constructor arguments into records. This makes type information more explicit and allows to pass all constructor arguments together to a helper function.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#optional-values","title":"Optional values","text":"<p>The polymorphic inductive type <code>Maybe</code> from the standard library is commonly used to represent optional or nullable values in a type-safe manner. It is analogous to <code>Option</code> in Rust, <code>option</code> in OCaml or <code>Maybe</code> in Haskell.</p> <pre><code><pre>type Maybe A :=  | nothing  | just A;</pre></code></pre> <p>Here are two standard library functions commonly used with the <code>Maybe</code> type:</p> <pre><code><pre>isJust {A} (maybeValue : Maybe A) : Bool :=  case maybeValue of    | nothing := false    | just _ := true;fromMaybe {A} (default : A) (maybeValue : Maybe A) : A :=  case maybeValue of    | nothing := default    | just value := value;</pre></code></pre> <p>In Juvix, all functions must be total, meaning they must return a result for every possible input. To handle cases where a function might not produce a result for certain inputs, you can use the <code>Maybe</code> type. When the result is undefined, the function can return <code>nothing</code>.</p> <pre><code><pre>getCommitment (tag : Tag) : Maybe Commitment :=  case tag of    | Created c := just c    | Consumed _ := nothing;getCommitmentD (default : Commitment) (tag : Tag) : Commitment :=  fromMaybe default (getCommitment tag);</pre></code></pre> <p>The function <code>getCommitmentD</code> returns its first argument <code>default</code> if the <code>tag</code> does not contain a commitment.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#lists-and-iteration","title":"Lists and iteration","text":"<p>In the Juvix standard library, the list type is defined as a polymorphic inductive type with two constructors:</p> <ul> <li><code>nil</code> - empty list <code>[]</code>,</li> <li><code>::</code> - \"cons\" - a non-empty list with a head and a tail.</li> </ul> <pre><code><pre>type List A :=  | nil  | :: A (List A);</pre></code></pre> <p>Recall that constructor arguments can be specified without naming them by listing their types after the constructor name, like above for the arguments of <code>::</code>. The first argument of <code>::</code> is the head (first list element) and the second argument is the tail (remaining list elements).</p> <p>The \"cons\" constructor <code>::</code> can be used in right-associative infix notation, e.g., <code>1 :: 2 :: 3 :: nil</code> is the same as <code>1 :: (2 :: (3 :: nil))</code> which is the same as <code>(::) 1 ((::) 2 ((::) 3 nil))</code>. So if <code>lst</code> is a list of <code>Nat</code>s, then <code>1 :: lst</code> is the list with head <code>1</code> and tail <code>lst</code>, i.e., the first element of <code>1 :: lst</code> is <code>1</code> and the remaining elements come from <code>lst</code>. When specifying all list elements at once, a move convenient notation <code>[1; 2; 3]</code> can be used. So <code>[1; 2; 3]</code> is the same as <code>1 :: [2; 3]</code>, <code>1 :: 2 :: [3]</code>, <code>1 :: 2 :: 3 :: []</code> and <code>1 :: 2 :: 3 :: nil</code>.</p> <p>Lists are fundamental data structures in functional programming which represent ordered sequences of elements. Lists are often used where an imperative program would use arrays, but these are not always directly interchangeable. To use lists, imperative array-based code needs to be reformulated to process elements sequentially.</p> <p>In Juvix, list processing is often performed with the <code>for</code> iterator. The expression</p> <pre><code>for (acc := initialValue) (x in list) {\n  BODY\n}\n</code></pre> <p>is evaluated as follows. First, the accumulator <code>acc</code> is assigned its initial value. Then each list element is processed sequentially in the order from left to right (from beginning to end of list). At each step, <code>BODY</code> is evaluated with the current value of <code>acc</code> and the current element <code>x</code>. The result of evaluating <code>BODY</code> becomes the new value of <code>acc</code>, and the iteration proceeds with the next element. The final value of the accumulator <code>acc</code> becomes the value of the whole <code>for</code>-expression.</p> <p>For example, here is a function which sums the elements of a list of natural numbers:</p> <pre><code><pre>sum (lst : List Nat) : Nat :=  for (acc := 0) (x in lst) {    acc + x  };</pre></code></pre> <p>First, the accumulator <code>acc</code> is initialized to 0. As the list <code>lst</code> is traversed from left to right, each element <code>x</code> is added to <code>acc</code>, updating its value. By the end of the iteration, <code>acc</code> holds the sum of all elements in the list.</p> <p>As another example, consider a function computing the total cost of all resources priced at more than 100 (recall <code>Resource</code> and <code>totalCost</code> defined earlier in this tutorial).</p> <pre><code><pre>totalCostOfValuableResources (lst : List Resource) : Nat :=  for (acc := 0) (r in lst) {    if       | Resource.price r &gt; 100 := acc + totalCost r      | else := acc  };</pre></code></pre> <p>The next example demonstrates how to perform iteration with multiple accumulators. The following function <code>minmax</code> computes the minimum and the maximum values in a list of natural numbers. The functions <code>min</code> and <code>max</code> are defined in the standard library.</p> <pre><code><pre>minmax (lst : List Nat) : Pair Nat Nat :=  for (minAcc, maxAcc := 0, 0) (x in lst) {    min minAcc x, max maxAcc x  };</pre></code></pre> <p>You can iterate over multiple lists simultaneously with the help of the <code>zip</code> function, which combines two lists into a list of pairs. For example, <code>zip [1; 2; 3] [4; 5; 6]</code> evaluates to <code>[(1, 4); (2, 5); (3, 6)]</code>. As an illustration, here is an implementation of the dot product for two lists of the same length.</p> <pre><code><pre>dotProduct (lst1 lst2 : List Nat) : Nat :=  for (acc := 0) (x, y in zip lst1 lst2) {    acc + x * y  };</pre></code></pre> <p>The dot product is the sum of products of elements at corresponding positions, e.g.,</p> <pre><code>dotProduct [1; 2; 3] [4; 5; 6]\n= 1 * 4 + 2 * 5 + 3 * 6\n= 32\n</code></pre> <p>In contrast, the following function <code>sumAllProducts</code> computes the sum of products for all possible pairs of elements from the two lists.</p> <pre><code><pre>sumAllProducts (lst1 lst2 : List Nat) : Nat :=  for (acc := 0) (x in lst1) {    for (acc' := acc) (y in lst2) {      acc' + x * y    }  };</pre></code></pre> <p>For example:</p> <pre><code>sumAllProducts [1; 2; 3] [4; 5; 6]\n= 1 * 4 + 1 * 5 + 1 * 6 +\n  2 * 4 + 2 * 5 + 2 * 6 +\n  3 * 4 + 3 * 5 + 3 * 6\n= 90\n</code></pre> <p>The <code>for</code> iterator is suitable for sequentially accumulating values from a list. Often, we want to transform a list into a new list. The <code>map</code> and <code>filter</code> iterators are commonly used for this purpose.</p> <p>The expression</p> <pre><code>map (x in lst) {f x}\n</code></pre> <p>evaluates to a list obtained from <code>lst</code> by replacing each element <code>x</code> with <code>f x</code>. For example, the following function increases the prices of all resources by <code>n</code>.</p> <pre><code><pre>increaseAllPrices (n : Nat) (lst : List Resource) : List Resource :=  map (r in lst) {    r@Resource{price := Resource.price r + n}  };</pre></code></pre> <p>The <code>filter</code> iterator selects elements of a list that satisfy a given condition. For example, the following function picks resources with price greater than <code>price</code>. The order of the elements is preserved.</p> <pre><code><pre>pickValuable (price : Nat) (lst : List Resource) : List Resource :=  filter (r in lst) {    Resource.price r &gt; price  };</pre></code></pre> <p>Lists do not allow for random access to their elements by index. The Juvix standard library intentionally does not provide a function to access the nth element of a list. Such a function could easily be implemented, but it would not be efficient. Lists are not arrays. If you find yourself wanting to access list elements by numerical index, you are most likely doing something wrong: trying to incongruently fit imperative array programming patterns into a functional language instead of using more elegant functional techniques. If you are used to array-based programming, the shift away from \"low-level\" index-based array manipulations in favour of \"high-level\" list iterators and functions may be challenging at first. The section Common techniques at the end of this tutorial collects some methods for solving common programming tasks in a purely functional manner.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#pipes","title":"Pipes","text":"<p>With the pipe <code>|&gt;</code> operator, the last argument of a function can be moved to the front: <code>z |&gt; f x y</code> is the same as <code>f x y z</code>. This is useful for chaining function applications which perform some processing steps in sequence: <code>x |&gt; doStep1 |&gt; doStep2 |&gt; doStep3 |&gt; doStep4</code> is the same as <code>doStep4 (doStep3 (doStep2 (doStep1 x)))</code>. Such processing pipelines are favored over loops with complex bodies, as they result in cleaner code, better separation of concerns across steps, and improved modularity.</p> <p>For example, recall the function <code>totalCostOfValuableResources</code> from the previous section.</p> <pre><code><pre>totalCostOfValuableResources (lst : List Resource) : Nat :=  for (acc := 0) (r in lst) {    if       | Resource.price r &gt; 100 := acc + totalCost r      | else := acc  };</pre></code></pre> <p>The body of the <code>for</code>-expression is somewhat complex, performing three distinct operations: checking if the price of <code>r</code> exceeds a threshold, computing the total cost for <code>r</code>, and computing the sum. The <code>for</code>-expression can be rewritten into a pipeline, resulting in increased readability and cleaner separation between the performed operations.</p> <pre><code><pre>totalCostOfValuableResources (lst : List Resource) : Nat :=  let    isValuable (r : Resource) : Bool := Resource.price r &gt; 100;  in lst |&gt; filter isValuable |&gt; map totalCost |&gt; sum;</pre></code></pre> <p>The iterators <code>map</code> and <code>filter</code> can be used as functions like above, with the body becoming the first argument and the list becoming the second argument. So <code>map doIt lst</code> is the same as <code>map (x in lst) {doIt x}</code>, and <code>filter doIt lst</code> is the same as <code>filter (x in lst) {doIt x}</code>.</p> <p>Now suppose we would like to modify <code>totalCostOfValuableResources</code> to take into account only resources with quantity greater than 10. In the first version, we would need to modify the <code>for</code>-expression body by inserting an extra check, which would complicate it even further. In the second version, we just need to add an extra step to the pipeline. There is no need to modify existing pipeline steps.</p> <pre><code><pre>totalCostOfValuableResources (lst : List Resource) : Nat :=  let    isEnough (r : Resource) : Bool := Resource.quantity r &gt; 10;    isValuable (r : Resource) : Bool := Resource.price r &gt; 100;  in lst |&gt; filter isEnough |&gt; filter isValuable |&gt; map totalCost |&gt; sum;</pre></code></pre>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#sets","title":"Sets","text":"<p>Lists represent ordered sequences of elements with possible duplicates. They are intended for sequential processing and do not support efficient membership checks. If you need to check for membership, the order is not significant and duplicates not allowed, then a <code>Set</code> is an appropriate data structure.</p> <p>Sets are not in the standard library prelude, so you need to import them separately.</p> <pre><code><pre>import Stdlib.Data.Set as Set open using {Set};</pre></code></pre> <p>The above statement makes set functions available qualified with <code>Set.</code> and the <code>Set</code> type available unqualified.</p> <p>The following functions are available for sets.</p> <ul> <li><code>Set.empty</code> is the empty set.</li> <li><code>Set.isMember elem set</code> evaluates to <code>true</code> iff <code>elem</code> is in <code>set</code>.</li> <li><code>Set.insert elem set</code> inserts <code>elem</code> into <code>set</code>, returning the updated set.</li> <li><code>Set.delete elem set</code> removes <code>elem</code> from <code>set</code>.</li> </ul> <p>As an example, here is a function which removes duplicates from a list, preserving element order and keeping the first occurrence of each value.</p> <pre><code><pre>removeDuplicates (lst : List Nat) : List Nat :=  for (acc, seen := [], Set.empty) (x in lst) {      if         | Set.isMember x seen := acc, seen        | else := x :: acc, Set.insert x seen    }    |&gt; fst    |&gt; reverse;</pre></code></pre> <p>The function uses an auxiliary set <code>seen</code> to check if an element was already encountered. The result of the <code>for</code> iteration is a pair <code>(acc, seen)</code>, so to get the result list we need to extract the first component <code>acc</code> using <code>fst</code>. Since the <code>for</code> iterator goes through the list from beginning to end, the order of the accumulated result list is reversed. The standard library function <code>reverse</code>, as its name indicates, reverses the result list back to the original order.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#maps","title":"Maps","text":"<p>A map is a data structure that represents associations from keys to values. Each key can be associated with only one value.</p> <p>In Juvix, the <code>Map</code> type of maps needs to be imported with the following statement:</p> <pre><code><pre>import Stdlib.Data.Map as Map open using {Map};</pre></code></pre> <p>The following functions are supported for maps.</p> <ul> <li> <p><code>Map.empty</code> is the empty map.</p> </li> <li> <p><code>Map.lookup key map</code> evaluates to <code>just value</code> if <code>key</code> is associated with <code>value</code> in <code>map</code>, or to <code>nothing</code> if <code>key</code> has no association in <code>map</code>.</p> </li> <li> <p><code>Map.insert key value map</code> associates <code>key</code> with <code>value</code> in <code>map</code>, overriding any previous association if present.</p> </li> <li> <p><code>Map.delete key map</code> removes the association for <code>key</code> from the <code>map</code>.</p> </li> <li> <p><code>Map.keys map</code> returns the list of keys present in <code>map</code>.</p> </li> <li> <p><code>Map.values map</code> returns the list of values associated with some key in <code>map</code>.</p> </li> </ul> <p>As an example of <code>Map</code> usage, consider the following function which groups resources by their price and adds up the quantities to create one resource for each price. The order of elements in the result list is not preserved.</p> <pre><code><pre>groupResourcesByPrice (lst : List Resource) : List Resource :=  for (acc := Map.empty) (r in lst) {      let        p := Resource.price r;      in case Map.lookup p acc of           | nothing := Map.insert p r acc           | just r' := Map.insert p (addQuantity (Resource.quantity r) r') acc    }    |&gt; Map.values;</pre></code></pre> <p>In fact, <code>groupResourcesByPrice</code> could be written more succinctly using <code>Map.insertWith</code>, which does not replace the value when the key is already present, but instead combines the new and the old values using a provided function.</p> <pre><code><pre>groupResourcesByPrice (lst : List Resource) : List Resource :=  let    combineResources (r1 r2 : Resource) : Resource :=      addQuantity (Resource.quantity r1) r2;  in for (acc := Map.empty) (r in lst) {      Map.insertWith combineResources (Resource.price r) r acc    }    |&gt; Map.values;</pre></code></pre>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#traits","title":"Traits","text":"<p>In Juvix, traits provide a way to define shared behaviour for types, similarly to traits in Rust, type classes in Haskell, and interfaces in Java. A trait specifies a set of functions that must be implemented in an instance for a given type. Traits allow you to write generic, reusable code by specifying constraints on types without committing to a specific implementation.</p> <p>For example, the <code>Eq</code> trait from the standard library specifies the equality function <code>Eq.eq</code>.</p> <pre><code><pre>traittype Eq A :=  mkEq@{    eq (x y : A) : Bool;  };</pre></code></pre> <p>An instance of <code>Eq</code> for a given type can be defined by implementing <code>Eq.eq</code> for this type. Here is an <code>Eq</code> instance definition for the <code>Resource</code> type.</p> <pre><code><pre>instanceeqResourceI : Eq Resource :=  mkEq@{    eq (r1 r2 : Resource) : Bool :=      Resource.quantity r1 == Resource.quantity r2        &amp;&amp; Resource.price r1 == Resource.price r2;  };</pre></code></pre> <p>A polymorphic function that needs an equality operation for its type parameter can be defined generically by requiring an instance of the <code>Eq</code> trait, rather than relying on a specific equality implementation. Then, the function can be used with any type for which an instance of <code>Eq</code> is available. The appropriate instance is chosen at compilation time based on the type. The corresponding concrete equality implementation from the instance is then used.</p> <p>As a trivial example, the standard library actually defines the infix equality operator <code>==</code> in terms of the <code>Eq</code> trait.</p> <pre><code><pre>== {A} {{Eq A}} (x y : A) : Bool := Eq.eq x y;</pre></code></pre> <p>The implicit instance argument <code>{{Eq A}}</code> specifies that wherever the function <code>==</code> is called, an instance of <code>Eq</code> is required for the type parameter <code>A</code>. The specific instance is automatically inferred by the type checker, separately for each function call.</p> <p>Because we have defined an instance of <code>Eq</code> for <code>Resource</code>, we can now use <code>==</code> with resources. The type checker automatically choses <code>eqResourceI</code> as the required instance and uses the corresponding equality implementation.</p> <pre><code><pre>countResource (resource : Resource) (lst : List Resource) : Nat :=  for (acc := 0) (r in lst) {    if       | resource == r := acc + 1      | else := acc  };</pre></code></pre> <p>The above function does not depend on the details of the <code>Resource</code> type. It only requires that equality be available for the list elements. Hence, the function can be generalized to use the <code>Eq</code> trait.</p> <pre><code><pre>countValue {A} {{Eq A}} (value : A) (lst : List A) : Nat :=  for (acc := 0) (x in lst) {    if       | value == x := acc + 1      | else := acc  };</pre></code></pre> <p>To use the polymorphic equality operator <code>==</code>, a type must have an instance of the <code>Eq</code> trait. It is quite tedious to manually implement instances of <code>Eq</code> for each user-defined type. Fortunately, an <code>Eq</code> instance may be derived automatically if <code>Eq</code> instances already exist for the types of all record fields or constructor arguments.</p> <pre><code>deriving instance\neqResourceI : Eq Resource;\n</code></pre>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#debugging","title":"Debugging","text":"<p>Juvix does not currently have a debugger. A common way of debugging Juvix programs is to make use of the REPL. Once you load your file into the REPL (with <code>juvix repl file.juvix</code>, or via Emacs or VSCode), you can evaluate any function from the file with the desired arguments and inspect the result.</p> <p>Another technique is to use the <code>trace</code> function which prints its argument and returns it.</p> <pre><code><pre>import Stdlib.Debug.Trace open;combineResources (r1 r2 : Resource) : Resource :=  trace r1    &gt;-&gt; trace r2    &gt;-&gt; r1@Resource{quantity := Resource.quantity r1 + Resource.quantity r2};</pre></code></pre> <p>The function <code>combineResources</code> first prints <code>r1</code>, then prints <code>r2</code>, then returns updated <code>r1</code>. The sequencing operator <code>&gt;-&gt;</code> first evaluates the expression on the left, ignores the result, then evaluates the expression on the right and returns it. The import above the function is necessary, because <code>trace</code> is not in the standard library prelude.</p> <p>The <code>failwith</code> function may also be useful to immediately crash with an error message.</p> <pre><code><pre>import Stdlib.Debug.Fail open;giveAllAway (lst : List Resource) : List Resource :=  let    lst' :=      map (r in lst) {        r@Resource{price := 0}      };  in if     | length lst /= length lst' :=      failwith \"Oops, something went very wrong with the mapping.\"    | else := trace \"Hurray!\" &gt;-&gt; lst';</pre></code></pre> <p>Finally, <code>assert</code> allows you to specify assumptions at different points in the program.</p> <pre><code><pre>dividePrice (n : Nat) (r : Resource) : Resource :=  assert (n &gt; 0) &gt;-&gt; r@Resource{price := div (Resource.price r) n};</pre></code></pre>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#common-techniques","title":"Common techniques","text":"<p>This section lists some common programming tasks and explains how to solve them in a purely functional manner.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#accumulate-list-elements-from-left-to-right","title":"Accumulate list elements from left to right","text":"<ul> <li> <p>Solution: use <code>for</code>.</p> </li> <li> <p>Example:  <pre><code><pre>reverse {A} (lst : List A) : List A :=  for (acc := []) (x in lst) {    x :: acc  };</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#accumulate-list-elements-from-right-to-left","title":"Accumulate list elements from right to left","text":"<ul> <li> <p>Solution: use <code>rfor</code>.</p> </li> <li> <p>Example:  <pre><code><pre>duplicate (lst : List Nat) : List Nat :=  rfor (acc := []) (x in lst) {    x :: x :: acc  };</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#check-if-a-list-is-empty","title":"Check if a list is empty","text":"<ul> <li> <p>Solution: use <code>isEmpty</code>.</p> </li> <li> <p>Anti-pattern: do not use <code>length lst == 0</code>.</p> </li> </ul> <p>The <code>length</code> function requires computation time proportional to the length of its argument - it needs to traverse the entire list to compute the length. The <code>isEmpty</code> function runs in constant time.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#check-if-a-condition-holds-for-all-list-elements","title":"Check if a condition holds for all list elements","text":"<ul> <li> <p>Solution: use <code>all</code>.</p> </li> <li> <p>Example:  <pre><code><pre>allDivisible (n : Nat) (lst : List Nat) : Bool :=  all (x in lst) {    mod x n == 0  };</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#check-if-a-condition-holds-for-any-list-element","title":"Check if a condition holds for any list element","text":"<ul> <li> <p>Solution: use <code>any</code>.</p> </li> <li> <p>Example:  <pre><code><pre>anyDivisible (n : Nat) (lst : List Nat) : Bool :=  any (x in lst) {    mod x n == 0  };</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#keep-a-state-when-accumulating-list-elements","title":"Keep a state when accumulating list elements","text":"<ul> <li> <p>Solution: use an extra accumulator.</p> </li> <li> <p>Example:  <pre><code><pre>listToMap {A} {{Ord A}} (lst : List A) : Map Nat A :=  for (acc, i := [], 0) (x in lst) {      (i, x) :: acc, i + 1    }    |&gt; fst    |&gt; Map.fromList;</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#replicate-an-element-into-a-list","title":"Replicate an element into a list","text":"<ul> <li>Solution: use <code>replicate</code>. The call <code>replicate n a</code> evaluates to <code>[a; a; ..; a]</code> with <code>a</code> repeated <code>n</code> times.</li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#concatenate-two-lists","title":"Concatenate two lists","text":"<ul> <li> <p>Solution: use <code>++</code>.</p> </li> <li> <p>Warning: <code>lst1 ++ lst2</code> takes time proportional to the length of <code>lst1</code>. When used inside a loop, care must be taken to avoid excessive running time.</p> </li> <li> <p>Example:  <pre><code><pre>flatten {A} (listOfLists : List (List A)) : List A :=  rfor (acc := []) (lst in listOfLists) {    lst ++ acc  };</pre></code></pre></p> </li> </ul> <p>In each step, <code>++</code> takes time proportional to the length of <code>lst</code>, so the   total running time of <code>flatten</code> is proportional to the length of the result.</p> <ul> <li>Anti-example:  <pre><code><pre>flattenWRONG {A} (listOfLists : List (List A)) : List A :=  for (acc := []) (lst in listOfLists) {    acc ++ lst  };</pre></code></pre></li> </ul> <p>In each step, <code>++</code> takes time proportional to the current length of <code>acc</code>,   which gets longer with every step. The total running time of <code>flattenWRONG</code> is   proportional to the square of the length of the result.</p>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#add-an-element-at-the-back-of-a-list","title":"Add an element at the back of a list","text":"<ul> <li> <p>Solution: don't do it. Lists are designed to allow adding elements efficiently only at the front. You should never accumulate list elements by adding them at the back. Change the direction of your iteration (from <code>for</code> to <code>rfor</code> or vice versa) or use <code>reverse</code>.</p> </li> <li> <p>If you really need to do it: use <code>lst ++ [x]</code>, but be aware of the inefficiency. The only legitimate use-cases are when the length of <code>lst</code> is a known constant, or when used carefully like list concatenation.</p> </li> <li> <p>Legitimate use-case examples:  <pre><code><pre>key32Bytes : List Nat := replicate 31 0x0 ++ [0x1];flattenWithSeparator {A} (sep : A) (listOfLists : List (List A)) : List A :=  rfor (acc := []) (lst in listOfLists) {    lst ++ [sep] ++ acc  };</pre></code></pre> </p> </li> <li> <p>Anti-example:  <pre><code><pre>tagsToPairWRONG (tags : List Tag) : Pair (List Nullifier) (List Commitment) :=  for (nfs, cms := [], []) (tag in tags) {    case tag of      | Consumed nf := nfs ++ [nf], cms      | Created cm := nfs, cms ++ [cm]  };</pre></code></pre> </p> </li> <li> <p>Correction:  <pre><code><pre>tagsToPair (tags : List Tag) : Pair (List Nullifier) (List Commitment) :=  rfor (nfs, cms := [], []) (tag in tags) {    case tag of      | Consumed nf := nf :: nfs, cms      | Created cm := nfs, cm :: cms  };</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#iterate-over-a-range-of-numbers","title":"Iterate over a range of numbers","text":"<ul> <li> <p>Solution: use <code>a to b</code> or <code>a to b step k</code>.</p> </li> <li> <p>Examples:  <pre><code><pre>listUpTo (n : Nat) : List Nat :=  rfor (acc := []) (x in 1 to n) {    x :: acc  };divisors (n : Nat) : List Nat :=  if     | n == 0 := []    | else :=      rfor (acc := []) (x in 1 to n) {        if           | mod n x == 0 := x :: acc          | else := acc      };sumEvenUpTo (n : Nat) : Nat :=  for (acc := 0) (x in 2 to n step 2) {    acc + x  };</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/essential.html#repeat-n-times","title":"Repeat n times","text":"<ul> <li> <p>Solution: use <code>iterate</code>.</p> </li> <li> <p>Example:  <pre><code><pre>random (seed : Nat) : Nat := mod (1103515245 * seed + 12345) 2147483648;randoms (n initialSeed : Nat) : Pair Nat (List Nat) :=  let    update (acc : Pair Nat (List Nat)) : Pair Nat (List Nat) :=      let        seed := random (fst acc);      in seed, seed :: snd acc;  in iterate n update (initialSeed, []);</pre></code></pre> </p> </li> </ul>","tags":["tutorial","beginner"],"boost":3},{"location":"tutorials/learn.html","title":"Functional programming with Juvix","text":"<p>Welcome to the Juvix functional programming tutorial! This thorough guide provides a structured introduction to Juvix language features and functional programming concepts. By the end of this tutorial, you'll have a strong foundation in functional programming with Juvix.</p> <p>Before reading this tutorial, it is recommended to work through the Essential Juvix tutorial which introduces basic Juvix freatures. Here we focus on explaining the Juvix language more thoroughly and on employing common functional programming techniques.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#data-types-and-functions","title":"Data types and functions","text":"<p>Common types like <code>Nat</code>, <code>Int</code> and <code>Bool</code> are defined in the standard library. These built-in types are treated specially by the compiler, but they still have ordinary definitions like any other type.</p> <p>The type <code>Bool</code> has two constructors <code>true</code> and <code>false</code>.</p> <pre><code><pre>type Bool :=  | true  | false;</pre></code></pre> <p>The constructors of a data type can be used to build elements of the type. They can also appear as patterns in function definitions. For example, the <code>not</code> function is defined in the standard library by:</p> <pre><code><pre>not : Bool -&gt; Bool  | true := false  | false := true;</pre></code></pre> <p>The type of the definition is specified after the colon. In this case, <code>not</code> is a function from <code>Bool</code> to <code>Bool</code>. The type is followed by two function clauses which specify the function result depending on the shape of the arguments. When a function call is evaluated, the first clause that matches the arguments is used.</p> <p>In contrast to languages like Python, Java or C/C++, Juvix doesn't require parentheses for function calls. All arguments are just listed after the function. The general pattern for function application is: <code>func arg1 arg2 arg3 ...</code></p> <p>Initial arguments that are matched against variables or wildcards in all clauses can be moved to the left of the colon. For example,</p> <pre><code><pre>or (x : Bool) : Bool -&gt; Bool  | true := true  | _ := x;</pre></code></pre> <p>is equivalent to</p> <pre><code><pre>or : Bool -&gt; Bool -&gt; Bool  | _ true := true  | x _ := x;</pre></code></pre> <p>If there is only one clause and all arguments are to the left of the colon, the pipe <code>|</code> should be omitted:</p> <pre><code><pre>id (x : Bool) : Bool := x;</pre></code></pre> <p>A more complex example of a data type is the <code>Nat</code> type from the standard library:</p> <pre><code><pre>type Nat :=  | zero : Nat  | suc : Nat -&gt; Nat;</pre></code></pre> <p>The constructor <code>zero</code> represents <code>0</code> and <code>suc</code> represents the successor function \u2013 <code>suc n</code> is the successor of <code>n</code>, i.e., <code>n+1</code>. For example, <code>suc zero</code> represents <code>1</code>. The number literals <code>0</code>, <code>1</code>, <code>2</code>, etc., are just shorthands for appropriate expressions built using <code>suc</code> and <code>zero</code>.</p> <p>The constructors of a data type specify how the elements of the type can be constructed. For instance, the above definition specifies that an element of <code>Nat</code> is either:</p> <ul> <li><code>zero</code>, or</li> <li><code>suc n</code> where <code>n</code> is an element of <code>Nat</code>, i.e., it is constructed by applying   <code>suc</code> to appropriate arguments (in this case the argument of <code>suc</code> has type   <code>Nat</code>).</li> </ul> <p>Any element of <code>Nat</code> can be built with the constructors in this way \u2013 there are no other elements. Mathematically, this is an inductive definition, which is why the data type is called inductive.</p> <p>Constructors can either by specified by listing their types after colons like in the above definition of <code>Nat</code>, or with a shorter ADT syntax like in the definition of <code>Bool</code>. The ADT syntax is similar to data type definition syntax in functional languages like Haskell or OCaml: one lists the types of constructor arguments separated by spaces. In this syntax, the <code>Nat</code> type could be defined by</p> <pre><code><pre>type Nat :=  | zero  | suc Nat;</pre></code></pre> <p>If implemented directly, the above unary representation of natural numbers would be extremely inefficient. The Juvix compiler uses a binary number representation under the hood and implements arithmetic operations using corresponding machine instructions, so the performance of natural number arithmetic is similar to other programming languages. The <code>Nat</code> type is a high-level presentation of natural numbers as seen by the user who does not need to worry about low-level arithmetic implementation details.</p> <p>One can use <code>zero</code> and <code>suc</code> in pattern matching, like any other constructors:</p> <pre><code><pre>syntax operator + additive;+ : Nat -&gt; Nat -&gt; Nat  | zero b := b  | (suc a) b := suc (a + b);</pre></code></pre> <p>The <code>syntax operator + additive</code> declares <code>+</code> to be an operator with the <code>additive</code> fixity. The <code>+</code> is an ordinary function, except that function application for <code>+</code> is written in infix notation. The definitions of the clauses of <code>+</code> still need the prefix notation on the left-hand sides. Note that to use this definition in the code one needs to import and open <code>Stdlib.Data.Fixity</code>.</p> <p>The <code>a</code> and <code>b</code> in the patterns on the left-hand sides of the clauses are variables which match arbitrary values of the corresponding type. They can be used on the right-hand side to refer to the values matched. For example, when evaluating</p> <pre><code>(suc (suc zero)) + zero\n</code></pre> <p>the second clause of <code>+</code> matches, assigning <code>suc zero</code> to <code>a</code> and <code>zero</code> to <code>b</code>. Then the right-hand side of the clause is evaluated with <code>a</code> and <code>b</code> substituted by these values:</p> <pre><code>suc (suc zero + zero)\n</code></pre> <p>Again, the second clause matches, now with both <code>a</code> and <code>b</code> being <code>zero</code>. After replacing with the right-hand side, we obtain:</p> <pre><code>suc (suc (zero + zero))\n</code></pre> <p>Now the first clause matches and finally we obtain the result</p> <pre><code>suc (suc zero)\n</code></pre> <p>which is just <code>2</code>.</p> <p>The function <code>+</code> is defined like above in the standard library, but the Juvix compiler treats it specially and generates efficient code using appropriate CPU instructions.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#evaluation-order","title":"Evaluation order","text":"<p>By default, evaluation in Juvix is eager (or strict), meaning that the arguments to a function are fully evaluated before applying the function. Only logical operators <code>||</code> and <code>&amp;&amp;</code> are treated specially and evaluated lazily. These special functions cannot be partially applied (see Partial application and higher-order functions below).</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#pattern-matching","title":"Pattern matching","text":"<p>The patterns in function clauses do not have to match on a single constructor \u2013 they may be arbitrarily deep. For example, here is an (inefficient) implementation of a function which checks whether a natural number is even:</p> <pre><code><pre>isEven : Nat -&gt; Bool  | zero := true  | (suc zero) := false  | (suc (suc n)) := isEven n;</pre></code></pre> <p>This definition states that a natural number <code>n</code> is even if either <code>n</code> is <code>zero</code> or, recursively, <code>n-2</code> is even.</p> <p>If a subpattern is to be ignored, then one can use a wildcard <code>_</code> instead of naming the subpattern.</p> <pre><code><pre>isPositive : Nat -&gt; Bool  | zero := false  | (suc _) := true;</pre></code></pre> <p>The above function could also be written as:</p> <pre><code><pre>isPositive : Nat -&gt; Bool  | zero := false  | _ := true;</pre></code></pre> <p>It is not necessary to define a separate function to perform pattern matching. One can use the <code>case</code> syntax to pattern match an expression directly.</p> <pre><code>Stdlib.Prelude&gt; case (1, 2) of (suc _, zero) := 0 | (suc _, suc x) := x | _ := 19\n1\n</code></pre> <p>It is possible to name subpatterns with <code>@</code>.</p> <pre><code>Stdlib.Prelude&gt; case 3 of suc n@(suc _) := n | _ := 0\n2\n</code></pre>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#comparisons-and-conditionals","title":"Comparisons and conditionals","text":"<p>The standard library includes all the expected comparison operators: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>/=</code>. Similarly to arithmetic operations, the comparisons are in fact defined generically for different datatypes using traits, which are out of the scope of this tutorial. For basic usage, one can assume that the comparisons operate on natural numbers.</p> <p>For example, one may define the function <code>max3</code> using <code>&gt;</code> and <code>max</code> from the standard library:</p> <pre><code><pre>max3 (x y z : Nat) : Nat :=  if     | x &gt; y := max x z    | else := max y z;</pre></code></pre>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#local-definitions","title":"Local definitions","text":"<p>Juvix supports local definitions with let-expressions.</p> <pre><code><pre>f (a : Nat) : Nat :=  let    x : Nat := a + 5;    y : Nat := a * 7 + x;  in x * y;</pre></code></pre> <p>The variables <code>x</code> and <code>y</code> are not visible outside <code>f</code>.</p> <p>One can also use multi-clause definitions in <code>let</code>-expressions, with the same syntax as definitions inside a module. For example:</p> <pre><code><pre>isEven : Nat -&gt; Bool :=  let    isEven' : Nat -&gt; Bool      | zero := true      | (suc n) := isOdd' n;    isOdd' : Nat -&gt; Bool      | zero := false      | (suc n) := isEven' n;  in isEven';</pre></code></pre> <p>The functions <code>isEven'</code> and <code>isOdd'</code> are not visible outside <code>isEven</code>.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#recursion","title":"Recursion","text":"<p>Juvix is a purely functional language, which means that functions have no side effects and all variables are immutable. An advantage of functional programming is that all expressions are referentially transparent \u2013 any expression can be replaced by its value without changing the meaning of the program. This makes it easier to reason about programs, in particular to prove their correctness. No errors involving implicit state are possible, because the state is always explicit.</p> <p>In a functional language, there are no imperative loops. Repetition is expressed using recursion. In many cases, the recursive definition of a function follows the inductive definition of a data structure the function analyses. For example, consider the following inductive type of lists of natural numbers:</p> <pre><code><pre>type NList :=  | nnil : NList  | ncons : Nat -&gt; NList -&gt; NList;</pre></code></pre> <p>An element of <code>NList</code> is either <code>nnil</code> (empty) or <code>ncons x xs</code> where <code>x : Nat</code> and <code>xs : NList</code> (a list with head <code>x</code> and tail <code>xs</code>).</p> <p>A function computing the length of a list may be defined by:</p> <pre><code><pre>nlength : NList -&gt; Nat  | nnil := 0  | (ncons _ xs) := nlength xs + 1;</pre></code></pre> <p>The definition follows the inductive definition of <code>NList</code>. There are two function clauses for the two constructors. The case for <code>nnil</code> is easy \u2013 the constructor has no arguments and the length of the empty list is <code>0</code>. For a constructor with some arguments, one typically needs to express the result of the function in terms of the constructor arguments, usually calling the function recursively on the constructor's inductive arguments (for <code>ncons</code> this is the second argument). In the case of <code>ncons _ xs</code>, we recursively call <code>nlength</code> on <code>xs</code> and add <code>1</code> to the result.</p> <p>Let's consider another example \u2013 a function which returns the maximum of the numbers in a list or 0 for the empty list.</p> <pre><code><pre>nmaximum : NList -&gt; Nat  | nnil := 0  | (ncons x xs) := max x (nmaximum xs);</pre></code></pre> <p>Again, there is a clause for each constructor. In the case for <code>ncons</code>, we recursively call the function on the list tail and take the maximum of the result and the list head.</p> <p>For an example of a constructor with more than one inductive argument, consider binary trees with natural numbers in nodes.</p> <pre><code><pre>type Tree :=  | leaf : Nat -&gt; Tree  | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;</pre></code></pre> <p>The constructor <code>node</code> has two inductive arguments (the second and the third) which represent the left and the right subtree.</p> <p>A function which produces the mirror image of a tree may be defined by:</p> <pre><code><pre>mirror : Tree -&gt; Tree  | (leaf x) := leaf x  | (node x l r) := node x (mirror r) (mirror l);</pre></code></pre> <p>The definition of <code>mirror</code> follows the definition of <code>Tree</code>. There are two recursive calls for the two inductive constructors of <code>node</code> (the subtrees).</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#partial-application-and-higher-order-functions","title":"Partial application and higher-order functions","text":"<p>Strictly speaking, all Juvix functions have only one argument. Multi-argument functions are really functions which return a function which takes the next argument and returns a function taking another argument, and so on for all arguments. The function type former <code>-&gt;</code> (the arrow) is right-associative. Hence, the type, e.g., <code>Nat -&gt; Nat -&gt; Nat</code> when fully parenthesised becomes <code>Nat -&gt; (Nat -&gt; Nat)</code>. It is the type of functions which given an argument of type <code>Nat</code> return a function of type <code>Nat -&gt; Nat</code> which itself takes an argument of type <code>Nat</code> and produces a result of type <code>Nat</code>. Function application is left-associative. For example, <code>f a b</code> when fully parenthesised becomes <code>(f a) b</code>. So it is an application to <code>b</code> of the function obtained by applying <code>f</code> to <code>a</code>.</p> <p>Since a multi-argument function is just a one-argument function returning a function, it can be partially applied to a smaller number of arguments than specified in its definition. The result is an appropriate function. For example, <code>sub 10</code> is a function which subtracts its argument from <code>10</code>, and <code>(+) 1</code> is a function which adds <code>1</code> to its argument. If the function has been declared as an infix operator (like <code>+</code>), then for partial application one needs to enclose it in parentheses.</p> <p>A function which takes a function as an argument is a higher-order function. An example is the <code>nmap</code> function which applies a given function to each element in a list of natural numbers.</p> <pre><code><pre>nmap (f : Nat -&gt; Nat) : NList -&gt; NList  | nnil := nnil  | (ncons x xs) := ncons (f x) (nmap f xs);</pre></code></pre> <p>The application</p> <pre><code>nmap \\{x := div x 2} lst\n</code></pre> <p>divides every element of <code>lst</code> by <code>2</code>, rounding down the result. The expression</p> <pre><code>\\{x := div x 2}\n</code></pre> <p>is an unnamed function, or a lambda, which divides its argument by <code>2</code>.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#polymorphism","title":"Polymorphism","text":"<p>The type <code>NList</code> we have been working with above requires the list elements to be natural numbers. It is possible to define lists polymorphically, parameterising them by the element type. This is similar to generics in languages like Java, C++ or Rust. Here is the polymorphic definition of lists from the standard library:</p> <pre><code><pre>syntax operator :: cons;type List A :=  | nil : List A  | :: : A -&gt; List A -&gt; List A;</pre></code></pre> <p>The constructor <code>::</code> is declared as a right-associative infix operator. The definition has a parameter <code>A</code> which is the element type. Then <code>List Ty</code> is the type of lists with elements of type <code>Ty</code>. For example, <code>List Nat</code> is the type of lists of natural numbers, isomorphic to the type <code>NList</code> defined above.</p> <p>Now one can define the <code>map</code> function polymorphically:</p> <pre><code><pre>map {A B} (f : A -&gt; B) : List A -&gt; List B  | nil := nil  | (h :: hs) := f h :: map f hs;</pre></code></pre> <p>This function has two implicit type arguments <code>A</code> and <code>B</code>. These arguments are normally omitted in function application \u2013 they are inferred automatically during type checking. The curly braces indicate that the argument is implicit and should be inferred.</p> <p>In fact, the constructors <code>nil</code> and <code>::</code> also have an implicit argument: the type of list elements. All type parameters of a data type definition become implicit arguments of the constructors.</p> <p>Usually, the implicit arguments in a function application can be inferred. However, sometimes this is not possible and then the implicit arguments need to be provided explicitly by enclosing them in braces:</p> <pre><code>f {implArg1} .. {implArgK} arg1 .. argN\n</code></pre> <p>For example, <code>nil {Nat}</code> has type <code>List Nat</code> while <code>nil</code> by itself has type <code>{A : Type} -&gt; List A</code>.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#tail-recursion","title":"Tail recursion","text":"<p>Any recursive call whose result is further processed by the calling function needs to create a new stack frame to save the calling function environment. This means that each such call will use a constant amount of memory. For example, a function <code>sum</code> implemented as follows will use an additional amount of memory proportional to the length of the processed list:</p> <pre><code><pre>sum : List Nat -&gt; Nat  | nil := 0  | (x :: xs) := x + sum xs;</pre></code></pre> <p>This is not acceptable if you care about performance. In an imperative language, one would use a simple loop going over the list without any memory allocation. In pseudocode:</p> <pre><code>var sum : Nat := 0;\n\nwhile (lst /= nil) do\nbegin\n  sum := sum + head lst;\n  lst := tail lst;\nend;\n\nresult := sum;\n</code></pre> <p>Fortunately, it is possible to rewrite this function to use tail recursion. A recursive call is tail recursive if its result is also the result of the calling function, i.e., the calling function returns immediately after it without further processing. The Juvix compiler guarantees that all tail calls will be eliminated, i.e., that they will be compiled to simple jumps without extra memory allocation. In a tail recursive call, instead of creating a new stack frame, the old one is reused.</p> <p>The following implementation of <code>sum</code> uses tail recursion.</p> <pre><code><pre>sum (lst : List Nat) : Nat :=  let    go (acc : Nat) : List Nat -&gt; Nat      | nil := acc      | (x :: xs) := go (acc + x) xs;  in go 0 lst;</pre></code></pre> <p>The first argument of <code>go</code> is an accumulator which holds the sum computed so far. It is analogous to the <code>sum</code> variable in the imperative loop above. The initial value of the accumulator is 0. The function <code>go</code> uses only constant additional memory overall. The code generated for it by the Juvix compiler is equivalent to an imperative loop.</p> <p>Most imperative loops may be translated into tail recursive functional programs by converting the locally modified variables into accumulators and the loop condition into pattern matching. For example, here is an imperative pseudocode for computing the nth Fibonacci number in linear time. The variables <code>cur</code> and <code>next</code> hold the last two computed Fibonacci numbers.</p> <pre><code>var cur : Nat := 0;\nvar next : Nat := 1;\n\nwhile (n /= 0) do\nbegin\n  tmp := next;\n  next := cur + next;\n  cur := tmp;\n  n := n - 1;\nend;\n\nresult := cur;\n</code></pre> <p>An equivalent functional program is:</p> <pre><code><pre>fib : Nat -&gt; Nat :=  let    go (cur next : Nat) : Nat -&gt; Nat      | zero := cur      | (suc n) := go next (cur + next) n;  in go 0 1;</pre></code></pre> <p>A naive definition of the Fibonacci function runs in exponential time:</p> <pre><code><pre>fib : Nat -&gt; Nat  | zero := 0  | (suc zero) := 1  | (suc (suc n)) := fib n + fib (suc n);</pre></code></pre> <p>Tail recursion is less useful when the function needs to allocate memory anyway. For example, one could make the <code>map</code> function from the previous section tail recursive, but the time and memory use would still be proportional to the length of the input because of the need to allocate the result list. In fact, a tail recursive <code>map</code> needs to allocate and discard an intermediate list which is reversed in the end to preserve the original element order:</p> <pre><code><pre>map {A B} (f : A -&gt; B) : List A -&gt; List B :=  let    go (acc : List B) : List A -&gt; List B      | nil := reverse acc      | (x :: xs) := go (f x :: acc) xs;  in go nil;</pre></code></pre> <p>So we have replaced stack allocation with heap allocation. This actually decreases performance.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#conclusion","title":"Conclusion","text":"<ul> <li>Use tail recursion to eliminate stack allocation.</li> <li>Do not use tail recursion to replace stack allocation with heap allocation.</li> </ul>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#iteration-over-data-structures","title":"Iteration over data structures","text":"<p>A common use of recursion is to traverse a data structure in a specified order accumulating some values. For example, the tail recursive <code>sum</code> function fits this pattern.</p> <p>Juvix provides special support for data structure traversals with the iterator syntax. The standard library defines several list iterators, among them <code>for</code> and <code>rfor</code>. We can implement the <code>sum</code> function using <code>for</code>:</p> <pre><code><pre>sum (l : List Nat) : Nat :=  for (acc := 0) (x in l) {    x + acc  };</pre></code></pre> <p>The above <code>for</code> iteration starts with the accumulator <code>acc</code> equal to <code>0</code> and goes through the list <code>l</code> from left to right (from beginning to end), at each step updating the accumulator to <code>x + acc</code> where <code>x</code> is the current list element and <code>acc</code> is the previous accumulator value. The final value of the iteration is the final value of the accumulator. The <code>for</code> iterator is tail recursive, i.e., no stack memory is allocated and the whole iteration is compiled to a loop.</p> <p>The <code>rfor</code> iterator is analogous to <code>for</code> except that it goes through the list from right to left (from end to beginning) and is not tail recursive. For example, one can implement <code>map</code> using <code>rfor</code>:</p> <pre><code><pre>map {A B} (f : A -&gt; B) (l : List A) : List B :=  rfor (acc := nil) (x in l) {    f x :: acc  };</pre></code></pre> <p>The iterators are just ordinary higher-order Juvix functions which can be used with the iterator syntax. In fact, the <code>map</code> function from the standard library can also be used with the iterator syntax. The expression</p> <pre><code>map (x in l) {body}\n</code></pre> <p>is equivalent to</p> <pre><code>map \\{x := body} l\n</code></pre> <p>Whenever possible, it is advised to use the standard library iterators instead of manually writing recursive functions. When reasonable, <code>for</code> should be preferred to <code>rfor</code>. The iterators provide a readable syntax and the compiler might be able to optimize them better than manually written recursion.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#totality-checking","title":"Totality checking","text":"<p>By default, the Juvix compiler requires all functions to be total. Totality consists of:</p> <ul> <li>termination and   coverage for function declarations,   and</li> <li>strict positivity for user-defined   data types.</li> </ul> <p>The termination check ensures that all functions are structurally recursive, i.e., all recursive calls are on structurally smaller values \u2013 subpatterns of the matched pattern.</p> <p>However, we can still make Juvix accept a non-terminating function via the <code>terminating</code> keyword, skipping the termination check.</p> <pre><code><pre>terminatinglog2 (n : Nat) : Nat :=  if     | n &lt;= 1 := 0    | else := suc (log2 (div n 2));</pre></code></pre> <p>Let us look at other examples. The termination checker rejects the following definition of the factorial function (when the <code>terminating</code> keyword is removed):</p> <pre><code><pre>terminatingfact (x : Nat) : Nat :=  if     | x == 0 := 1    | else := x * fact (sub x 1);</pre></code></pre> <p>To ensure termination, the argument to the recursive call must be a proper subpattern of a pattern matched on in the clause. One can reformulate this definition so that it is accepted by the termination checker:</p> <pre><code><pre>fact : Nat -&gt; Nat  | zero := 1  | x@(suc n) := x * fact n;</pre></code></pre> <p>Coverage checking ensures that there are no unhandled patterns in function clauses or <code>case</code> expressions. For example, the following definition is rejected because the case <code>suc zero</code> is not handled:</p> <pre><code>  isEven : Nat -&gt; Bool\n    | zero := true\n    | (suc (suc n)) := isEven n;\n</code></pre> <p>Since coverage checking forces the user to specify the function for all input values, it may be unclear how to implement functions which are typically partial. For example, the <code>tail</code> function on lists is often left undefined for the empty list. One solution is to return a default value. In the Juvix standard library, <code>tail</code> is implemented as follows, returning the empty list when the argument is empty.</p> <pre><code><pre>tail {A} : List A -&gt; List A  | (_ :: xs) := xs  | nil := nil;</pre></code></pre> <p>Another solution is to wrap the result in the <code>Maybe</code> type from the standard library, which allows representing optional values. An element of <code>Maybe A</code> is either <code>nothing</code> or <code>just x</code> with <code>x : A</code>.</p> <pre><code><pre>type Maybe A :=  | nothing : Maybe A  | just : A -&gt; Maybe A;</pre></code></pre> <p>For example, one could define the tail function as:</p> <pre><code><pre>tail {A} : List A -&gt; Maybe (List A)  | (_ :: xs) := just xs  | nil := nothing;</pre></code></pre> <p>Then the user needs to explicitly check if the result of the function contains a value or not:</p> <pre><code>case tail' lst of\n| just x := ...\n| nothing := ...\n</code></pre>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#exercises","title":"Exercises","text":"<p>You have now learnt essential functional programming techniques in Juvix. To consolidate your understanding, try doing some of the following exercises.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#warm-up-exercises","title":"Warm-up exercises","text":"","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#boolean-operators","title":"Boolean operators","text":"<p>Let's start by defining some functions on booleans.</p> <p>The type for booleans is defined in the standard library like this:</p> <pre><code><pre>type Bool :=  | true : Bool  | false : Bool;</pre></code></pre> <p>Remember that you can import this definition by adding <code>import Stdlib.Prelude open</code> at the beginning of your module.</p> <p>Now, define the logical function <code>not</code> by using pattern matching.</p> <p>Tip</p> <p>The type of your function should be:</p> <pre><code>        not : Bool -&gt; Bool;\n</code></pre> <p>Now, define the logical functions <code>and</code>, <code>or</code> by using pattern matching as well. Feel free to experiment and see what happens if your patterns are not exhaustive, i.e., if not all the cases are covered.</p> <p>Next, let's define the logical function <code>xor</code>, which should return <code>true</code> if and only if exactly one of its arguments is <code>true</code>. This time, instead of using pattern matching, use the previously defined logical functions.</p> <p>Tip</p> <p>Be wary of using the standard library here as it may cause name conflicts.</p> Solution <p><pre><code><pre>type Bool :=  | true : Bool  | false : Bool;not : Bool -&gt; Bool  | false := true  | true := false;or : Bool -&gt; Bool -&gt; Bool  | false b := b  | true  := true;and : Bool -&gt; Bool -&gt; Bool  | true b := b  | false  := false;xor (a b : Bool) : Bool := and (not (and a b)) (or a b);","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#the-maybe-type","title":"The <code>Maybe</code> type","text":"<p>The <code>NMaybe</code> type encapsulates an optional natural number (the preceding <code>N</code>\nstands for <code>Nat</code>). The <code>nnothing</code> constructor is used when the value is missing.\nOn the other hand, the <code>njust</code> constructor is used when the value is present.</p>\n<pre><code><pre>type NMaybe :=  | nnothing : NMaybe  | njust : Nat \u2192 NMaybe;</pre></code></pre>\n\n<p>Let's define a function <code>isJust : NMaybe -&gt; Bool</code> that returns <code>true</code> when the\nvalue is present.</p>\n\nSolution\n<p><pre><code><pre>type NMaybe :=  | nnothing : NMaybe  | njust : Nat \u2192 NMaybe;isJust : NMaybe -&gt; Bool  | (njust _) := true  | nnothing := false;</pre></code></pre></p>\n\n<p>Now let's define a function <code>fromMaybe : Nat -&gt; NMaybe -&gt; Nat</code> that given a\n<code>NMaybe</code>, returns its value if present and otherwise returns the first argument\nas a default value.</p>\n\nSolution\n<p><pre><code><pre>type NMaybe :=  | nnothing : NMaybe  | njust : Nat \u2192 NMaybe;fromMaybe (d : Nat) : NMaybe -&gt; Nat  | (njust n) := n  | nnothing := d;</pre></code></pre></p>\n\n<p>It would be useful to have a type that represents optional values of any type.\nIn Juvix, we can define the polymorphic version of <code>NMaybe</code> like this:</p>\n<pre><code><pre>type Maybe A :=  | nothing : Maybe A  | just : A \u2192 Maybe A;</pre></code></pre>\n\n<p>In this definition, we parameterize the type <code>Maybe</code> with a generic type <code>A</code>.</p>\n<p>Implement again the <code>fromMaybe</code> function, but now, for the polymorphic <code>Maybe</code>\ntype. Note that in function definitions we must specify the type variables. The\ndefinition of <code>fromMaybe</code> begins with:</p>\n<pre><code>fromMaybe {A} (d : A) : Maybe A -&gt; A\n</code></pre>\n<p>Give the implementation.</p>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;fromMaybe {A} (d : A) : Maybe A -&gt; A  | (just n) := n  | nothing := d;</pre></code></pre></p>\n\n<p>Neat! It is indeed very easy to define polymorphic functions in Juvix.</p>\n<p>To get some more practice, give an implementation for <code>maybe</code> which begins with:</p>\n<pre><code>maybe {A B} (d : B) (f : A -&gt; B) : Maybe A -&gt; B\n</code></pre>\n<p>This should return the value (if present) applied to the function <code>f</code>. Otherwise\nit should return the default value <code>d</code>.</p>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;maybe {A B} (d : B) (f : A -&gt; B) : Maybe A -&gt; B  | (just n) := f n  | nothing := d;</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#list-exercises","title":"List exercises","text":"<p>We can define polymorphic lists as follows:</p>\n<pre><code><pre>import Stdlib.Data.Fixity open;syntax operator :: cons;type List A :=  | nil : List A  | :: : A -&gt; List A -&gt; List A;</pre></code></pre>\n\n<p>Let's define a function that returns the first element of a <code>List</code> if it exists.</p>\n<p>Is beginning the definition as follows appropriate? If not, why?</p>\n<pre><code>head {A} : List A -&gt; A\n</code></pre>\n<p>Try to give an implementation for it.</p>\n\nSolution\n<p>As we know, Juvix guarantees that all functions are total.\nBut we cannot return anything when the list is empty.\nTherefore it makes sense to use the <code>Maybe</code> type that we defined in the previous section.\nThe proper definition of <code>head</code> should be:</p>\n<p><pre><code><pre>import Stdlib.Prelude open;head {A} : List A -&gt; Maybe A  | nil := nothing  | (h :: _) := just h;</pre></code></pre></p>\n\n<p>So far we have defined only functions that do not involve looping, but any\nnon-trivial program will require some sort of repetition, so let's tackle that.</p>\n<p>As stated previously, the only way to express repetition in Juivx is by using\nrecursion. We say that a function is recursive if it is defined in terms of\nitself, i.e., the name of the function appears in its body.</p>\n<p>The next exercise is to define a function which returns the last element of a\nlist. This function will need to call itself until it reaches the last element\nof the list.</p>\n<pre><code>last {A} : List A -&gt; Maybe A;\n</code></pre>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;last {A} : List A -&gt; Maybe A  | nil := nothing  | (x :: nil) := just x  | (_ :: xs) := last xs;</pre></code></pre></p>\n\n<p>Next, implement a function that concatenates two lists:</p>\n<pre><code>  concat {A} : List A -&gt; List A -&gt; List A\n</code></pre>\n\n<p>Tip</p>\n<p>It is enough to pattern match the first list.</p>\n\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;concat {A} : List A -&gt; List A -&gt; List A  | nil b := b  | (a :: as) b := a :: concat as b;</pre></code></pre></p>\n\n<p>Now write a function that concatenates a list of lists.</p>\n<pre><code>  concatMany {A} : List (List A) -&gt; List A\n</code></pre>\n\n<p>Tip</p>\n<p><code>concat</code> may be helpful.</p>\n\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;concat {A} : List A -&gt; List A -&gt; List A  | nil b := b  | (a :: as) b := a :: concat as b;concatMany {A} : List (List A) -&gt; List A  | nil := nil  | (a :: as) := concat a (concatMany as);</pre></code></pre></p>\n\n<p>Can you give an alternative implementation that uses the <code>rfor</code> iterator? What\nwould happen if you used <code>for</code> instead of <code>rfor</code>?</p>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;import Stdlib.Data.Fixity open;concat {A} : List A -&gt; List A -&gt; List A  | nil b := b  | (a :: as) b := a :: concat as b;concatMany-iter {A} (m : List (List A)) : List A :=  rfor (acc := nil) (l in m) {    concat l acc  };</pre></code></pre></p>\n\n<p>In the previous solution, if you replace <code>rfor</code> by <code>for</code>, the resulting list\nwill be as if the original list was reversed, but each of the nested lists keep\ntheir original order.</p>\n<p>Write a function that reverses a list:</p>\n<ul>\n<li>using the <code>for</code> iterator,</li>\n<li>using tail recursion.</li>\n</ul>\n\nSolution\n<p>Using the <code>for</code> iterator:</p>\n<p><pre><code><pre>import Stdlib.Prelude open;reverse {A} (xs : List A) : List A :=  for (acc := nil) (x in xs) {    x :: acc  };</pre></code></pre></p>\n<p>Using tail recursion:</p>\n<p><pre><code><pre>import Stdlib.Prelude open;reverse {A} : List A -&gt; List A :=  let    go (acc : List A) : List A -&gt; List A      | nil := acc      | (x :: xs) := go (x :: acc) xs;  in go nil;</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#function-composition","title":"Function composition","text":"<p>Let's try a different exercise. Define a function <code>compose</code> that composes two\nfunctions <code>f</code> and <code>g</code>. It should take three arguments <code>f</code>, <code>g</code>, <code>x</code> and its only\nclause's body should be <code>f (g x)</code>.</p>\n<p>Can you make the <code>compose</code> function polymorphic and as general as possible?</p>\n\nHint\n<p>The definition should start like this:</p>\n<pre><code>    compose {A B C} ...\n</code></pre>\n\n\nSolution\n<p><pre><code><pre>compose {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);</pre></code></pre></p>\n\n<p>Congratulations! Your warm-up is complete!</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#more-exercises","title":"More exercises","text":"","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#prime-numbers","title":"Prime numbers","text":"<p>Define a function <code>prime : Nat -&gt; Bool</code> which checks if a given natural number\nis prime.</p>\n\n<p>Tip</p>\n<p>A number is prime if it is greater than 1 and has no divisors\nother than 1 and itself.</p>\n\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;prime (x : Nat) : Bool :=  let    go : Nat -&gt; Bool      | zero := true      | (suc zero) := true      | n@(suc k) :=        if           | mod x k == 0 := false          | else := go k;  in case x of       | zero := false       | suc zero := false       | suc k := go k;</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#half","title":"Half","text":"<p>Does Juvix accept the following definition?</p>\n<pre><code>half : Nat -&gt; Nat :=\n  if\n    | n &lt; 2 := 0\n    | else := half (sub n 2) + 1;\n</code></pre>\n<p>If not, how can you reformulate this definition so that it is accepted by Juvix?</p>\n\nSolution\n<p>The definition doesn't pass the termination checker.\nOne way to reformulate it is as follows:</p>\n<p><pre><code><pre>import Stdlib.Prelude open;half : Nat -&gt; Nat  | zero := 0  | (suc zero) := 0  | (suc (suc n)) := half n + 1;</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#tree-map","title":"Tree map","text":"<p>Recall the <code>Tree</code> type from above.</p>\n<pre><code><pre>import Stdlib.Prelude open;type Tree :=  | leaf : Nat -&gt; Tree  | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;</pre></code></pre>\n\n<p>Analogously to the <code>map</code> function for lists, define a function</p>\n<pre><code>tmap : (Nat -&gt; Nat) -&gt; Tree -&gt; Tree;\n</code></pre>\n<p>which applies a function to all natural numbers stored in a tree.</p>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;type Tree :=  | leaf : Nat -&gt; Tree  | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;tmap (f : Nat -&gt; Nat) : Tree -&gt; Tree  | (leaf x) := leaf (f x)  | (node x l r) := node (f x) (tmap f l) (tmap f r);</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#polymorphic-tree","title":"Polymorphic tree","text":"<p>Modify the <code>Tree</code> type to be polymorphic in the element type, and then\nrepeat the previous exercise.</p>\n\nSolution\n<p>The <code>Tree</code> type and the <code>tmap</code> function need to be made polymorphic in the element types.</p>\n<p><pre><code><pre>type Tree A :=  | leaf : A -&gt; Tree A  | node : A -&gt; Tree A -&gt; Tree A -&gt; Tree A;tmap {A B} (f : A -&gt; B) : Tree A -&gt; Tree B  | (leaf x) := leaf (f x)  | (node x l r) := node (f x) (tmap f l) (tmap f r);</pre></code></pre></p>\n<p>Note that only the types needed to be changed.</p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#suffixes","title":"Suffixes","text":"<p>A suffix of a list <code>l</code> is any list which can be obtained from <code>l</code> by removing\nsome initial elements. For example, the suffixes of <code>1 :: 2 :: 3 :: nil</code> are:</p>\n<ul>\n<li><code>1 :: 2 :: 3 :: nil</code>,</li>\n<li><code>2 :: 3 :: nil</code>,</li>\n<li><code>3 :: nil</code>, and</li>\n<li><code>nil</code>.</li>\n</ul>\n<p>Define a function which computes the list of all suffixes of a given list,\narranged in descending order of their lengths.</p>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;suffixes {A} : List A -&gt; List (List A)  | nil := nil :: nil  | xs@(_ :: xs') := xs :: suffixes xs';</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#factorial","title":"Factorial","text":"<p>Write a tail recursive function which computes the factorial of a natural\nnumber.</p>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;fact : Nat -&gt; Nat :=  let    go (acc : Nat) : Nat -&gt; Nat      | zero := acc      | n@(suc n') := go (acc * n) n';  in go 1;</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/learn.html#list-function-compose","title":"List function compose","text":"<p>Define a function</p>\n<pre><code>comp {A} : List (A -&gt; A) -&gt; A -&gt; A\n</code></pre>\n<p>which composes all functions in a list. For example,</p>\n<pre><code>comp (suc :: (*) 2 :: \\{x := sub x 1} :: nil)\n</code></pre>\n<p>should be a function which given <code>x</code> computes <code>2(x - 1) + 1</code>.</p>\n\nSolution\n<p><pre><code><pre>import Stdlib.Prelude open;comp {A} (fs : List (A -&gt; A)) : A -&gt; A :=  for (acc := id) (f in fs) {    f &gt;&gt; acc  };</pre></code></pre></p>\n<p>where <code>&gt;&gt;</code> is the composition function from the standard library:</p>\n<p><pre><code><pre>import Stdlib.Data.Fixity open;syntax operator &gt;&gt; composition;&gt;&gt; {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);</pre></code></pre></p>","tags":["tutorial","intermediate","functional-programming"],"boost":2},{"location":"tutorials/vscode.html","title":"Juvix VSCode extension tutorial","text":"<p>To install the Juvix VSCode extension, click on the \"Extensions\" button in the left panel and search for the \"Juvix\" extension by Heliax.</p> <p>Once you've installed the Juvix extension, you can open a Juvix file. For example, create a <code>Hello.juvix</code> file with the following content.</p> <pre><code><pre>module Hello;  import Stdlib.Prelude open;    main : String := \"Hello world!\";end;</pre></code></pre> <p>The name of the top module must coincide with the file name.</p> <p>Syntax should be automatically highlighted for any file with the <code>.juvix</code> extension. You can jump to the definition of an identifier by pressing F12 or control-clicking it. To apply the Juvix code formatter to the current file, use Shift+Ctrl+I.</p> <p>In the top right-hand corner of the editor window you should see several buttons. Hover the mouse pointer over a button to see its description. The functions of the buttons are as follows.</p> <ul> <li>Load file in REPL (Shift+Alt+R). Launches the Juvix REPL in a separate   window and loads the current file into it. You can then evaluate any   definition from the loaded file.</li> <li>Typecheck (Shift+Alt+T). Type-checks the current file.</li> <li>Compile (Shift+Alt+C). Compiles the current file. The resulting native   executable will be left in the directory of the file.</li> <li>Evaluate (Shift+Alt+X). Evaluates the current file in the Juvix   evaluator. The output of the program evaluation is displayed in a separate   window.</li> <li>Html preview. Generates HTML documentation for the current file and displays   it in a separate window.</li> </ul>","boost":2},{"location":"blog/archive/2023.html","title":"2023","text":""},{"location":"blog/archive/2022.html","title":"2022","text":""},{"location":"blog/category/language.html","title":"language","text":""},{"location":"blog/category/type-system.html","title":"type-system","text":""}]}