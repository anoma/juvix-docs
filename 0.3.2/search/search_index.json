{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Juvix documentation!","text":"<p>Juvix is an open-source, ever-evolving functional language for creating privacy-focused decentralized apps. It allows developers to write high-level programs that compile to WASM or, via VampIR, to circuits for private execution using Taiga on Anoma or Ethereum.</p> <p>This documentation covers various topics, including a concise introduction to the Juvix ecosystem, which can be found in the overview section.</p> <ul> <li> <p> How-to guides</p> <p>Learn how to install Juvix on macOS or Linux, as well as compile and    document your Juvix projects.</p> <p> Quick start </p> <p> How-to guides </p> </li> <li> <p> Tutorials</p> <p>Master the essentials of Juvix's programming language though a series of tailored examples, tutorials and technical explanations.</p> <p> Learn Juvix in 5 minutes</p> </li> <li> <p> Explanations</p> <p>Comprehensive technical explanations' series.</p> <p> Read the book</p> </li> <li> <p> Reference</p> <p>Explore the Language reference, milestone examples, and tooling Documentation!</p> <p> Reference</p> </li> <li> <p> Blog</p> <p>Check out our blog to discover new features in the upcoming release, along with helpful examples and more. And, don't forget to join us on Discord.</p> <p> Join us</p> </li> <li> <p> Open Source, GPL3.0</p> <p>Juvix is licensed under GPL3 and available on GitHub.</p> <p> License</p> </li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":"<p>To install Juvix, follow the instructions in the Installation How-to.</p> <p>After installation, run <code>juvix --help</code> to see the list of commands.</p> <p>Run Juvix doctor to check your system setup:</p> <pre><code>juvix doctor\n</code></pre>"},{"location":"quick-start/#cli-usage-examples","title":"CLI Usage Examples","text":"<p>Create a new package:</p> <pre><code>juvix init\n</code></pre> <p>Compile a source file into an executable:</p> <pre><code>juvix compile path/to/source.juvix\n</code></pre> <p>Compile a source file into a WebAssembly binary:</p> <pre><code>juvix compile -t wasm path/to/source.juvix\n</code></pre> <p>Launch the REPL:</p> <pre><code>juvix repl\n</code></pre> <p>Typecheck a source file:</p> <pre><code>juvix typecheck path/to/source.juvix\n</code></pre> <p>Generate HTML representations of a source file and its imports:</p> <pre><code>juvix html --recursive path/to/source.juvix\n</code></pre>"},{"location":"quick-start/#the-hello-world-example","title":"The Hello World example","text":"<p>This is the Juvix source code of the traditional Hello World program.</p> <pre><code>-- HelloWorld.juvix\nmodule HelloWorld;\n\nopen import Stdlib.Prelude;\n\nmain : IO;\nmain := printStringLn \"hello world!\";\n\nend;\n</code></pre> <p>To compile and run a binary generated by Juvix, save the source code to a file called <code>HelloWorld.juvix</code> and run the following command from the directory containing it:</p> <pre><code>juvix compile HelloWorld.juvix\n./HelloWorld\n</code></pre> <p>You should see the output: <code>hello world!</code></p> <p>The source code can also be compiled to a WebAssembly binary. This requires some additional setup. See the Installation How-to for more information. You can also run <code>juvix doctor</code> to check your setup.</p> <pre><code>juvix compile --target wasm HelloWorld.juvix\nwasmer HelloWorld.wasm\n</code></pre>"},{"location":"about/community/","title":"Juvix community","text":"<p>Join us on our Discord server</p> <p>This project is part of a bigger effort called Anoma. Anoma is a suite of protocols and mechanisms for self-contained, self-sovereign coordination. Join the Anoma project.</p>"},{"location":"blog/","title":"Juvix Blog","text":"<p>Hola and welcome to the Juvix blog!</p> <p>Welcome to our cosy corner, where we dive into the world of functional programming and next-generation distributed apps! We'll be exploring Juvix and beyond, discussing fascinating aspects and applications. So come on in, and let's embark on this exciting journey together!</p>"},{"location":"blog/#what-can-you-expect","title":"What can you expect?","text":"<p>Throughout our articles, you'll discover functional programming (FP), and potentially, implementation notes pertinent to the ongoing development cycles of Juvix. Our primary objective is to share our insights about Juvix while encouraging discussions centred on functional programming concepts and methodologies.</p>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/","title":"Stay Positive with Your Data Types","text":"<p>In this blog post, we will investigate the notion of strictly positive inductive data types, which is a condition that Juvix mandates for a data type to be considered well-typed.</p> <p>An inductive type is considered strictly positive if it either:</p> <ol> <li>Does not appear within the argument types of its constructors, or</li> <li>Appears strictly positively within the argument types of its constructors.</li> </ol> <p>A name is considered strictly positive for an inductive type if it never appears in a negative position within the argument types of its constructors. The term negative position denotes instances located to the left of an arrow in a type constructor argument.</p>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/#example","title":"Example","text":"<p>Consider the following data type <code>X</code> where <code>A</code> and <code>B</code> are types in scope:</p> <pre><code>  type X :=\n    | c0 : (B -&gt; X) -&gt; X\n    | c1 : (X -&gt; A) -&gt; X;\n</code></pre> <p>In this example, the type <code>X</code> occurs strictly positive in the constructor <code>c0</code>, but negatively in the constructor <code>c1</code> in the type argument <code>X -&gt; A</code>. Therefore, <code>X</code> is not strictly positive.</p> <p>Positive parameters can also be described as those that do not occur in negative positions. For instance, the type <code>B</code> in the <code>c0</code> constructor above appears to the left of the arrow <code>B-&gt;X</code>, placing <code>B</code> in a negative position. It is essential to consider negative parameters when verifying strictly positive data types, as they might enable the definition of non-strictly positive data types.</p> <p>Let us consider another example:</p> <pre><code>  type T0 (A : Type) :=\n    | c0 : (A -&gt; T0 A) -&gt; T0 A;\n\n  positive\n</code></pre> <pre><code>  type T1 :=\n    | c1 : T0 T1 -&gt; T1;\n</code></pre> <p>In this example, the type <code>T0</code> is strictly positive, while the type <code>T1</code> is not. It is only after unfolding the type application <code>T0 (T1 A)</code> in the data constructor <code>c1</code> that we can determine <code>T1</code> occurs in a negative position due to <code>T0</code>. More specifically, the type parameter <code>A</code> of <code>T0</code> is negative.</p>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/#bypassing-the-strict-positivity-condition","title":"Bypassing the Strict Positivity Condition","text":"<p>To bypass the positivity check in a data type declaration, you can annotate it with the <code>positive</code> keyword. Alternatively, you can use the CLI global flag <code>--no-positivity</code> when type checking a <code>Juvix</code> file.</p> <pre><code>module E5;\n  positive\n  type T0 (A : Type) :=\n    | c0 : (T0 A -&gt; A) -&gt; T0 A;\nend;\n\n</code></pre>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/#examples-of-non-strictly-positive-data-types","title":"Examples of Non-Strictly Positive Data Types","text":"<ul> <li>The <code>Bad</code> data type is not strictly positive due to the negative parameter <code>A</code>   of <code>Tree</code>.</li> </ul> <pre><code>  type Tree (A : Type) :=\n    | leaf : Tree A\n    | node : (A -&gt; Tree A) -&gt; Tree A;\n\n  positive\n</code></pre> <pre><code>  type Bad :=\n    | bad : Tree Bad -&gt; Bad;\n\n  positive\n</code></pre> <ul> <li><code>A</code> is a negative parameter.</li> </ul> <pre><code>  type B (A : Type) :=\n    | b : (A -&gt; B (B A -&gt; A)) -&gt; B A;\n</code></pre>"},{"location":"explanations/typetheory/","title":"Type theory","text":""},{"location":"explanations/totality/coverage/","title":"Coverage checking","text":""},{"location":"explanations/totality/positive/","title":"Strictly positive data types","text":""},{"location":"explanations/totality/termination/","title":"Termination","text":"<p>To prevent inconsistencies arising from function declarations, Juvix mandates that every function passes its termination checker. Nevertheless, this requirement can be challenging to meet; thus, we provide users with two distinct methods for bypassing this check:</p>"},{"location":"explanations/totality/termination/#keyword","title":"Keyword","text":"<p>Utilize the terminating keyword to annotate function type signatures as terminating. In the following example we mark the function <code>fun</code> as terminating.</p> <pre><code>terminating\nfun : A \u2192 B;\n</code></pre> <p>Note</p> <p>Annotating a function with the <code>terminating</code> keyword indicates that all of its function clauses meet the termination checker's criteria. For mutual recursive functions, to bypass the termination checker, all involved functions must be annotated as <code>terminating</code>.</p>"},{"location":"explanations/totality/termination/#cli-flag","title":"CLI flag","text":"<p>Utilizing the global CLI flag --no-termination.</p> <pre><code>juvix typecheck --no-termination MyProgram.juvix\n</code></pre> <p>Note</p> <p>Please note that our termination checker has certain limitations, as it only accepts a subset of recursive functions. The algorithm used in the termination checker is a minor adaptation of the one employed for checking termination in the Foetus language.</p>"},{"location":"howto/compilation/","title":"Compiling simple programs","text":"<p>A Juvix file must declare a module whose name corresponds exactly to the name of the file. For example, a file <code>Hello.juvix</code> must declare a module <code>Hello</code>:</p> <pre><code>-- Hello world example. This is a comment.\nmodule Hello;\n\n-- Import the standard library prelude, including the 'String' type\nopen import Stdlib.Prelude;\n\nmain : String;\nmain := \"Hello world!\";\n</code></pre> <p>A file compiled to an executable must define the zero-argument function <code>main</code> of type <code>IO</code> which is evaluated when running the program.</p> <p>To compile the file <code>Hello.juvix</code> type <code>juvix compile Hello.juvix</code>. Typing <code>juvix compile --help</code> will list all options to the <code>compile</code> command.</p>"},{"location":"howto/compilation/#compilation-targets","title":"Compilation targets","text":"<p>Since version 0.3 Juvix supports three compilation targets. The targets are specified with the <code>-t</code> option: <code>juvix compile -t target file.juvix</code>.</p> <ol> <li><code>native</code>. This is the default. Produces a native 64bit executable     for your machine.</li> <li><code>wasm32-wasi</code>. Produces a WebAssembly binary which uses the WASI     runtime.</li> <li><code>geb</code>. Produces a GEB input file.</li> </ol>"},{"location":"howto/compilation/#compilation-options","title":"Compilation options","text":"<p>To see all compilation options type <code>juvix compile --help</code>. The most commonly used options are:</p> <ul> <li><code>-t target</code>: specify the target,</li> <li><code>-g</code>: generate debug information and runtime assertions,</li> <li><code>-o file</code>: specify the output file.</li> </ul>"},{"location":"howto/compilation/#juvix-projects","title":"Juvix projects","text":"<p>A Juvix project is a collection of Juvix modules inside one main project directory containing a <code>juvix.yaml</code> metadata file. The name of each module must coincide with the path of the file it is defined in, relative to the project's root directory. For example, if the file is <code>root/Data/List.juvix</code> then the module must be called <code>Data.List</code>, assuming <code>root</code> is the project's directory.</p> <p>To interactively initialize a Juvix project in the current directory, use <code>juvix init</code>.</p> <p>To check that Juvix is correctly detecting your project's root, you can run the command <code>juvix dev root File.juvix</code>.</p> <p>See also: Modules Reference.</p>"},{"location":"howto/installing/","title":"Dependencies","text":"<p>You need Clang / LLVM version 13 or later. Note that on macOS the preinstalled clang does not support the wasm target, so use e.g. <code>brew install llvm</code> instead.</p> <p>If you want to compile to WebAssembly, you also need:</p> <ul> <li>wasmer</li> <li>wasi-sdk</li> <li>wasm-ld - the LLVM linker for WASM (NB: On   Linux you may need to install the <code>lld</code> package; on macOS this is   installed as part of <code>llvm</code>).</li> </ul> <p>See below for instructions on how to install the dependencies.</p>"},{"location":"howto/installing/#installing-juvix","title":"Installing Juvix","text":""},{"location":"howto/installing/#macos","title":"MacOS","text":"<p>The easiest way to install Juvix on MacOS is by using Homebrew.</p> <p>To install the homebrew-juvix tap, run:</p> <pre><code>brew tap anoma/juvix\n</code></pre> <p>To install Juvix, run:</p> <pre><code>brew install juvix\n</code></pre> <p>Helpful information can also be obtained by running:</p> <pre><code>brew info juvix\n</code></pre>"},{"location":"howto/installing/#linux-x8664","title":"Linux x86<sub>64</sub>","text":"<p>A Juvix compiler binary executable for Linux x86<sub>64</sub> is available on the Juvix release page.</p> <p>To install this executable, download and unzip the linked file and move it to a directory on your shell's <code>PATH</code>.</p> <p>For example if <code>~/.local/bin</code> is on your shell's <code>PATH</code>, you can install Juvix as follows:</p> <pre><code>cd /tmp\ncurl -OL https://github.com/anoma/juvix/releases/download/v0.3.1/juvix-linux_x86_64-v0.3.1.zip\nunzip juvix-linux_x86_64-v0.3.1.zip\nmv juvix-linux_x86_64-v0.3.1 ~/.local/bin/juvix\n</code></pre>"},{"location":"howto/installing/#building-juvix-from-source","title":"Building Juvix from source","text":"<p>To install Juvix from source you must clone the Github repository. Then Juvix can be installed with the following commands. We assume you have Stack and GNU Make installed.</p> <pre><code>git clone --recursive https://github.com/anoma/juvix.git\ncd juvix\nmake install\n</code></pre> <p>The C compiler and linker paths can be specified as options to the <code>make install</code> command, e.g.</p> <pre><code>make install CC=path/to/clang LIBTOOL=path/to/llvm-ar\n</code></pre> <p>On MacOS, you can alternatively run the following command for Homebrew. The flag <code>--HEAD</code> used below is optional \u2013 use it to build the latest version of Juvix in the <code>main</code> branch on Github.</p> <pre><code>brew install --build-from-source --HEAD juvix --verbose\n</code></pre>"},{"location":"howto/installing/#building-the-project-with-cabal","title":"Building the project with <code>cabal</code>","text":"<p>We recommend to use the <code>stack</code> build tool with this project.</p> <p>If you prefer the <code>cabal</code> build tool instead, then you need to generate the <code>juvix.cabal</code> file using hpack before running <code>cabal build</code>.</p> <p>You also need to compile the runtime first:</p> <pre><code>make runtime\ncabal build\n</code></pre>"},{"location":"howto/installing/#installing-dependencies","title":"Installing dependencies","text":"<p>To install <code>wasi-sdk</code> you need to download <code>libclang_rt</code> and <code>wasi-sysroot</code> precompiled archives from the wasi-sdk release page and:</p> <ol> <li> <p>Extract the <code>libclang_rt.builtins-wasm32-wasi-*.tar.gz</code> archive in     the <code>clang</code> installation root (for example <code>/usr/lib/clang/13</code> on     Ubuntu or <code>`brew --prefix llvm`</code> on macos).</p> <p>For example on macos with homebrew clang:</p> <p><code>shell cd `brew --prefix llvm` curl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/libclang_rt.builtins-wasm32-wasi-15.0.tar.gz -OL tar xf libclang_rt.builtins-wasm32-wasi-15.0.tar.gz</code></p> </li> <li> <p>Extract the <code>wasi-sysroot-*.tar.gz</code> archive on your local system and     set <code>WASI_SYSROOT_PATH</code> to its path.</p> <p>For example:</p> <p><code>shell cd ~ curl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/wasi-sysroot-15.0.tar.gz -OL tar xf wasi-sysroot-15.0.tar.gz export WASI_SYSROOT_PATH=~/wasi-sysroot</code></p> </li> </ol>"},{"location":"howto/judoc/","title":"Documenting Juvix programs with Judoc","text":""},{"location":"notes/lsp/","title":"LSP support","text":"<p>We provide a sample <code>hie.yaml</code> configuration file for both <code>cabal</code> and <code>stack</code>.</p> <p>If you prefer <code>stack</code>, run:</p> <pre><code>cp stack.hie.yaml hie.yaml\n</code></pre> <p>If you prefer <code>cabal</code>, run:</p> <pre><code>cp cabal.hie.yaml hie.yaml\n</code></pre>"},{"location":"notes/runtime-benchmark-results/","title":"Benchmarks of the new Juvix runtime","text":"<p>Benchmarked version: commit 148ececb4d4259eacbb980f5992073a3ac611d82 from 31.10.2022</p>"},{"location":"notes/runtime-benchmark-results/#summary","title":"Summary","text":"<p>We benchmark several programs manually compiled into the primitives of the new Juvix runtime. The code corresponds closely to the code that will be generated by the new compilation process, with basic low-level optimisations (unboxing, untagging, etc.) but without any high-level optimisations on JuvixCore (inlining, specialisation, constant folding, fusion, etc.). This corresponds to the compilation process planned for the 0.4 milestone.</p> <p>We compare the running time and memory usage with analogous programs written in Haskell, OCaml, JuvixCore (using the evaluator), current Juvix (with the \"direct\" transpilation to C) and C.</p> <p>The results suggest that for most first-order programs the new compilation process will produce code with running time comparable to the code produced by the native OCaml compiler. For higher-order programs heavy on closure manipulation, the results are acceptable but noticeably worse, especially with third-order functions (i.e. functions which take functions taking functions). This could, however, be alleviated by implementing the specialisation optimisation (see the \"specialised\" column in the `ackermann` and `mapfun` benchmarks). Besides, functional programs of order higher than two are rare.</p> <p>The comparisons with OCaml and Haskell were not entirely fair because the new Juvix runtime does not perform garbage collection. The overhead of garbage collection is particularly visible on the `mergesort` benchmark which creates many intermediate data structures that are quickly discarded. With proper memory management, the running time results on first-order programs for the new Juvix runtime are expected to become slightly worse than for the native OCaml compiler.</p> <p>For simple programs operating on integers which don't require any heap memory allocation (`fibonacci` and `combinations` benchmarks), the direct transpilation to C in the current Juvix seems to perform best (behind only C). The reason is that for very simple programs `clang` can better optimise the output of such a direct transpiler. The main problem with the transpilation to C approach is that it cannot scale to reliably work for more complex programs, as evidenced by the segfaults, longer running time and higher memory use on other benchmarks.</p> <p>In addition to the `fibonacci` and `combinations` benchmarks, the advantage of direct transpilation for very simple programs is also visible on the `fold` benchmark where a simple loop over a list dominates the running time. However, this is partly because the compilation of closures in current Juvix is incorrect allowing it to be more efficient.</p>"},{"location":"notes/runtime-benchmark-results/#benchmark-programs","title":"Benchmark programs","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci-compute-the-nth-fibonacci-number-modulo-228-n-100000000","title":"fibonacci: compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)","text":"<p>The Nth Fibonacci number is computed in O(N). Needs only constant stack space and no heap memory. This benchmark tests the efficiency of tail recursion and arithmetic operations.</p>"},{"location":"notes/runtime-benchmark-results/#combinations-count-combinations-of-numbers-1-to-n-having-sum-n-n-100","title":"combinations: count combinations of numbers 1 to N having sum N (N = 100)","text":"<p>This benchmark tests the efficiency of general recursion. No heap memory needs to be allocated. Uses stack space proportional to N. The running time is exponential in N.</p>"},{"location":"notes/runtime-benchmark-results/#prime-compute-the-nth-prime-n-16384","title":"prime: compute the Nth prime (N = 16384)","text":"<p>The Nth prime number is computed via the Eratosthenes sieve. A list of N primes is created. No intermediate lists are discarded (garbage collection not needed). This benchmark tests the efficiency of tail recursion, arithmetic operations, list cell allocation and access.</p>"},{"location":"notes/runtime-benchmark-results/#mergesort-merge-sort-a-list-of-n-integers-n-2000000","title":"mergesort: merge sort a list of N integers (N = 2\u2019000\u2019000)","text":"<p>At each level of merge sort intermediate lists are created and discarded. The running time for this benchmark largely depends on the efficiency of memory management. Here one may observe the overhead of garbage collection or the memory blow-up if no garbage collection is used.</p>"},{"location":"notes/runtime-benchmark-results/#maybe-optionally-sum-n-integers-from-a-binary-tree-k-times-n-220-k-100","title":"maybe: optionally sum N integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)","text":"<p>If a fixed number k is encountered in the tree then the result is `Nothing`, otherwise it is `Just sum`. The computation is repeated for values of k from 0 to K. This tests the efficiency of handling optional values and data structure access.</p>"},{"location":"notes/runtime-benchmark-results/#fold-fold-a-list-of-n-integers-k-times-n-100000-k-1000","title":"fold: fold a list of N integers K times (N = 100\u2019000, K = 1000)","text":"<p>The sum of N natural numbers is computed via fold<sub>left</sub> (tail-recursive). The computation is repeated K times. The list is created only once, so that allocation time does not dominate. This benchmark tests the efficiency of closure call and list cell access.</p>"},{"location":"notes/runtime-benchmark-results/#cps-compute-the-nth-fibonacci-number-modulo-228-with-cps-n-100000000","title":"cps: compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)","text":"<p>The function computing the Nth Fibonacci number is written in continuation-passing style, tail-recursively calling a continuation supplied as an argument. This benchmark tests the efficiency of closure call and allocation.</p>"},{"location":"notes/runtime-benchmark-results/#mapfold-map-and-fold-a-list-of-n-integers-k-times-n-10000-k-10000","title":"mapfold: map and fold a list of N integers K times (N = 10000, K = 10000)","text":"<p>This benchmark tests the efficiency of standard higher-order functions on lists, closure call and memory management. The program allocates O(K) intermediate lists of length N which are quickly discarded.</p>"},{"location":"notes/runtime-benchmark-results/#ackermann-compute-ack3-n-with-the-higher-order-ackermann-function-definition-n-11","title":"ackermann: compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)","text":"<p>The higher-order Ackermann function definition iterates an iteration of function compositions. Hence, it uses a third-order invocation of an iteration function. This benchmark tests the efficiency of creating and calling second-order closures, and of partial application.</p>"},{"location":"notes/runtime-benchmark-results/#mapfun-successively-map-k-functions-to-a-list-of-n-integers-k-100-n-10000","title":"mapfun: successively map K functions to a list of N integers (K = 100, N = 10000)","text":"<p>The benchmark stores K second-order closures in a list, maps them successively to a list of K closures, and then successively maps the K closures from the result to a list of N integers. This benchmark tests the efficiency of manipulating closures and storing them in data structures.</p> <p>The benchmark programs can be found in `tests/benchmark` in the Juvix source directory.</p>"},{"location":"notes/runtime-benchmark-results/#methodology","title":"Methodology","text":"<p>For each program the total running time (elapsed real time) and memory use (maximum resident set size) were measured on an M1 iMac with no significant background activity. Averages of several runs were taken. The variance was negligible, unless indicated otherwise by providing a range.</p>"},{"location":"notes/runtime-benchmark-results/#results","title":"Results","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci-compute-the-nth-fibonacci-number-modulo-228-n-100000000_1","title":"fibonacci: compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.26 0.35 0.35 0.23 13.15 10.03 0.39 0.35 0.94 0.16 0.22 Memory use (MB, max RSS) 1.5 3.8 1.3 8.8 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#combinations-count-all-combinations-of-numbers-1-to-n-having-sum-n-n-1000","title":"combinations: count all combinations of numbers 1 to N having sum N (N = 1000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 6.67 11.25 3.22 5.1 441.71 5.48 5.48 6.53 41.08 2.69 4.80 Memory use (MB, max RSS) 1.5 3.9 1.3 8.9 22.3 9.6 9.6 1.7 1.9 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#prime-compute-the-nth-prime-n-16384_1","title":"prime: compute the Nth prime (N = 16384)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.52 1.91 segfault 3.09 167.04 3.85 3.85 1.68 14.82 0.12 0.13 Memory use (MB, max RSS) 1.7 4.0 segfault 9.3 24.4 9.8 9.6 2.2 2.2 1.4 4.0"},{"location":"notes/runtime-benchmark-results/#mergesort-merge-sort-a-list-of-n-integers-n-2000000_1","title":"mergesort: merge sort a list of N integers (N = 2\u2019000\u2019000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.40 0.31 3.55 1.32 22.45 2.86 2.90 1.95 3.52 0.15 0.15 Memory use (MB, max RSS) 1973.7 720.4 5046.7 2729.8 1728.9 253.6 253.6 172.6 343.1 24.4 26.8"},{"location":"notes/runtime-benchmark-results/#maybe-optionally-sum-n-non-zero-integers-from-a-binary-tree-k-times-n-220-k-100","title":"maybe: optionally sum N non-zero integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.64 3.29 1.57 22.75 5.58 0.59 0.30 3.57 0.27 0.50 Memory use (MB, max RSS) 1.6 3.8 2646.1 1320.9 22.4 5560.7 9.7 3.9 4.0 1.3 4.1"},{"location":"notes/runtime-benchmark-results/#fold-fold-a-list-of-n-integers-k-times-n-100000-k-1000_1","title":"fold: fold a list of N integers K times (N = 100\u2019000, K = 1000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.54 0.35 0.23 15.27 0.58 0.58 0.36 1.80 NA NA Memory use (MB, max RSS) 3.1 4.6 4.4 10.6 43.4 12.7 12.7 5.9 5.9 NA NA"},{"location":"notes/runtime-benchmark-results/#cps-compute-the-nth-fibonacci-number-modulo-228-with-cps-n-100000000_1","title":"cps: compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.43 0.52 1.56 stack overflow 20.22 10.04 0.39 0.35 1.60 0.16 0.25 Memory use (MB, max RSS) 1.5 3.9 1539.3 stack overflow 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfold-map-and-fold-a-list-of-n-integers-k-times-n-10000-k-10000_1","title":"mapfold: map and fold a list of N integers K times (N = 10000, K = 10000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.01 1.59 2.74 1.81 38.24 1.29 2.42 1.43 4.22 NA NA Memory use (MB, max RSS) 2154.5 893.0 3059.1 1542.0 26.4 10.6 10.7 7.5 10-20 NA NA"},{"location":"notes/runtime-benchmark-results/#ackermann-compute-ack3-n-with-the-higher-order-ackermann-function-definition-n-11_1","title":"ackermann: compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.92 1.21 0.30 0.65 segfault runtime error 11.71 0.87 0.47 0.54 1.35 0.00 0.14 Memory use (MB, max RSS) 2.6 4.1 2.3 3.9 segfault runtime error 23.3 13.6 9.6 2.0 3.6 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfun-successively-map-k-functions-to-a-list-of-n-integers-k-100-n-10000_1","title":"mapfun: successively map K functions to a list of N integers (K = 100, N = 10000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.27 1.04 0.39 0.46 segfault runtime error 4.18 1.85 0.95 0.19 0.68 NA NA Memory use (MB, max RSS) 3209.8 1229.7 21.8 13.2 segfault runtime error 33.0 13.6 11.6 5.3 7.9 NA NA <p>Comments</p>"},{"location":"notes/runtime-benchmark-results/#new-juvix-runtime-denotes-c-programs-written-using-the-primitives","title":"\"New Juvix runtime\" denotes C programs written using the primitives","text":"<p>of the new Juvix runtime. These programs were \"manually\" compiled from the corresponding Juvix/JuvixCore programs, according to the new Juvix compilation concept. They correspond closely to the code that will be generated by the basic version of the new compilation process, without any high-level optimisations (inlining, specialisation, fusion, constant folding) but with basic low-level memory representation optimisations (unboxing, untagging, etc). This version of the new compilation process should be finished with the 0.4 milestone.</p>"},{"location":"notes/runtime-benchmark-results/#the-specialised-column-for-new-juvix-runtime-denotes-a-version","title":"The \"specialised\" column for \"New Juvix runtime\" denotes a version","text":"<p>of the corresponding \"New Juvix runtime\" benchmark program for which specialisation of higher-order functions was manually performed (to simulate the effects of the high-level specialisation optimisation).</p>"},{"location":"notes/runtime-benchmark-results/#current-juvix-denotes-juvix-programs-compiled-with-the-current","title":"\"Current Juvix\" denotes Juvix programs compiled with the current","text":"<p>compilation process via a \"direct\" translation to C. For a fair comparison, all number operations were implemented using native binary C integers (exposed via `foreign` and `compile` blocks) without overflow check, instead of using the unary Nat from the standard library. For Haskell, we use the fixed-precision Int instead of the arbitrary-precision Integer.</p>"},{"location":"notes/runtime-benchmark-results/#for-the-simplest-benchmark-programs-without-heap-memory-allocation","title":"For the simplest benchmark programs without heap memory allocation","text":"<p>(e.g. `fibonacci`, `combinations`), the performance of \"Current Juvix\" is comparable to or better than that of \"New Juvix runtime\". This is because `clang` managed to eliminate (tail) recursion and optimise the code to essentially the same or better thing. The main problem with the current \"direct\" transpilation to C approach is that it cannot scale to reliably work for more complex programs. By \"more complex\" I mean larger program size, more functions, more complex patterns of recursion and/or the use of more functional programming features (including functional data structures). I don't mean higher computational complexity or more resource use.</p>"},{"location":"notes/runtime-benchmark-results/#the-segfaults-and-runtime-errors-for-current-juvix-are","title":"The segfaults and runtime errors for \"Current Juvix\" are","text":"<p>consequences of incorrectly generated code (current compilation of partial application is not entirely correct) or stack overflows (when `clang` didn't figure out how to eliminate tail recursion).</p>"},{"location":"notes/runtime-benchmark-results/#the-comparison-with-current-juvix-is-not-entirely-fair-for","title":"The comparison with \"Current Juvix\" is not entirely fair for","text":"<p>benchmarks that test the manipulation and calling of closures (e.g. `fold`). Current Juvix achieves good performance (when it doesn't segfault) at the expense of correctness: partial application is not compiled correctly and fixing this would require a fundamental change in closure representation.</p>"},{"location":"notes/runtime-benchmark-results/#the-comparison-with-haskell-and-ocaml-compilers-is-not-entirely","title":"The comparison with Haskell and OCaml compilers is not entirely","text":"<p>fair, because the new Juvix runtime does not perform garbage collection. With the GC overhead, I would expect the Juvix runtime results for native compilation of first-order programs to become a bit worse than the native OCaml versions. The GC overhead is particularly noticeable for the `mergesort` benchmark which creates many large intermediate lists. The memory usage of the Juvix runtime is much higher on this benchmark than the memory usage of OCaml or Haskell versions. The relatively small time difference between the OCaml native and bytecode versions of `mergesort` also indicates that GC accounts for a significant part of the running time.</p>"},{"location":"notes/runtime-benchmark-results/#another-small-overhead-will-be-introduced-by-bounds-checking-for","title":"Another small overhead will be introduced by bounds checking for","text":"<p>integer operations. Currently, the new Juvix runtime operates on unboxed 31-bit (or 63-bit) integers without checking for integer overflow.</p>"},{"location":"notes/runtime-benchmark-results/#if-we-decide-to-default-to-transparent-arbitrary-precision-integers","title":"If we decide to default to transparent arbitrary-precision integers,","text":"<p>then another small overhead will be introduced by the need to check the integer representation with each arithmetic operation.</p>"},{"location":"notes/runtime-benchmark-results/#admittedly-the-programs-were-deliberately-written-in-a-way-to-make","title":"Admittedly, the programs were deliberately written in a way to make","text":"<p>high-level optimisations unnecessary, except specialisation for higher-order functions (mostly in `ackermann` and `mapfun`). This also explains the good performance of the OCaml native compiler which doesn't do much high-level optimisation.</p>"},{"location":"notes/runtime-benchmark-results/#in-the-current-juvix-and-ocaml-version-of-mergesort-to-avoid","title":"In the \"Current Juvix\" and OCaml version of `mergesort`, to avoid","text":"<p>stack overflow the `merge` function was written tail-recursively with accumulator reversal at the end. This is not necessary for the new Juvix runtime, because the stack is dynamically extended when needed.</p>"},{"location":"notes/runtime-benchmark-results/#as-evidenced-by-the-combinations-benchmark-for-non-tail-recursive","title":"As evidenced by the `combinations` benchmark, for non-tail-recursive","text":"<p>direct calls our code performs worse than the code which uses the C / WebAssembly stack and function call mechanisms. However, in general it is impossible to directly use the C / WebAssembly stack and call mechanisms for a purely functional language. Since we dynamically allocate the stack segments when needed, stack overflow is impossible. This is convenient in an eager functional language. Otherwise, one needs to rewrite all functions operating on large data to use tail recursion. We pay for this convenience with a small overhead, which is the main reason for poorer performance on `combinations` where stack manipulation cost dominates.</p>"},{"location":"notes/runtime-benchmark-results/#haskells-laziness-seems-to-introduce-more-overhead-than-i","title":"Haskell's laziness seems to introduce more overhead than I","text":"<p>expected. This would explain the comparatively better performance of the native OCaml compiler. The problem is particularly stark when Haskell's strictness analysis fails for some reason, as in the `fibonacci` benchmark. The second \"Haskell\" column with the \"-XStrict\" flag for GHC indicates the version of the benchmark compiled with strictness as the default.</p>"},{"location":"notes/runtime-benchmark-results/#the-c-versions-of-the-programs-were-written-to-take-advantage-of-cs","title":"The C versions of the programs were written to take advantage of C's","text":"<p>imperative features, e.g., using arrays instead of lists, loops instead of recursion. No C versions are provided for some benchmarks designed to test specifically functional language features.</p>"},{"location":"notes/runtime-benchmark-results/#with-the-new-juvix-runtime-the-32-bit-webassembly-version-of","title":"With the new Juvix runtime, the 32-bit WebAssembly version of","text":"<p>`mergesort` is faster than the 64-bit native version because it needs roughly half as much memory (the word size is 4 bytes instead of 8). The difference is even starker between the WebAssembly and native versions of `mergesort` for \"Current Juvix\".</p>"},{"location":"notes/runtime-benchmark-results/#there-seems-to-be-a-memory-leak-in-the-juvixcore-evaluator-this-is","title":"There seems to be a memory leak in the JuvixCore evaluator. This is","text":"<p>what happens too often when one uses a lazy language.</p>"},{"location":"notes/runtime-benchmark-results/#haskell-also-leaks-memory-in-the-fibonacci-benchmark-despite-it","title":"Haskell also leaks memory in the Fibonacci benchmark, despite it","text":"<p>being a simple tail-recursive program. It seems strictness analysis didn't work.</p>"},{"location":"reference/benchmarks/","title":"Benchmarks","text":""},{"location":"reference/examples/","title":"Example programs","text":""},{"location":"reference/examples/#examples-of-programs-written-in-juvix","title":"Examples of programs written in Juvix","text":"<p>The following links are clickable versions of their corresponding Juvix programs. The HTML output is generated by running <code>juvix html --recursive FileName.juvix</code>.</p> <ul> <li>HelloWorld.juvix</li> <li>Fibonacci.juvix</li> <li>Hanoi.juvix</li> <li>PascalsTriangle.juvix</li> <li>Collatz.juvix</li> <li>TicTacToe.juvix</li> </ul> <p>The Juvix standard library contains common functions that can be used in Juvix programs.</p>"},{"location":"reference/judoc/","title":"Judoc syntax reference","text":"<p>Judoc is used to document parts of your code. You can attach Judoc blocks to the following entities:</p> <ol> <li>A module.</li> <li>A type definition.</li> <li>A constructor definition.</li> <li>A type signature of a function.</li> <li>An axiom definition.</li> </ol> <p>In order to attach documentation to any of these entities, write blocks of documentation before them:</p> <ol> <li>For modules:    <code>--- This module is cool    module Cool;    ..</code></li> <li>For type definitions:    <code>--- Unary representation of natural numbers    type Nat : Type :=      | --- Nullary constructor representing number 0        zero : Nat      | --- Unary constructor representing the successor of a natural number        suc : Nat -&gt; Nat;</code></li> <li>For type signatures (and likewise for axioms):</li> </ol> <p><code>--- The polymorphic identity function    id : {A : Type} -&gt; A -&gt; A;</code></p> <p>Next we define the syntax of Judoc blocks.</p>"},{"location":"reference/judoc/#block","title":"Block","text":"<p>A block can be one of these:</p> <ol> <li>A paragraph.</li> <li>An example.</li> </ol> <p>Blocks are separated by a line with only <code>---</code>. For instance, this is a sequence of two blocks:</p> <pre><code>--- First block\n---\n--- Second block\n</code></pre> <p>Note that the following is a single block since it lacks the <code>---</code> separator:</p> <pre><code>--- First block\n\n--- Still first block\n</code></pre>"},{"location":"reference/judoc/#paragraph","title":"Paragraph","text":"<p>A paragraph is a non-empty sequence of lines.</p> <p>For instance, the following is a paragraph with two lines:</p> <pre><code>--- First line\n--- Second line\n</code></pre> <p>Note that a rendered paragraph will have have no line breaks. If you want to have line breaks, you will need to split the paragraph. Hence, the paragraph above will be rendered as</p> <pre><code>First line Second line\n</code></pre>"},{"location":"reference/judoc/#line","title":"line","text":"<p>A line starts with <code>---</code> and is followed by a non-empty sequence of atoms.</p> <p>For instance, the following is a valid line:</p> <pre><code>--- A ;Pair Int Bool; contains an ;Int; and a ;Bool;\n</code></pre>"},{"location":"reference/judoc/#atom","title":"Atom","text":"<p>An atom is either:</p> <ol> <li>A string of text (including spaces but not line breaks).</li> <li>An inline Juvix expression surrounded by <code>;</code>.</li> </ol> <p>For instance, the following are valid atoms:</p> <ol> <li><code>I am some text.</code></li> <li><code>;Pair Int Bool;</code></li> </ol>"},{"location":"reference/judoc/#example","title":"Example","text":"<p>An example is of the following form</p> <pre><code>--- &gt;&gt;&gt; someExpression ;\n</code></pre> <p>The <code>someExpression</code> can span multiple lines and it must be ended with a <code>;</code>. For instance:</p> <pre><code>--- &gt;&gt;&gt; 1\n        + 2\n        + 3;\n</code></pre>"},{"location":"reference/stdlib/","title":"Standard library","text":"<p>The Juvix standard library contains common functions that can be used in Juvix programs.</p>"},{"location":"reference/language/axioms/","title":"Axiom","text":"<p>Axioms or postulates can be introduced by using the <code>axiom</code> keyword. For example, let us imagine one wants to write a program that assumes A is a type, and there exists a term x that inhabits A. Then the program would look like the following.</p> <pre><code>module Example;\naxiom\nA : Type;\n\naxiom\nx : A;\nend;\n</code></pre> <p>Terms introduced by the <code>axiom</code> keyword lack any computational content. Programs containing axioms not marked as builtins cannot be compiled to most targets.</p>"},{"location":"reference/language/builtins/","title":"Built-ins","text":"<p>Juvix has support for the built-in natural type and a few functions that are compiled to efficient primitives.</p>"},{"location":"reference/language/builtins/#built-in-inductive-definitions","title":"Built-in inductive definitions.","text":"<pre><code>builtin nat\ntype Nat :=\n  | zero : Nat\n  | suc : Nat \u2192 Nat;\n</code></pre>"},{"location":"reference/language/builtins/#builtin-function-definitions","title":"Builtin function definitions.","text":"<pre><code>infixl 6 +;\nbuiltin nat-plus\n+ : Nat \u2192 Nat \u2192 Nat;\n+ zero b := b;\n+ (suc a) b := suc (a + b);\n</code></pre>"},{"location":"reference/language/builtins/#builtin-axiom-definitions","title":"Builtin axiom definitions.","text":"<pre><code>builtin nat-print\naxiom printNat : Nat \u2192 Action;\n</code></pre>"},{"location":"reference/language/comments/","title":"Comments","text":"<p>Comments follow the same syntax as in <code>Haskell</code> and <code>Agda</code>. Be aware, Juvix has no support for nested comments.</p> <ul> <li>Inline Comment</li> </ul> <pre><code>    -- This is a comment!\n</code></pre> <ul> <li>Region comment</li> </ul> <pre><code>    {-\n        This is a comment!\n    -}\n</code></pre>"},{"location":"reference/language/control/","title":"Control structures","text":""},{"location":"reference/language/control/#case","title":"Case","text":"<p>A case expression has the following syntax:</p> <pre><code>case value\n| pat1 := branch1\n..\n| patN := branchN\n</code></pre> <p>For example, one can evaluate the following expression in the REPL:</p> <pre><code>Stdlib.Prelude&gt; case 2 | zero := 0 | suc x := x | _ := 19\n1\n</code></pre>"},{"location":"reference/language/control/#lazy-builtins","title":"Lazy builtins","text":"<p>The standard library provides several builtin functions which are treated specially and evaluated lazily. These builtins must always be fully applied.</p> <ul> <li><code>if condition branch1 branch2</code>. First evaluates <code>condition</code>, if true   evaluates and returns <code>branch1</code>, otherwise evaluates and returns   <code>branch2</code>.</li> <li><code>a || b</code>. Lazy disjunction. First evaluates <code>a</code>, if true returns   true, otherwise evaluates and returns <code>b</code>.</li> <li><code>a &amp;&amp; b</code>. Lazy conjunction. First evaluates <code>a</code>, if false returns   false, otherwise evaluates and returns <code>b</code>.</li> <li><code>a &gt;&gt; b</code>. Sequences two IO actions. Lazy in the second argument.</li> </ul>"},{"location":"reference/language/datatypes/","title":"Data types","text":"<p>A data type declaration consists of:</p> <ul> <li>The <code>type</code> keyword,</li> <li>a unique name for the type,</li> <li>the <code>:=</code> symbol, and</li> <li>a non-empty list of constructor declarations (functions for   building the elements of the data type).</li> </ul> <p>The simplest data type is the <code>Unit</code> type with one constructor called <code>unit</code>.</p> <pre><code>type Unit := unit : Unit;\n</code></pre> <p>In the following example, we declare the type <code>Nat</code> \u2013 the unary representation of natural numbers. This type comes with two constructors: <code>zero</code> and <code>suc</code>. Example elements of type <code>Nat</code> are the number one represented by <code>suc zero</code>, the number two represented by <code>suc (suc zero)</code>, etc.</p> <pre><code>type Nat :=\n    zero : Nat\n  | suc : Nat -&gt; Nat;\n</code></pre> <p>Constructors can be used like normal functions or in patterns when defining functions by pattern matching. For example, here is a function adding two natural numbers:</p> <pre><code>infixl 6 +;\n+ : Nat -&gt; Nat -&gt; Nat;\n+ zero b := b;\n+ (suc a) b := suc (a + b);\n</code></pre> <p>A data type may have type parameters. A data type with a type parameter <code>A</code> is called polymorphic in <code>A</code>. A canonical example is the type <code>List</code> polymorphic in the type of list elements.</p> <pre><code>infixr 5 ::;\ntype List (A : Type) :=\n    nil : List A\n  | :: : A -&gt; List A -&gt; List A;\n\nelem : {A : Type} -&gt; (A -&gt; A -&gt; Bool) -&gt; A -&gt; List A -&gt; Bool;\nelem _ _ nil := false;\nelem eq s (x :: xs) := eq s x || elem eq s xs;\n</code></pre> <p>For more examples of inductive types and how to use them, see the Juvix standard library.</p>"},{"location":"reference/language/functions/","title":"Function declarations","text":"<p>A function declaration consists of a type signature and a group of function clauses.</p> <p>In the following example, we define a function <code>multiplyByTwo</code>. The first line <code>multiplyByTwo : Nat -&gt; Nat;</code> is the type signature and the second line <code>multiplyByTwo n := 2 * n;</code> is a function clause.</p> <pre><code>open import Stdlib.Prelude;\n\nmultiplyByTwo : Nat -&gt; Nat;\nmultiplyByTwo n := 2 * n;\n</code></pre> <p>A function may have more than one function clause. When a function is called, the first clause that matches the arguments is used.</p> <p>The following function has two clauses.</p> <pre><code>open import Stdlib.Prelude;\n\nneg : Bool -&gt; Bool;\nneg true := false;\nneg false := true;\n</code></pre> <p>When <code>neg</code> is called with <code>true</code>, the first clause is used and the function returns <code>false</code>. Similarly, when <code>neg</code> is called with <code>false</code>, the second clause is used and the function returns <code>true</code>.</p>"},{"location":"reference/language/functions/#mutually-recursive-functions","title":"Mutually recursive functions","text":"<p>Function declarations can depend on each other recursively. In the following example, we define a function that checks if a number is <code>even</code> by calling a function that checks if a number is <code>odd</code>.</p> <pre><code>open import Stdlib.Prelude;\n\nodd : Nat -&gt; Bool;\neven : Nat -&gt; Bool;\n\nodd zero := false;\nodd (suc n) := even n;\n\neven zero := true;\neven (suc n) := odd n;\n</code></pre>"},{"location":"reference/language/functions/#anonymous-functions","title":"Anonymous functions","text":"<p>Anonymous functions, or lambdas, are introduced with the syntax:</p> <pre><code>\\{| pat1 .. patN_1 := clause1\n  | ..\n  | pat1 .. patN_M := clauseM}\n</code></pre> <p>The first pipe <code>|</code> is optional. Instead of <code>\\</code> one can also use <code>\u03bb</code>.</p> <p>An anonymous function just lists all clauses of a function without naming it. Any function declaration can be converted to use anonymous functions:</p> <pre><code>open import Stdlib.Prelude;\n\nodd : Nat -&gt; Bool;\neven : Nat -&gt; Bool;\n\nodd := \\{\n  | zero := false\n  | (suc n) := even n\n};\n\neven := \\{\n  | zero := true\n  | (suc n) := odd n\n};\n</code></pre>"},{"location":"reference/language/functions/#short-definitions","title":"Short definitions","text":"<p>A function definition can be written in one line, with the body immediately following the signature:</p> <pre><code>multiplyByTwo : Nat -&gt; Nat := \\{n := 2 * n};\n</code></pre>"},{"location":"reference/language/let/","title":"Local definitions","text":"<p>Local definitions are introduced with the <code>let</code> construct.</p> <pre><code>sum : NList -&gt; Nat;\nsum lst :=\n  let\n    go : Nat -&gt; NList -&gt; Nat;\n    go acc nnil := acc;\n    go acc (ncons x xs) := go (acc + x) xs;\n  in\n  go 0 lst;\n</code></pre> <p>The declaractions in a <code>let</code> have the same syntax as declarations inside a module, but they are visible only in the expression following the <code>in</code> keyword.</p>"},{"location":"reference/language/modules/","title":"Module system","text":""},{"location":"reference/language/modules/#defining-a-module","title":"Defining a module","text":"<p>The <code>module</code> keyword stars the declaration of a module followed by its name and body. The module declaration ends with the <code>end</code> keyword.</p> <pre><code>-- ModuleName.juvix\nmodule ModuleName;\n\nend;\n</code></pre> <p>A Juvix project is a collection of Juvix modules inside one main project folder containing a metadata file named <code>juvix.yaml</code>. Each Juvix file has to define a module of the same name. The name of the module must coincide with the path of its file relative to its project's root directory. For example, if the file is <code>root/Data/List.juvix</code> then the module must be called <code>Data.List</code>, assuming <code>root</code> is the project's folder.</p> <p>To check that Juvix is correctly detecting your project's root, one can run the command <code>juvix dev root File.juvix</code>.</p>"},{"location":"reference/language/modules/#importing-modules","title":"Importing modules","text":"<p>To bring into the current scope all module definitions from other external modules, one can use the <code>import</code> keyword along with the corresponding module name. This way, one gets all the imported names qualified.</p> <pre><code>-- A.juvix\nmodule A;\n   axiom\n   Nat : Type;\n\n   axiom\n   zero : Nat;\nend;\n\n-- B.juvix\nmodule B;\n    import A;\n    x : A.Nat;\n    x := A.zero;\n</code></pre> <p>Additionally, one can open an imported module making available all its names by their unqualified name.</p> <pre><code>-- A.juvix\nmodule A;\n   axiom\n   Nat : Type;\n\n   axiom\n   zero : Nat;\nend;\n\n-- B.juvix\nmodule B;\n    import A;\n    open A;\n    x : Nat;\n    x := zero;\nend;\n</code></pre> <p>However, opening modules may create name collisions if you already have the imported names as definitions in the current module. In this case, Juvix will complain with an error, letting you know which symbols are ambiguous. For example, in module <code>B</code> below, the name <code>a</code> is ambiguous.</p> <pre><code>-- A.juvix\nmodule A;\naxiom\nA : Type;\n\naxiom\na : A;\nend;\n\n-- B.juvix\nmodule B;\n\nimport A;\nopen A;\n\naxiom\na : A;\n\nx := a;\nend;\n</code></pre> <p>One alternative here is hiding the name <code>a</code> as follows.</p> <pre><code>-- B.juvix\nmodule B;\nimport A;\nopen A hiding {a};\n\naxiom\na : A;\n\n\nx := a;\n\nend;\n</code></pre> <p>Now, we can use the <code>open import</code> syntax to simplify the <code>import-open</code> statements.</p> <p>Instead of having:</p> <pre><code>import Prelude;\nopen Prelude;\n</code></pre> <p>We simplify it by the expression:</p> <pre><code>open import Prelude;\n</code></pre> <p>The <code>hiding</code> keyword can be used within an <code>open-import</code> statement.</p> <pre><code>-- B.juvix\nmodule A;\nopen import A hiding {a};\n\naxiom\na : A;\n\nx := a;\nend;\n</code></pre>"},{"location":"reference/language/modules/#exporting-symbols","title":"Exporting symbols","text":"<p>The module <code>C</code> below does not typecheck. Both symbols, originally defined in module <code>A</code>, are not visible in module <code>C</code> after importing <code>B</code>. The symbols <code>A</code> and <code>a</code> are not exported by the module <code>B</code>. To export symbols from an imported module, one can use the <code>public</code> keyword at the end of the corresponding <code>open</code> statement. For example, the module <code>C</code> typechecks after marking the import of <code>A</code> as <code>public</code> in module <code>B</code>.</p> <pre><code>-- A.juvix\nmodule A;\naxiom\nA : Type;\n\naxiom\na : A;\n\nend;\n\n-- B.juvix\nmodule B;\nopen import A;\nend;\n\n-- C.juvix\nmodule C;\nopen import B;\n\nx : A;\nx := a;\nend;\n</code></pre> <p>Fix:</p> <pre><code>-- B.juvix\nmodule B;\nopen import A public;\nend;\n</code></pre>"},{"location":"reference/tooling/CLI/","title":"CLI","text":""},{"location":"reference/tooling/CLI/#usage","title":"Usage","text":"<pre><code>juvix [Global options] ((-v|--version) | (-h|--help) | COMPILER_CMD | UTILITY_CMD)\n</code></pre>"},{"location":"reference/tooling/CLI/#informative-options","title":"Informative options","text":"<ul> <li><code>-v,--version</code> Print the version and exit</li> <li><code>-h,--help</code> Show this help text</li> </ul>"},{"location":"reference/tooling/CLI/#global-command-flags","title":"Global Command flags","text":"<ul> <li><code>--no-colors</code> Disable globally ANSI formatting</li> <li><code>--show-name-ids</code> Show the unique number of each identifier when   pretty printing</li> <li><code>--only-errors</code> Only print errors in a uniform format (used by   juvix-mode)</li> <li><code>--no-termination</code> Disable termination checking</li> <li><code>--no-positivity</code> Disable positivity checking for inductive types</li> <li><code>--no-stdlib</code> Do not use the standard library</li> </ul>"},{"location":"reference/tooling/CLI/#main-commands","title":"Main Commands","text":"<ul> <li><code>html</code> Generate HTML output from a Juvix file</li> <li><code>typecheck</code> Typecheck a Juvix file</li> <li><code>compile</code> Compile a Juvix file</li> </ul>"},{"location":"reference/tooling/CLI/#utility-commands","title":"Utility Commands","text":"<ul> <li><code>doctor</code> Perform checks on your Juvix development environment</li> <li><code>init</code> Interactively initialize a Juvix project in the current   directory</li> </ul>"},{"location":"reference/tooling/CLI/#dev-commands","title":"Dev Commands","text":"<pre><code>juvix dev COMMAND\n</code></pre> <ul> <li><code>parse</code> Parse a Juvix file</li> <li><code>scope</code> Parse and scope a Juvix file</li> <li><code>highlight</code> Highlight a Juvix file</li> <li><code>core</code> Subcommands related to JuvixCore</li> <li><code>asm</code> Subcommands related to JuvixAsm</li> <li><code>root</code> Show the root path for a Juvix project</li> <li><code>termination</code> Subcommands related to termination checking</li> <li><code>internal</code> Subcommands related to Internal</li> <li><code>minic</code> Translate a Juvix file to a subset of C</li> </ul>"},{"location":"reference/tooling/CLI/#cli-auto-completion-scripts","title":"CLI Auto-completion Scripts","text":"<p>The Juvix CLI can generate auto-completion scripts. Follow the instructions below for your shell.</p> <p>NB: You may need to restart your shell after installing the completion script.</p>"},{"location":"reference/tooling/CLI/#bash","title":"Bash","text":"<p>Add the following line to your bash init script (for example <code>~/.bashrc</code>).</p> <pre><code>eval \"$(juvix --bash-completion-script juvix)\"\n</code></pre>"},{"location":"reference/tooling/CLI/#fish","title":"Fish","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --fish-completion-script juvix\n  &gt; ~/.config/fish/completions/juvix.fish\n</code></pre>"},{"location":"reference/tooling/CLI/#zsh","title":"ZSH","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --zsh-completion-script juvix &gt; $DIR_IN_FPATH/_juvix\n</code></pre> <p>where <code>$DIR_IN_FPATH</code> is a directory that is present on the ZSH FPATH variable (which you can inspect by running <code>echo $FPATH</code> in the shell).</p>"},{"location":"reference/tooling/doctor/","title":"Juvix Doctor","text":"<p>The <code>juvix doctor</code> command can help you to troubleshoot problems with your development environment. For each problem the doctor finds they'll be a link to a section on this page to help you fix it.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-clang-command","title":"Could not find the clang command","text":"<p>The Juvix compiler uses the Clang compiler version 13 or later to generate binaries. You need to have Clang available on your system <code>$PATH</code>.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos","title":"MacOS","text":"<p>Use Homebrew:</p> <pre><code>brew install llvm\n</code></pre> <p>NB: The distribution of Clang that comes with XCode does not support the <code>Wasm</code> target so you must install the standard Clang distribution.</p>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install clang lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S llvm lld\n</code></pre>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasm-ld-command","title":"Could not find the wasm-ld command","text":"<p>The Juvix compiler required <code>wasm-ld</code> (the Wasm linker) to produce <code>Wasm</code> binaries.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos_1","title":"MacOS","text":"<p><code>wasm-ld</code> is included in the Homebrew llvm distribution:</p> <pre><code>brew install llvm\n</code></pre>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux_1","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux_1","title":"Arch Linux","text":"<pre><code>sudo pacman -S lld\n</code></pre>"},{"location":"reference/tooling/doctor/#newer-clang-version-required","title":"Newer Clang version required","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-target","title":"Clang does not support the wasm32 target","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-wasi-target","title":"Clang does not support the wasm32-wasi target","text":"<p>Juvix uses WASI - The Wasm System Interface to produce binaries that can be executed using a Wasm runtime. The files necessary to setup Clang with <code>wasm32-wasi</code> support are available at wasi-sdk.</p> <p>To install the <code>wasm32-wasi</code> target for Clang you need to do two things:</p>"},{"location":"reference/tooling/doctor/#install-libclang_rtbuiltins-wasm32a-into-your-clang-distribution","title":"Install <code>libclang_rt.builtins-wasm32.a</code> into your Clang distribution","text":"<ol> <li> <p>Obtain <code>libclang_rt.builtins-wasm32-wasi-16.0.tar.gz</code> from the     wasi-sdk     releases page.</p> </li> <li> <p>Untar the file and place the file     <code>lib/wasi/libclang_rt.builtins-wasm32.a</code> into your Clang     distribution directory.</p> <p>On MacOS, if you installed llvm using homebrew you can find the Clang distribution directory using <code>brew --prefix llvm</code>. You should then place the builtins file at <code>`brew --prefix llvm`/lib/wasi/libclang_rt.builtins-wasm32.a</code>.</p> <p>On Linux the Clang distribution directory will be something like <code>/usr/lib/clang/13.0.1</code> where <code>13.0.1</code> is the version of Clang that you have installed. You should then place the builtins file at <code>/usr/lib/clang/13.0.1/lib/wasi/libclang_rt.builtins-wasm32</code>.</p> </li> </ol>"},{"location":"reference/tooling/doctor/#download-the-wasi-sysroot-and-set-wasi_sysroot_path","title":"Download the WASI sysroot and set <code>WASI_SYSROOT_PATH</code>","text":"<ol> <li>Obtain <code>wasi-sysroot-16.0.tar.gz</code> from the wasi-sdk     releases page.</li> <li>Untar the file and set the environment variable <code>WASI_SYSROOT_PATH</code>     to that location.</li> </ol>"},{"location":"reference/tooling/doctor/#environment-variable-wasi_sysroot_path-is-not-set","title":"Environment variable <code>WASI_SYSROOT_PATH</code> is not set","text":"<p>Set the <code>WASI_SYSROOT_PATH</code> to the directory where you installed the <code>wasi-sdk</code> sysroot files. See installing the WASI sysroot.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasmer-command","title":"Could not find the wasmer command","text":"<p>The Juvix test suite uses Wasmer as a Wasm runtime to execute compiled Wasm binaries. See the Wasmer documentation to see how to install it.</p>"},{"location":"reference/tooling/emacs/","title":"Emacs mode","text":""},{"location":"reference/tooling/emacs/#emacs-mode","title":"Emacs Mode","text":"<p>There is an Emacs mode available for Juvix. Currently, it supports syntax highlighting for well-scoped modules.</p> <p>To get started, clone the Juvix Emacs mode repository:</p> <pre><code>git clone https://github.com/anoma/juvix-mode.git\n</code></pre> <p>To install it add the following lines to your Emacs configuration file:</p> <pre><code>(push \"/path/to/juvix-mode/\" load-path)\n(require 'juvix-mode)\n</code></pre> <p>Make sure that Juvix is installed in your <code>PATH</code>.</p> <p>The Juvix major mode will be activated automatically for <code>.juvix</code> files.</p>"},{"location":"reference/tooling/emacs/#keybindings","title":"Keybindings","text":"Key Function Name Description <code>C-c C-l</code> <code>juvix-load</code> Runs the scoper and adds semantic syntax highlighting <code>M-.</code> <code>juvix-goto-definition</code> Go to the definition of symbol at point <code>C-c C-f</code> <code>juvix-format-buffer</code> Format the current buffer"},{"location":"reference/tooling/emacs/#emacs-installation","title":"Emacs installation","text":"<p>Most Linux distributions contain an Emacs package which can be installed with your package manager (<code>sudo apt install emacs</code> on Ubuntu). On macOS, it is recommended to install Emacs Plus via Homebrew: <code>brew install emacs-plus</code>. Using the Emacs Homebrew casks is not recommended.</p>"},{"location":"reference/tooling/emacs/#common-problems","title":"Common problems","text":"<ul> <li>Error \"Symbol's value as variable is void: sh:1:\"</li> </ul> <p>Make sure the juvix executable is on the Emacs' <code>exec-path</code>. Note   that <code>exec-path</code> may be different from your shell's <code>PATH</code>. This is   particularly common on macOS with Emacs launched from GUI instead of   the terminal.</p> <p>The easiest way to resolve this issue is to install the   exec-path-from-shell   package (available on MELPA). Alternatively, one may set <code>exec-path</code>   to match shell <code>PATH</code> by following the instructions from   EmacsWiki.</p>"},{"location":"reference/tooling/testing/","title":"Testing","text":""},{"location":"reference/tooling/testing/#dependencies","title":"Dependencies","text":"<p>See Installing dependencies for instructions on how to setup the testing environment for the WASM compiler tests.</p>"},{"location":"reference/tooling/testing/#running","title":"Running","text":"<p>Run tests using:</p> <pre><code>stack test\n</code></pre> <p>To run tests, ignoring all the WASM tests:</p> <pre><code>stack test --ta '-p \"! /slow tests/\"'\n</code></pre>"},{"location":"tutorials/emacs/","title":"Juvix Emacs mode tutorial","text":"<p>First, follow the instructions in the Emacs Mode Reference to install the Juvix Emacs mode. Once you've successfully set it up, create a file <code>Hello.juvix</code> with the following content.</p> <pre><code></code></pre> <p>Type Ctrl+C+Ctrl+L to run the scoper and highlight the syntax.</p> <p>If you make a mistake in your program, it is automatically underlined in red with the error message popping up when you hover the mouse pointer over the underlined part.</p> <p>For example, in the following program the identifier <code>printStringLna</code> should be underlined with the error message \"Symbol not in scope\".</p> <pre><code>module Hello;\n\nopen import Stdlib.Prelude;\n\nmain : IO;\nmain := printStringLna \"Hello world!\";\n\nend;\n</code></pre> <p>If error underlining doesn't work, make sure you have the <code>flycheck</code> mode turned on. It should be turned on automatically when loading <code>juvix-mode</code>, but in case this doesn't work you can enable it with <code>M-x flycheck-mode</code>.</p> <p>Let's extend our program with another definition.</p> <pre><code>module Hello;\n\nopen import Stdlib.Prelude;\n\nprint : IO;\nprint := printStringLn \"Hello world!\";\n\nmain : IO;\nmain := print;\n\nend;\n</code></pre> <p>Place the cursor on the <code>print</code> call in the function clause of <code>main</code> and press <code>M-.</code>. The cursor will jump to the definition of <code>print</code> above. This also works across files and for definitions from the standard library. You can try using <code>M-.</code> to jump to the definition of <code>printStringLn</code>.</p> <p>One more feature of the Juvix Emacs mode is code formatting. To format the content of the current buffer, type Ctrl+C+Ctrl+F. Here is the result.</p> <pre><code>module Hello;\n  open import Stdlib.Prelude;\n\n  print : IO;\n  print := printStringLn \"Hello world!\";\n\n  main : IO;\n  main := print;\nend;\n</code></pre>"},{"location":"tutorials/learn/","title":"Juvix tutorial","text":""},{"location":"tutorials/learn/#juvix-repl","title":"Juvix REPL","text":"<p>After installing Juvix, launch the Juvix REPL:</p> <pre><code>juvix repl\n</code></pre> <p>The response should be similar to:</p> <pre><code>Juvix REPL version 0.3: https://juvix.org. Run :help for help\nOK loaded: ./.juvix-build/stdlib/Stdlib/Prelude.juvix\nStdlib.Prelude&gt;\n</code></pre> <p>Currently, the REPL supports evaluating expressions but it does not yet support adding new definitions. To see the list of available REPL commands type <code>:help</code>.</p>"},{"location":"tutorials/learn/#basic-expressions","title":"Basic expressions","text":"<p>You can try evaluating simple arithmetic expressions in the REPL:</p> <pre><code>Stdlib.Prelude&gt; 3 + 4\n7\nStdlib.Prelude&gt; 1 + 3 * 7\n22\nStdlib.Prelude&gt; div 35 4\n8\nStdlib.Prelude&gt; mod 35 4\n3\nStdlib.Prelude&gt; sub 35 4\n31\nStdlib.Prelude&gt; sub 4 35\n0\n</code></pre> <p>By default, Juvix operates on non-negative natural numbers. Natural number subtraction is implemented by the function <code>sub</code>. Subtracting a bigger natural number from a smaller one yields <code>0</code>.</p> <p>You can also try boolean expressions</p> <pre><code>Stdlib.Prelude&gt; true\ntrue\nStdlib.Prelude&gt; not true\nfalse\nStdlib.Prelude&gt; true &amp;&amp; false\nfalse\nStdlib.Prelude&gt; true || false\ntrue\nStdlib.Prelude&gt; if true 1 0\n1\n</code></pre> <p>and strings, pairs and lists:</p> <pre><code>Stdlib.Prelude&gt; \"Hello world!\"\n\"Hello world!\"\nStdlib.Prelude&gt; (1, 2)\n(1, 2)\nStdlib.Prelude&gt; 1 :: 2 :: nil\n1 :: 2 :: nil\n</code></pre> <p>In fact, you can use all functions and types from the Stdlib.Prelude module of the standard library, which is preloaded by default.</p> <pre><code>Stdlib.Prelude&gt; length (1 :: 2 :: nil)\n3\nStdlib.Prelude&gt; null (1 :: 2 :: nil)\nfalse\nStdlib.Prelude&gt; swap (1, 2)\n(2, 1)\n</code></pre>"},{"location":"tutorials/learn/#files-modules-and-compilation","title":"Files, modules and compilation","text":"<p>Currently, the REPL does not support adding new definitions. To define new functions or data types, you need to put them in a separate file and either load the file in the REPL with <code>:load file.juvix</code> or compile the file to a binary executable with the shell command <code>juvix compile file.juvix</code>.</p> <p>To conveniently edit Juvix files, an Emacs mode and a VSCode extension are available.</p> <p>A Juvix file must declare a module whose name corresponds exactly to the name of the file. For example, a file <code>Hello.juvix</code> must declare a module <code>Hello</code>:</p> <pre><code>-- Hello world example. This is a comment.\nmodule Hello;\n  -- Import the standard library prelude, including the 'String' type\n  open import Stdlib.Prelude;\n\n  main : String;\n  main := \"Hello world!\";\nend;\n</code></pre> <p>A file compiled to an executable must define the zero-argument function <code>main</code> which is evaluated when running the program. The definition of <code>main</code> can have any non-function type, e.g., <code>String</code>, <code>Bool</code> or <code>Nat</code>. The generated executable prints the result of evaluating <code>main</code>.</p>"},{"location":"tutorials/learn/#data-types-and-functions","title":"Data types and functions","text":"<p>To see the type of an expression, use the <code>:type</code> REPL command:</p> <pre><code>Stdlib.Prelude&gt; :type 1\nNat\nStdlib.Prelude&gt; :type true\nBool\n</code></pre> <p>The types <code>Nat</code> and <code>Bool</code> are defined in the standard library.</p> <p>The type <code>Bool</code> has two constructors <code>true</code> and <code>false</code>.</p> <pre><code>  type Bool :=\n    | true : Bool\n    | false : Bool;\n</code></pre> <p>The constructors of a data type can be used to build elements of the type. They can also appear as patterns in function definitions. For example, the <code>not</code> function is defined in the standard library by:</p> <pre><code>  not : Bool -&gt; Bool;\n  not true := false;\n  not false := true;\n</code></pre> <p>The first line is the signature which specifies the type of the definition. In this case, <code>not</code> is a function from <code>Bool</code> to <code>Bool</code>. The signature is followed by two function clauses which specify the function result depending on the shape of the arguments. When a function call is evaluated, the first clause that matches the arguments is used.</p> <p>In contrast to languages like Python, Java or C/C++, Juvix doesn't require parentheses for function calls. All the arguments are just listed after the function. The general pattern for function application is: <code>func arg1 arg2 arg3 ...</code></p> <p>A more complex example of a data type is the <code>Nat</code> type from the standard library:</p> <pre><code>  type Nat :=\n    | zero : Nat\n    | suc : Nat -&gt; Nat;\n</code></pre> <p>The constructor <code>zero</code> represents <code>0</code> and <code>suc</code> represents the successor function \u2013 <code>suc n</code> is the successor of <code>n</code>, i.e., <code>n+1</code>. For example, <code>suc zero</code> represents <code>1</code>. The number literals <code>0</code>, <code>1</code>, <code>2</code>, etc., are just shorthands for appropriate expressions built using <code>suc</code> and <code>zero</code>.</p> <p>The constructors of a data type specify how the elements of the type can be constructed. For instance, the above definition specifies that an element of <code>Nat</code> is either:</p> <ul> <li><code>zero</code>, or</li> <li><code>suc n</code> where <code>n</code> is an element of <code>Nat</code>, i.e., it is constructed by   applying <code>suc</code> to appropriate arguments (in this case the argument   of <code>suc</code> has type <code>Nat</code>).</li> </ul> <p>Any element of <code>Nat</code> can be built with the constructors in this way \u2013 there are no other elements. Mathematically, this is an inductive definition, which is why the data type is called inductive.</p> <p>If implemented directly, the above unary representation of natural numbers would be extremely inefficient. The Juvix compiler uses a binary number representation under the hood and implements arithmetic operations using corresponding machine instructions, so the performance of natural number arithmetic is similar to other programming languages. The <code>Nat</code> type is a high-level presentation of natural numbers as seen by the user who does not need to worry about low-level arithmetic implementation details.</p> <p>One can use <code>zero</code> and <code>suc</code> in pattern matching, like any other constructors:</p> <pre><code>  infixl 6 +;\n  + : Nat -&gt; Nat -&gt; Nat;\n  + zero b := b;\n  + (suc a) b := suc (a + b);\n</code></pre> <p>The <code>infixl 6 +</code> declares <code>+</code> to be an infix left-associative operator with priority 6. The <code>+</code> is an ordinary function, except that function application for <code>+</code> is written in infix notation. The definitions of the clauses of <code>+</code> still need the prefix notation on the left-hand sides.</p> <p>The <code>a</code> and <code>b</code> in the patterns on the left-hand sides of the clauses are variables which match arbitrary values of the corresponding type. They can be used on the right-hand side to refer to the values matched. For example, when evaluating</p> <pre><code>(suc (suc zero)) + zero\n</code></pre> <p>the second clause of <code>+</code> matches, assigning <code>suc zero</code> to <code>a</code> and <code>zero</code> to <code>b</code>. Then the right-hand side of the clause is evaluated with <code>a</code> and <code>b</code> substituted by these values:</p> <pre><code>suc (suc zero + zero)\n</code></pre> <p>Again, the second clause matches, now with both <code>a</code> and <code>b</code> being <code>zero</code>. After replacing with the right-hand side, we obtain:</p> <pre><code>suc (suc (zero + zero))\n</code></pre> <p>Now the first clause matches and finally we obtain the result</p> <pre><code>suc (suc zero)\n</code></pre> <p>which is just <code>2</code>.</p> <p>The function <code>+</code> is defined like above in the standard library, but the Juvix compiler treats it specially and generates efficient code using appropriate CPU instructions.</p>"},{"location":"tutorials/learn/#pattern-matching","title":"Pattern matching","text":"<p>The patterns in function clauses do not have to match on a single constructor \u2013 they may be arbitrarily deep. For example, here is an (inefficient) implementation of a function which checks whether a natural number is even:</p> <pre><code>  even : Nat -&gt; Bool;\n  even zero := true;\n  even (suc zero) := false;\n  even (suc (suc n)) := even n;\n</code></pre> <p>This definition states that a natural number <code>n</code> is even if either <code>n</code> is <code>zero</code> or, recursively, <code>n-2</code> is even.</p> <p>If a subpattern is to be ignored, then one can use a wildcard <code>_</code> instead of naming the subpattern.</p> <pre><code>  isPositive : Nat -&gt; Bool;\n  isPositive zero := false;\n  isPositive (suc _) := true;\n</code></pre> <p>The above function could also be written as:</p> <pre><code>    isPositive : Nat -&gt; Bool;\n    isPositive zero := false;\n    isPositive _ := true;\n</code></pre> <p>It is not necessary to define a separate function to perform pattern matching. One can use the <code>case</code> syntax to pattern match an expression directly.</p> <pre><code>Stdlib.Prelude&gt; case (1, 2)\n  | (suc _, zero) := 0\n  | (suc _, suc x) := x\n  | _ := 19\n1\n</code></pre>"},{"location":"tutorials/learn/#comparisons-and-conditionals","title":"Comparisons and conditionals","text":"<p>To use the comparison operators on natural numbers, one needs to import the <code>Stdlib.Data.Nat.Ord</code> module. The comparison operators are not in <code>Stdlib.Prelude</code> to avoid clashes with user-defined operators for other data types. The functions available in <code>Stdlib.Data.Nat.Org</code> include: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>/=</code>, <code>min</code>, <code>max</code>.</p> <p>For example, one may define the function <code>max3</code> by:</p> <pre><code>  open import Stdlib.Prelude;\n  open import Stdlib.Data.Nat.Ord;\n\n  max3 : Nat -&gt; Nat -&gt; Nat -&gt; Nat;\n  max3 x y z := if (x &gt; y) (max x z) (max y z);\n</code></pre> <p>The conditional <code>if</code> is a special function which is evaluated lazily, i.e., first the condition (the first argument) is evaluated, and then depending on its truth-value one of the branches (the second or the third argument) is evaluated and returned.</p> <p>By default, evaluation in Juvix is eager (or strict), meaning that the arguments to a function are fully evaluated before applying the function. Only <code>if</code>, <code>||</code> and <code>&amp;&amp;</code> are treated specially and evaluated lazily. These special functions cannot be partially applied (see Partial application and higher-order functions below).</p>"},{"location":"tutorials/learn/#local-definitions","title":"Local definitions","text":"<p>Juvix supports local definitions with let-expressions.</p> <pre><code>  f : Nat -&gt; Nat;\n  f a :=\n    let\n      x : Nat := a + 5;\n      y : Nat := a * 7 + x;\n    in x * y;\n</code></pre> <p>The variables <code>x</code> and <code>y</code> are not visible outside <code>f</code>.</p> <p>One can also use multi-clause definitions in <code>let</code>-expressions, with the same syntax as definitions inside a module. For example:</p> <pre><code>  even : Nat -&gt; Bool;\n  even :=\n    let\n      even' : Nat -&gt; Bool;\n      odd' : Nat -&gt; Bool;\n      even' zero := true;\n      even' (suc n) := odd' n;\n      odd' zero := false;\n      odd' (suc n) := even' n;\n    in even';\n</code></pre> <p>The functions <code>even'</code> and <code>odd'</code> are not visible outside <code>even</code>.</p>"},{"location":"tutorials/learn/#recursion","title":"Recursion","text":"<p>Juvix is a purely functional language, which means that functions have no side effects and all variables are immutable. An advantage of functional programming is that all expressions are referentially transparent \u2013 any expression can be replaced by its value without changing the meaning of the program. This makes it easier to reason about programs, in particular to prove their correctness. No errors involving implicit state are possible, because the state is always explicit.</p> <p>In a functional language, there are no imperative loops. Repetition is expressed using recursion. In many cases, the recursive definition of a function follows the inductive definition of a data structure the function analyses. For example, consider the following inductive type of lists of natural numbers:</p> <pre><code>  type NList :=\n    | nnil : NList\n    | ncons : Nat -&gt; NList -&gt; NList;\n</code></pre> <p>An element of <code>NList</code> is either <code>nnil</code> (empty) or <code>ncons x xs</code> where <code>x : Nat</code> and <code>xs : NList</code> (a list with head <code>x</code> and tail <code>xs</code>).</p> <p>A function computing the length of a list may be defined by:</p> <pre><code>  -- Nat here is the built-in type for natural numbers\n  -- coming from the standard library\n  nlength : NList -&gt; Nat;\n  nlength nnil := 0;\n  nlength (ncons _ xs) := nlength xs + 1;\n</code></pre> <p>The definition follows the inductive definition of <code>NList</code>. There are two function clauses for the two constructors. The case for <code>nnil</code> is easy \u2013 the constructor has no arguments and the length of the empty list is <code>0</code>. For a constructor with some arguments, one typically needs to express the result of the function in terms of the constructor arguments, usually calling the function recursively on the constructor's inductive arguments (for <code>ncons</code> this is the second argument). In the case of <code>ncons _ xs</code>, we recursively call <code>nlength</code> on <code>xs</code> and add <code>1</code> to the result.</p> <p>Let's consider another example \u2013 a function which returns the maximum of the numbers in a list or 0 for the empty list.</p> <pre><code>  open import Stdlib.Data.Nat.Ord;\n  -- for `max`\n  nmaximum : NList -&gt; Nat;\n  nmaximum nnil := 0;\n  nmaximum (ncons x xs) := max x (nmaximum xs);\n</code></pre> <p>Again, there is a clause for each constructor. In the case for <code>ncons</code>, we recursively call the function on the list tail and take the maximum of the result and the list head.</p> <p>For an example of a constructor with more than one inductive argument, consider binary trees with natural numbers in nodes.</p> <pre><code>  type Tree :=\n    | leaf : Nat -&gt; Tree\n    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;\n</code></pre> <p>The constructor <code>node</code> has two inductive arguments (the second and the third) which represent the left and the right subtree.</p> <p>A function which produces the mirror image of a tree may be defined by:</p> <pre><code>  mirror : Tree -&gt; Tree;\n  mirror (leaf x) := leaf x;\n  mirror (node x l r) := node x (mirror r) (mirror l);\n</code></pre> <p>The definition of <code>mirror</code> follows the definition of <code>Tree</code>. There are two recursive calls for the two inductive constructors of <code>node</code> (the subtrees).</p>"},{"location":"tutorials/learn/#partial-application-and-higher-order-functions","title":"Partial application and higher-order functions","text":"<p>Strictly speaking, all Juvix functions have only one argument. Multi-argument functions are really functions which return a function which takes the next argument and returns a function taking another argument, and so on for all arguments. The function type former <code>-&gt;</code> (the arrow) is right-associative. Hence, the type, e.g., <code>Nat -&gt; Nat -&gt; Nat</code> when fully parenthesised becomes <code>Nat -&gt; (Nat -&gt; Nat)</code>. It is the type of functions which given an argument of type <code>Nat</code> return a function of type <code>Nat -&gt; Nat</code> which itself takes an argument of type <code>Nat</code> and produces a result of type <code>Nat</code>. Function application is left-associative. For example, <code>f a b</code> when fully parenthesised becomes <code>(f a) b</code>. So it is an application to <code>b</code> of the function obtained by applying <code>f</code> to <code>a</code>.</p> <p>Since a multi-argument function is just a one-argument function returning a function, it can be partially applied to a smaller number of arguments than specified in its definition. The result is an appropriate function. For example, <code>sub 10</code> is a function which subtracts its argument from <code>10</code>, and <code>(+) 1</code> is a function which adds <code>1</code> to its argument. If the function has been declared as an infix operator (like <code>+</code>), then for partial application one needs to enclose it in parentheses.</p> <p>A function which takes a function as an argument is a higher-order function. An example is the <code>nmap</code> function which applies a given function to each element in a list of natural numbers.</p> <pre><code>  nmap : (Nat -&gt; Nat) -&gt; NList -&gt; NList;\n  nmap _ nnil := nnil;\n  nmap f (ncons x xs) := ncons (f x) (nmap f xs);\n</code></pre> <p>The application</p> <pre><code>nmap \\{ x := div x 2 } lst\n</code></pre> <p>divides every element of <code>lst</code> by <code>2</code>, rounding down the result. The expression</p> <pre><code>\\{ x := div x 2 }\n</code></pre> <p>is an unnamed function, or a lambda, which divides its argument by <code>2</code>.</p>"},{"location":"tutorials/learn/#polymorphism","title":"Polymorphism","text":"<p>The type <code>NList</code> we have been working with above requires the list elements to be natural numbers. It is possible to define lists polymorphically, parameterising them by the element type. This is similar to generics in languages like Java, C++ or Rust. Here is the polymorphic definition of lists from the standard library:</p> <pre><code>  infixr 5 ::;\n  type List (A : Type) :=\n    | nil : List A\n    | :: : A -&gt; List A -&gt; List A;\n</code></pre> <p>The constructor <code>::</code> is declared as a right-associative infix operator with priority 5. The definition has a parameter <code>A</code> which is the element type.</p> <p>Now one can define the <code>map</code> function polymorphically:</p> <pre><code>  map : {A B : Type} -&gt; (A -&gt; B) -&gt; List A -&gt; List B;\n  map f nil := nil;\n  map f (h :: hs) := f h :: map f hs;\n</code></pre> <p>This function has two implicit type arguments <code>A</code> and <code>B</code>. These arguments are normally omitted in function application \u2013 they are inferred automatically during type checking. The curly braces indicate that the argument is implicit and should be inferred.</p> <p>In fact, the constructors <code>nil</code> and <code>::</code> also have an implicit argument: the type of list elements. All type parameters of a data type definition become implicit arguments of the constructors.</p> <p>Usually, the implicit arguments in a function application can be inferred. However, sometimes this is not possible and then the implicit arguments need to be provided explicitly by enclosing them in braces:</p> <pre><code>f {implArg1} .. {implArgK} arg1 .. argN\n</code></pre> <p>For example, <code>nil {Nat}</code> has type <code>List Nat</code> while <code>nil</code> by itself has type <code>{A : Type} -&gt; List A</code>.</p>"},{"location":"tutorials/learn/#tail-recursion","title":"Tail recursion","text":"<p>Any recursive call whose result is further processed by the calling function needs to create a new stack frame to save the calling function environment. This means that each such call will use a constant amount of memory. For example, a function <code>sum</code> implemented as follows will use an additional amount of memory proportional to the length of the processed list:</p> <pre><code>  sum : NList -&gt; Nat;\n  sum nnil := 0;\n  sum (ncons x xs) := x + sum xs;\n</code></pre> <p>This is not acceptable if you care about performance. In an imperative language, one would use a simple loop going over the list without any memory allocation. In pseudocode:</p> <pre><code>sum : Nat := 0;\n\nwhile (lst /= nil) do\nbegin\n  sum := sum + head lst;\n  lst := tail lst;\nend;\n\nresult := sum;\n</code></pre> <p>Fortunately, it is possible to rewrite this function to use tail recursion. A recursive call is tail recursive if its result is also the result of the calling function, i.e., the calling function returns immediately after it without further processing. The Juvix compiler guarantees that all tail calls will be eliminated, i.e., that they will be compiled to simple jumps without extra memory allocation. In a tail recursive call, instead of creating a new stack frame, the old one is reused.</p> <p>The following implementation of <code>sum</code> uses tail recursion.</p> <pre><code>  sum : NList -&gt; Nat;\n  sum lst :=\n    let\n      go : Nat -&gt; NList -&gt; Nat;\n      go acc nnil := acc;\n      go acc (ncons x xs) := go (acc + x) xs;\n    in go 0 lst;\n</code></pre> <p>The first argument of <code>go</code> is an accumulator which holds the sum computed so far. It is analogous to the <code>sum</code> variable in the imperative loop above. The initial value of the accumulator is 0. The function <code>go</code> uses only constant additional memory overall. The code generated for it by the Juvix compiler is equivalent to an imperative loop.</p> <p>Most imperative loops may be translated into tail recursive functional programs by converting the locally modified variables into accumulators and the loop condition into pattern matching. For example, here is an imperative pseudocode for computing the nth Fibonacci number in linear time. The variables <code>cur</code> and <code>next</code> hold the last two computed Fibonacci numbers.</p> <pre><code>cur : Nat := 0;\nnext : Nat := 1;\n\nwhile (n /= 0) do\nbegin\n  tmp := next;\n  next := cur + next;\n  cur := tmp;\n  n := n - 1;\nend;\n\nresult := cur;\n</code></pre> <p>An equivalent functional program is:</p> <pre><code>    fib : Nat -&gt; Nat;\n    fib :=\n      let\n        go : Nat -&gt; Nat -&gt; Nat -&gt; Nat;\n        go cur _ zero := cur;\n        go cur next (suc n) := go next (cur + next) n;\n      in go 0 1;\n</code></pre> <p>A naive definition of the Fibonacci function runs in exponential time:</p> <pre><code>    fib : Nat -&gt; Nat;\n    fib zero := 0;\n    fib (suc zero) := 1;\n    fib (suc (suc n)) := fib n + fib (suc n);\n</code></pre> <p>Tail recursion is less useful when the function needs to allocate memory anyway. For example, one could make the <code>map</code> function from the previous section tail recursive, but the time and memory use would still be proportional to the length of the input because of the need to allocate the result list.</p>"},{"location":"tutorials/learn/#totality-checking","title":"Totality checking","text":"<p>By default, the Juvix compiler requires all functions to be total. Totality consists of:</p> <ul> <li>termination and coverage for function declarations, and</li> <li>strict positivity for user-defined   data types.</li> </ul> <p>The termination check ensures that all functions are structurally recursive, i.e., all recursive call are on structurally smaller values \u2013 subpatterns of the matched pattern. For example, the termination checker rejects the definition</p> <pre><code>    fact : Nat -&gt; Nat;\n    fact x := if (x == 0) 1 (x * fact (sub x 1));\n</code></pre> <p>because the recursive call is not on a subpattern of a pattern matched on in the clause. One can reformulate this definition so that it is accepted by the termination checker:</p> <pre><code>    fact : Nat -&gt; Nat;\n    fact zero := 1;\n    fact x@(suc n) := x * fact n;\n</code></pre> <p>Sometimes, such a reformulation is not possible. Then one can use the <code>terminating</code> keyword to forgo the termination check.</p> <pre><code>  terminating\n  log2 : Nat -&gt; Nat;\n  log2 n := if (n &lt;= 1) 0 (suc (log2 (div n 2)));\n</code></pre> <p>Coverage checking ensures that there are no unhandled patterns in function clauses or <code>case</code> expressions. For example, the following definition is rejected because the case <code>suc zero</code> is not handled:</p> <pre><code>    even : Nat -&gt; Bool;\n    even zero := true;\n    even (suc (suc n)) := even n;\n</code></pre> <p>Since coverage checking forces the user to specify the function for all input values, it may be unclear how to implement functions which are typically partial. For example, the <code>tail</code> function on lists is often left undefined for the empty list. One solution is to return a default value. In the Juvix standard library, <code>tail</code> is implemented as follows, returning the empty list when the argument is empty.</p> <pre><code>  tail : {A : Type} -&gt; List A -&gt; List A;\n  tail (_ :: xs) := xs;\n  tail nil := nil;\n</code></pre> <p>Another solution is to wrap the result in the <code>Maybe</code> type from the standard library, which allows representing optional values. An element of <code>Maybe A</code> is either <code>nothing</code> or <code>just x</code> with <code>x : A</code>.</p> <pre><code>  type Maybe (A : Type) :=\n    | nothing : Maybe A\n    | just : A -&gt; Maybe A;\n</code></pre> <p>For example, one could define the tail function as:</p> <pre><code>    tail' : {A : Type} -&gt; List A -&gt; Maybe (List A);\n    tail' (_ :: xs) := just xs;\n    tail' nil := nothing;\n</code></pre> <p>Then the user needs to explicitly check if the result of the function contains a value or not:</p> <pre><code>case tail' lst\n| just x := ...\n| nothing := ...\n</code></pre>"},{"location":"tutorials/learn/#exercises","title":"Exercises","text":"<p>You have now learnt the very basics of Juvix. To consolidate your understanding of Juvix and functional programming, try doing some of the following exercises. To learn how to write more complex Juvix programs, see the advanced tutorial and the Juvix program examples.</p>"},{"location":"tutorials/learn/#exercise-1","title":"Exercise 1","text":"<p>Define a function <code>prime : Nat -&gt; Nat</code> which checks if a given natural number is prime.</p> <p>Tip</p> <p>A number is prime if it is greater than 1 and has no divisors other than 1 and itself.</p>"},{"location":"tutorials/learn/#exercise-2","title":"Exercise 2","text":"<p>What is wrong with the following definition?</p> <pre><code>half : Nat -&gt; Nat;\nhalf n := if (n &lt; 2) 0 (half (n - 2) + 1);\n</code></pre> <p>How can you reformulate this definition so that it is accepted by Juvix?</p>"},{"location":"tutorials/learn/#exercise-3","title":"Exercise 3","text":"<p>Define a polymorphic function which computes the last element of a list. What is the result of your function on the empty list?</p>"},{"location":"tutorials/learn/#exercise-4","title":"Exercise 4","text":"<p>A suffix of a list <code>l</code> is any list which can be obtained from <code>l</code> by removing some initial elements. For example, the suffixes of <code>1 :: 2 :: 3 :: nil</code> are:</p> <ul> <li><code>1 :: 2 :: 3 :: nil</code>,</li> <li><code>2 :: 3 :: nil</code>,</li> <li><code>3 :: nil</code>, and</li> <li><code>nil</code>.</li> </ul> <p>Define a function which computes the list of all suffixes of a given list, arranged in descending order of their lengths.</p>"},{"location":"tutorials/learn/#exercise-5","title":"Exercise 5","text":"<p>Recall the <code>Tree</code> type from above.</p> <pre><code>  type Tree :=\n    | leaf : Nat -&gt; Tree\n    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;\n</code></pre> <p>Analogously to the <code>map</code> function for lists, define a function</p> <pre><code>tmap : (Nat -&gt; Nat) -&gt; Tree -&gt; Tree;\n</code></pre> <p>which applies a function to all natural numbers stored in a tree.</p>"},{"location":"tutorials/learn/#exercise-6","title":"Exercise 6","text":"<p>Modify the <code>Tree</code> type from Exercise 5 to be polymorphic in the element type, and then repeat the previous exercise.</p>"},{"location":"tutorials/learn/#exercise-7","title":"Exercise 7","text":"<p>Write a tail recursive function which reverses a list.</p>"},{"location":"tutorials/learn/#exercise-8","title":"Exercise 8","text":"<p>Write a tail recursive function which computes the factorial of a natural number.</p>"},{"location":"tutorials/learn/#exercise-9","title":"Exercise 9","text":"<p>Define a function</p> <pre><code>comp : {A : Type} -&gt; List (A -&gt; A) -&gt; A -&gt; A\n</code></pre> <p>which composes all functions in a list. For example,</p> <pre><code>comp (suc :: (*) 2 :: \\{x := sub x 1} :: nil)\n</code></pre> <p>should be a function which given <code>x</code> computes <code>2(x - 1) + 1</code>.</p>"},{"location":"tutorials/nodejs-interop/","title":"NodeJS Interop","text":"<p>A Juvix module can be compiled to a Wasm module. When a Wasm module is instantiated by a host, functions from the host can be injected into a Wasm module and functions from the Wasm module can be called by the host.</p> <p>In this tutorial you will see how to call host functions in Juvix and call Juvix functions from the host using the Wasm mechanism.</p>"},{"location":"tutorials/nodejs-interop/#the-juvix-module","title":"The Juvix module","text":"<p>The following Juvix module has two functions.</p> <p>The function <code>hostDisplayString</code> is an <code>axiom</code> with no corresponding <code>compile</code> block that implements it. We will inject an implementation for this function when we instantiate the module from NodeJS.</p> <p>The function <code>juvixRender</code> is a normal Juvix function. We will call this from NodeJS.</p> <pre><code>-- NodeJsInterop.juvix\nmodule NodeJsInterop;\n\nopen import Stdlib.Prelude;\n\naxiom hostDisplayString : String \u2192 IO;\n\njuvixRender : IO;\njuvixRender := hostDisplayString \"Hello World from Juvix!\";\n\nend;</code></pre>"},{"location":"tutorials/nodejs-interop/#compiling-the-juvix-module","title":"Compiling the Juvix module","text":"<p>The Juvix module can be compiled using the following command:</p> <pre><code>juvix compile -t wasm -r standalone NodeJsInterop.juvix</code></pre> <p>This will create a file containing a Wasm module called <code>NodeJsInterop.wasm</code>.</p>"},{"location":"tutorials/nodejs-interop/#the-nodejs-module","title":"The NodeJS module","text":"<p>The following NodeJS module demonstrates both calling a Juvix function from NodeJS and injecting a NodeJS function into a Juvix module.</p> <p>The NodeJS function <code>hostDisplayString</code> is passed to the Wasm module <code>NodeJSInterop.wasm</code> when it is instantiated. After instantiation the Juvix function <code>juvixRender</code> is called.</p> <p>The functions <code>ptrToCstr</code> and <code>cstrlen</code> are necessary to convert the <code>char</code> pointer passed from Juvix to a JS <code>String</code>.</p> <pre><code>// NodeJSInterop.js\nconst fs = require('fs');\nlet wasmModule = null;\n\nfunction cstrlen(mem, ptr) {\n    let len = 0;\n    while (mem[ptr] != 0) {\n        len++;\n        ptr++;\n    }\n    return len;\n}\n\nfunction ptrToCstr(ptr) {\n    const wasmMemory = wasmModule.instance.exports.memory.buffer;\n    const mem = new Uint8Array(wasmMemory);\n    const len = cstrlen(mem, ptr);\n    const bytes = new Uint8Array(wasmMemory, ptr, len);\n    return new TextDecoder().decode(bytes);\n}\n\nfunction hostDisplayString(strPtr) {\n    const text = ptrToCstr(strPtr);\n    console.log(text);\n}\n\nconst wasmBuffer = fs.readFileSync(\"NodeJsInterop.wasm\");\nWebAssembly.instantiate(wasmBuffer, {\n    env: {\n        hostDisplayString,\n    }\n}).then((w) =&gt; {\n    wasmModule = w;\n    wasmModule.instance.exports.juvixRender();\n});</code></pre>"},{"location":"tutorials/nodejs-interop/#running-the-wasm-module","title":"Running the Wasm module","text":"<p>Now you should have the files <code>NodeJsInterop.wasm</code> and <code>NodeJsInterop.js</code> in the same directory. Run the following command to execute the module:</p> <pre><code>node NodeJsInterop.js</code></pre> <p>You should see the following output:</p> <pre><code>Hello World from Juvix!</code></pre>"},{"location":"tutorials/vscode/","title":"Juvix VSCode extension tutorial","text":"<p>To install the Juvix VSCode extension, click on the \"Extensions\" button in the left panel and search for the \"Juvix\" extension by Heliax.</p> <p>Once you've installed the Juvix extension, you can open a Juvix file. For example, create a <code>Hello.juvix</code> file with the following content.</p> <pre><code></code></pre> <p>Syntax should be automatically highlighted for any file with <code>.juvix</code> extension. You can jump to the definition of an identifier by pressing F12 or control-clicking it. To apply the Juvix code formatter to the current file, use Shift+Ctrl+I.</p> <p>In the top right-hand corner of the editor window you should see several buttons. Hover the mouse pointer over a button to see its description. The functions of the buttons are as follows.</p> <ul> <li>Load file in REPL (Shift+Alt+R). Launches the Juvix REPL in a   separate window and loads the current file into it. You can then   evaluate any definition from the loaded file.</li> <li>Typecheck (Shift+Alt+T). Type-checks the current file.</li> <li>Compile (Shift+Alt+C). Compiles the current file. The resulting   native executable will be left in the directory of the file.</li> <li>Run (Shift+Alt+X). Compiles and runs the current file. The output of   the executable run is displayed in a separate window.</li> <li>Html preview. Generates HTML documentation for the current file and   displays it in a separate window.</li> </ul>"}]}