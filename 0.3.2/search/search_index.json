{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Juvix documentation!","text":"<p>Juvix is an open-source, ever-evolving functional language for creating privacy-focused decentralized apps. It allows developers to write high-level programs that compile to WASM or, via VampIR, to circuits for private execution using Taiga on Anoma or Ethereum.</p> <p>This documentation covers various topics, including a concise introduction to the Juvix ecosystem, which can be found in the overview section.</p> <ul> <li> <p> How-to guides</p> <p>Learn how to install Juvix on macOS or Linux, as well as compile and    document your Juvix projects.</p> <p> Quick start </p> <p> How-to guides </p> </li> <li> <p> Tutorials</p> <p>Master the essentials of Juvix's programming language though a series of tailored examples, tutorials and technical explanations.</p> <p> Learn Juvix in 5 minutes</p> </li> <li> <p> Explanations</p> <p>A series dedicated to delivering more in-depth technical explanations of Juvix.</p> <p> Read the book</p> </li> <li> <p> Reference</p> <p>Explore the Language reference, milestone examples, and tooling documentation!</p> <p> Reference</p> </li> <li> <p> Blog</p> <p>Check out our blog to discover new features in the upcoming release, along with helpful examples and more. And, don't forget to join us on Discord.</p> <p> Join us</p> </li> <li> <p> Open Source, GPL3.0</p> <p>Juvix is licensed under GPL3 and available on GitHub.</p> <p> License</p> </li> </ul>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CHANGELOG/#v031-2023-03-31","title":"v0.3.1 (2023-03-31)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Option <code>--show-args-num</code> #1946   (lukaszcz)</li> <li>Preserve the target type in letrec lifting   #1945   (janmasrovira)</li> <li>Add syntax highlighting to Core error messages   #1938   (lukaszcz)</li> <li>Add the <code>--unroll</code> option   #1935   (lukaszcz)</li> <li>Preserve name and location information in Internal-to-Core   #1933   (lukaszcz)</li> <li>Polymorphic type inference in Core   #1931   (lukaszcz)</li> <li>Update README.md with Juvix nightly builds badge   #1923   (jonaprieto)</li> <li>Create clean-up-cache.yaml   #1915   (jonaprieto)</li> <li>Update GitHub pages deployment using deploy-pages action   #1910   (jonaprieto)</li> <li>Check for recursive inductive types in the GEB pipeline   #1909   (lukaszcz)</li> <li>CI pre-commit maintenance   #1905   (jonaprieto)</li> <li>Add new README and md files   #1904   (jonaprieto)</li> <li>Print JuvixCore correctly   #1875   (lukaszcz)</li> <li>Pattern matching compilation   #1874   (lukaszcz)</li> <li>CI Haskell maintenance   #1797   (jonaprieto)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Let-folding after lifting   #1955   (lukaszcz)</li> <li>Fix removal of polymorphic type arguments   #1954   (lukaszcz)</li> <li>Fix a bug in closure traversal   #1953   (lukaszcz)</li> <li>Update typecheck command to check for coverage   #1952   (janmasrovira)</li> <li>CI: Ignore errors linux typecheck / format examples step   #1950   (paulcadman)</li> <li>Filter out type synonyms in RemoveTypeArgs   #1949   (lukaszcz)</li> <li>Add fail nodes to Geb   #1947   (lukaszcz)</li> <li>End-to-end Geb compilation tests   #1942   (lukaszcz)</li> <li>Add juvix dev repl command   #1941   (paulcadman)</li> <li>Refactor Geb values   #1940   (lukaszcz)</li> <li>Avoid capturing the same free variable multiple times in letrec lifting   #1939   (janmasrovira)</li> <li>Add Judoc syntax reference   #1934   (janmasrovira)</li> <li>Fix spacing of judoc in the formatter   #1932   (janmasrovira)</li> <li>bench: Fix juvix compile flag for wasm   #1925   (paulcadman)</li> <li>Fix memory count for string operations   #1924   (lukaszcz)</li> <li>Let folding   #1921   (lukaszcz)</li> <li>Add a test suite for milestone examples   #1920   (paulcadman)</li> <li>Add --numeric-version flag   #1918   (jonaprieto)</li> <li>Fix bug with unregistered builtin bool   #1917   (lukaszcz)</li> <li>Recursion unrolling for functions   #1912   (lukaszcz)</li> <li>Fix REPL state to include enough information to rerun the pipeline   #1911   (janmasrovira)</li> <li>CI Haskell fix for macOS build   #1908   (jonaprieto)</li> <li>Fix bug in IO runtime   #1906   (lukaszcz)</li> <li>Fix JuvixAsm validation   #1903   (lukaszcz)</li> <li>Fix registration of builtin inductive axioms   #1901   (paulcadman)</li> <li>internal-to-core: Fix index shifting of pattern arguments   #1900   (paulcadman)</li> <li>Fix de Bruijn indices in rmap   #1898   (lukaszcz)</li> <li>Normalize types in repl   #1897   (janmasrovira)</li> <li>Add MidSquareHash.juvix and fix types in MidSquareHash.jvc   #1896   (lukaszcz)</li> <li>Automatically detect and split mutually recursive blocks in let expressions   #1894   (janmasrovira)</li> <li>The <code>rmap</code> recursor   #1893   (lukaszcz)</li> <li>Add <code>juvix format</code> command   #1886   (paulcadman)</li> <li>Make keyword <code>end</code> optional for top modules   #1883   (janmasrovira)</li> <li>Add errors to the Core pipeline and check GEB prerequisites   #1871   (lukaszcz)</li> <li>Test core to geb translation   #1865   (jonaprieto)</li> </ul>"},{"location":"CHANGELOG/#v030-2023-03-15","title":"v0.3.0 (2023-03-15)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Avoid line breaks in applications within a type signature   #1850   (paulcadman)</li> <li>Respect user's spacing decisions in the formatter   #1837   (janmasrovira)</li> <li>Formatter should not transform ASCII symbols to unicode by default   #1827   (janmasrovira)</li> <li>Enable match-to-case, nat-to-int and convert-builtins by default in   REPL #1825   (lukaszcz)</li> <li>The Juvix formatter works poorly with multi-line ifs   #1793   (janmasrovira)</li> <li>Add a lazy IO sequencing function (#1772)   #1773   (lukaszcz)</li> <li>Support LetRec in the GEB backend   #1756   (janmasrovira)</li> <li>Support integers in the GEB backend   #1753   (lukaszcz)</li> <li>GEB evaluator #1751   (jonaprieto)</li> <li>Add debugging builtin functions   #1731   (jonaprieto)</li> <li>Non-judoc comments are removed when generating HTML output   #1723   (janmasrovira)</li> <li>Special syntax for <code>case</code> #1716   (janmasrovira)</li> <li>Make || and &amp;&amp; lazy   #1701   (lukaszcz)</li> <li>It should be possible to specify multiple implicit type arguments at   once #1692   (janmasrovira)</li> <li>Naive compilation of complex pattern matches with match-expressions   to decision trees with case-expressions   #1531   (paulcadman)</li> <li>New compilation pipeline   #1832   (lukaszcz)</li> <li>Add internal core-eval option to evaluate named function identifier   #1819   (paulcadman)</li> <li>Short syntax for sequences of function and datatype parameters   #1809   (lukaszcz)</li> <li>Add Geb Backend Evaluator with some extra subcommands   #1808   (jonaprieto)</li> <li>Add REPL option to apply Core transformations   #1796   (paulcadman)</li> <li>String builtins #1784   (lukaszcz)</li> <li>Use restore/save github action to speed up the CI testing   #1783   (jonaprieto)</li> <li>Fix minor issue with ==% for type equality   #1780   (jonaprieto)</li> <li>Add debugging builtin functions <code>trace</code> and <code>fail</code> #1771   (jonaprieto)</li> <li>Keep regular comments in html output   #1766   (janmasrovira)</li> <li>Lazy boolean operators   #1743   (lukaszcz)</li> <li>Refactor <code>html</code> command with extra options   #1725   (jonaprieto)</li> <li>Add initial setup for codespaces   #1713   (jonaprieto)</li> <li>Typecheck let expressions   #1712   (janmasrovira)</li> <li>Use Smoke instead of shelltestrunner   #1710   (jonaprieto)</li> <li>Replace \u2013output-dir flag by \u2013internal-build-dir   #1707   (jonaprieto)</li> <li>Compiler output #1705   (jonaprieto)</li> <li>Allow optional pipe before the first constructor for inductive type   declarations #1699   (jonaprieto)</li> <li>Nat builtins #1686   (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Remove dead code in <code>Internal</code> #1891   (janmasrovira)</li> <li>Remove missing Juvix examples and webapp example from docs build   #1890   (paulcadman)</li> <li>Fix type synonym in let   #1880   (janmasrovira)</li> <li>Update stack resolver to lts-20.12   #1873   (paulcadman)</li> <li>Use Ape to format patterns   #1870   (janmasrovira)</li> <li>Fix Core-To-Geb translation   #1863   (jonaprieto)</li> <li>Remove the old C backend   #1862   (lukaszcz)</li> <li>Move <code>substEnv</code> to its own module   #1861   (janmasrovira)</li> <li>Add <code>_caseTypeWholeExpression</code> to Internal   #1860   (janmasrovira)</li> <li>remove old minihaskell files   #1859   (jonaprieto)</li> <li>Fix bugs in the Case translation in Core-to-Geb   #1858   (lukaszcz)</li> <li>Format examples #1856   (janmasrovira)</li> <li>Sort the identifiers topologically in the Core-to-GEB translation   #1854   (lukaszcz)</li> <li>Add type info to the mid-square hashing function   #1853   (lukaszcz)</li> <li>Use APE mechanism to format Function expressions   #1852   (paulcadman)</li> <li>Preserve single wildcards pretty printing function parameters   #1851   (paulcadman)</li> <li>Add type annotation to case expression   #1849   (janmasrovira)</li> <li>Remove module parameters   #1848   (janmasrovira)</li> <li>Allow shadowing local variables with let function definitions   #1847   (janmasrovira)</li> <li>Add lambda type info   #1845   (janmasrovira)</li> <li>Improve comma formatting   #1842   (janmasrovira)</li> <li>Improve formatter #1840   (janmasrovira)</li> <li>Respect lambda Ascii/Unicode   #1838   (janmasrovira)</li> <li>Fix <code>juvix init</code> #1835   (janmasrovira)</li> <li>The formatter respects the ascii function arrow   #1834   (janmasrovira)</li> <li>Add <code>dev core from-concrete</code> command   #1833   (janmasrovira)</li> <li>Give proper errors for incorrect application of lazy builtins   #1830   (lukaszcz)</li> <li>Documentation: update language reference   #1829   (lukaszcz)</li> <li>Add compilation of complex pattern matching to case   #1824   (paulcadman)</li> <li>Apply CI ghcup workaround to docs build   #1823   (paulcadman)</li> <li>Update the Juvix tutorial for 0.3   #1822   (lukaszcz)</li> <li>Workaround ghcup issue on CI runner   #1821   (paulcadman)</li> <li>Respect the <code>juvix dev highlight --format</code> flag when outputting   errors #1820   (janmasrovira)</li> <li>Comments about the usage of the JuvixCore recursors   #1818   (lukaszcz)</li> <li>Emacs mode and VSCode extension tutorials   #1815   (lukaszcz)</li> <li>Documentation: how to compile Juvix programs   #1813   (lukaszcz)</li> <li>Make '&gt;&gt;' lazy #1812   (lukaszcz)</li> <li>Output proper GEB Lisp programs   #1810   (lukaszcz)</li> <li>Remove the usage annotation syntax   #1805   (lukaszcz)</li> <li>Mid-square hashing implemented in JuvixCore   #1804   (lukaszcz)</li> <li>Autocompletion for <code>dev core compilation --target</code> #1803   (janmasrovira)</li> <li>Special syntax for case   #1800   (janmasrovira)</li> <li>Adapt benchmarks to the new pipeline   #1795   (lukaszcz)</li> <li>Support letrec lifting without lambda lifting   #1794   (janmasrovira)</li> <li>Use the reader effect   #1791   (janmasrovira)</li> <li>Remove braces from let expressions   #1790   (janmasrovira)</li> <li>Translate as-pattern binders to Core PatternBinders   #1789   (paulcadman)</li> <li>Fix termination with as-patterns   #1787   (janmasrovira)</li> <li>Allow type signatures to have a body   #1785   (janmasrovira)</li> <li>Track builtins in the Core InfoTable   #1782   (paulcadman)</li> <li>Pipes for lambda clauses   #1781   (janmasrovira)</li> <li>Support integers in the GEB backend   #1778   (lukaszcz)</li> <li>Add builtin nat and bool types as start nodes in reachability   analysis #1775   (paulcadman)</li> <li>Update pre-commit #1772   (jonaprieto)</li> <li>Parse JuvixCore with absolute paths   #1770   (paulcadman)</li> <li>Use absolute path in Core Evaluator to generate source file location   #1769   (paulcadman)</li> <li>Install wasmer binary from Github releases   #1765   (jonaprieto)</li> <li>Run the new Juvix formatter for all the Juvix examples   #1764   (jonaprieto)</li> <li>Fix let expressions in the repl   #1763   (janmasrovira)</li> <li>Improve arity inference for repl expressions   #1762   (janmasrovira)</li> <li>Fix broken links and other improvements   #1761   (jonaprieto)</li> <li>Translate Nat builtins to the correct Core Ops   #1760   (paulcadman)</li> <li>Remove hlint from the CI and pre-commit config   #1759   (jonaprieto)</li> <li>Fix demo example build   #1757   (paulcadman)</li> <li>Basic Geb integration   #1748   (lukaszcz)</li> <li>Fix macOS CI build #1747   (paulcadman)</li> <li>Adapt Juvix programs to the new pipeline   #1746   (lukaszcz)</li> <li>Fix link in README for the new docs   #1745   (lukaszcz)</li> <li>Move juvix-mode to a separate repository   #1744   (jonaprieto)</li> <li>Print comments when pretty printing concrete syntax   #1737   (janmasrovira)</li> <li>Demo #1736   (lukaszcz)</li> <li>Update CI to install Smoke, Github actions, and Makefile fixes   #1735   (jonaprieto)</li> <li>Update stack.yaml #1734   (jonaprieto)</li> <li>Fix Nat builtins #1733   (lukaszcz)</li> <li>Script to count LOC   #1732   (lukaszcz)</li> <li>Give a proper type to literal Strings   #1730   (paulcadman)</li> <li>Do not filter implicit args in internal to core translation   #1728   (paulcadman)</li> <li>Fix de Brujin indexing of lambda arguments   #1727   (paulcadman)</li> <li>Fix inference loop #1726   (janmasrovira)</li> <li>Remove wildcard patterns from Internal   #1724   (janmasrovira)</li> <li>Restructure the documentation and add a tutorial   #1718   (lukaszcz)</li> <li>Improve error message for confusing ':=' with '='   #1715   (lukaszcz)</li> <li>Fix #1704 #1711   (janmasrovira)</li> <li>Fix #1693 #1708   (janmasrovira)</li> <li>Tests for the new compilation pipeline   #1703   (lukaszcz)</li> <li>Add printString and printBool support to legacy C backend   #1698   (paulcadman)</li> <li>Add \u2013show-de-bruijn option to <code>juvix repl</code> #1694   (lukaszcz)</li> <li>Allow 'terminating' keyword with builtins   #1688   (lukaszcz)</li> <li>Remove unicode cons symbol   #1687   (lukaszcz)</li> <li>Change syntax for ind. data types and forbid the empty data type   #1684   (jonaprieto)</li> <li>Convert Nat literals to Core integers   #1681   (lukaszcz)</li> <li>Less verbose output from running <code>make check</code> #1675   (jonaprieto)</li> <li>Remove where syntax   #1674   (jonaprieto)</li> <li>Benchmarks #1673   (janmasrovira)</li> <li>JuvixCore to JuvixAsm translation   #1665   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v029-2023-01-18","title":"v0.2.9 (2023-01-18)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Refactor <code>html</code> command with extra options   #1725   (jonaprieto)</li> <li>Add initial setup for codespaces   #1713   (jonaprieto)</li> <li>Typecheck let expressions   #1712   (janmasrovira)</li> <li>Use Smoke instead of shelltestrunner   #1710   (jonaprieto)</li> <li>Replace \u2013output-dir flag by \u2013internal-build-dir   #1707   (jonaprieto)</li> <li>Compiler output #1705   (jonaprieto)</li> <li>Allow optional pipe before the first constructor for inductive type   declarations #1699   (jonaprieto)</li> <li>Nat builtins #1686   (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Demo #1736   (lukaszcz)</li> <li>Update stack.yaml #1734   (jonaprieto)</li> <li>Fix Nat builtins #1733   (lukaszcz)</li> <li>Script to count LOC   #1732   (lukaszcz)</li> <li>Give a proper type to literal Strings   #1730   (paulcadman)</li> <li>Do not filter implicit args in internal to core translation   #1728   (paulcadman)</li> <li>Fix de Brujin indexing of lambda arguments   #1727   (paulcadman)</li> <li>Fix inference loop #1726   (janmasrovira)</li> <li>Remove wildcard patterns from Internal   #1724   (janmasrovira)</li> <li>Restructure the documentation and add a tutorial   #1718   (lukaszcz)</li> <li>Improve error message for confusing ':=' with '='   #1715   (lukaszcz)</li> <li>Fix #1704 #1711   (janmasrovira)</li> <li>Fix #1693 #1708   (janmasrovira)</li> <li>Tests for the new compilation pipeline   #1703   (lukaszcz)</li> <li>Add printString and printBool support to legacy C backend   #1698   (paulcadman)</li> <li>Add \u2013show-de-bruijn option to <code>juvix repl</code> #1694   (lukaszcz)</li> <li>Allow 'terminating' keyword with builtins   #1688   (lukaszcz)</li> <li>Remove unicode cons symbol   #1687   (lukaszcz)</li> <li>Change syntax for ind. data types and forbid the empty data type   #1684   (jonaprieto)</li> <li>Convert Nat literals to Core integers   #1681   (lukaszcz)</li> <li>Less verbose output from running <code>make check</code> #1675   (jonaprieto)</li> <li>Remove where syntax   #1674   (jonaprieto)</li> <li>Benchmarks #1673   (janmasrovira)</li> <li>JuvixCore to JuvixAsm translation   #1665   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v028-2022-12-20","title":"v0.2.8 (2022-12-20)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Support basic dependencies   #1622   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Refactor hie.yaml and add entry in the readme   #1672   (janmasrovira)</li> <li>Fix inline monospace formatted text in README   #1671   (paulcadman)</li> <li>Pin mdbook to version 0.4.22 in docs build   #1670   (paulcadman)</li> <li>Add option to specify Core transformations to   <code>dev internal core-eval</code> #1669   (paulcadman)</li> <li>Revert \"Ignore binaries generated by running some tests\"   #1668   (jonaprieto)</li> <li>Add configuration files so the project can be built with cabal   #1667   (paulcadman)</li> <li>Add documentation for compiling/running the TicTacToe example   #1664   (paulcadman)</li> <li>Ignore binaries generated by running some tests   #1663   (jonaprieto)</li> <li>Conversion of Nat representation to JuvixCore integers   #1661   (lukaszcz)</li> <li>Move applications inside Lets and Cases   #1659   (lukaszcz)</li> <li>Run shelltests on macOS build   #1658   (paulcadman)</li> <li>Restore macOS CI build/test   #1657   (paulcadman)</li> <li>Remove type arguments and type abstractions from Nodes   #1655   (lukaszcz)</li> <li>Pretty printing of JuvixAsm code   #1650   (lukaszcz)</li> <li>Remove NameId from Core   #1649   (lukaszcz)</li> <li>Translation from JuvixAsm to C   #1619   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v027-2022-12-05","title":"v0.2.7 (2022-12-05)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Add juvix-repl-mode for emacs   #1612   (paulcadman)</li> <li>Make lambda lifting correct when free variables occur in the types   of binders #1609   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Files pure refactor   #1652   (janmasrovira)</li> <li>Use the same stack version in all CI jobs and remove <code>stack setup</code>   step #1651   (paulcadman)</li> <li>Fix 'not a primitive type' error message   #1648   (lukaszcz)</li> <li>Upgrade stack snapshot to use ghc-9.2.5   #1621   (janmasrovira)</li> <li>Add an emacs function to restart the REPL   #1618   (paulcadman)</li> <li>Add types to Core functions and constructors when translating from   Internal #1617   (paulcadman)</li> <li>Auto complete argument of 'dev core read -t'   #1616   (janmasrovira)</li> <li>Compute new entrypoint root when loading a file in the REPL   #1615   (paulcadman)</li> <li>Compute maximum runtime stack height in JuvixReg   #1613   (lukaszcz)</li> <li>Remove shelltest threading   #1611   (paulcadman)</li> <li>Use StackInfo and recurseS in the JuvixAsm to JuvixReg translation.   #1610   (lukaszcz)</li> <li>Precompute maximum heap allocation   #1608   (lukaszcz)</li> <li>Improvements to Juvix REPL   #1607   (paulcadman)</li> <li>Fix discrepancy between Juvix and WASM pages   #1605   (lukaszcz)</li> <li>Compute JuvixAsm stack usage info   #1604   (lukaszcz)</li> <li>Improve As-Pattern parsing   #1603   (ii8)</li> <li>Juvix core recursors should descend into nodes stored in infos   #1600   (janmasrovira)</li> <li>Add docs for installing the linux binary   #1599   (paulcadman)</li> <li>Binder refactor #1598   (janmasrovira)</li> <li>Juvix C runtime #1580   (lukaszcz)</li> <li>As-patterns #1576   (ii8)</li> <li>Eta expansion at the top of each core function definition (#1481)   #1571   (janmasrovira)</li> <li>Add translation from Internal to Core   #1567   (paulcadman)</li> </ul>"},{"location":"CHANGELOG/#v026-2022-10-26","title":"v0.2.6 (2022-10-26)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Support go to definition for the standard library   #1592   (paulcadman)</li> <li>Add builtin if #1585   (paulcadman)</li> <li>Add builtin boolean   #1582   (paulcadman)</li> <li>Add lambda expressions to internal and add typechecking support   #1538   (janmasrovira)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix arity checker bug   #1546   (janmasrovira)</li> <li>Look in patterns when building the dependency graph   #1536   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Update language reference to match current state of Juvix   #1594   (paulcadman)</li> <li>Fix letrec printing   #1591   (janmasrovira)</li> <li>Update stdlib submodule with builtin changes   #1589   (paulcadman)</li> <li>Rename builtin natural to nat and boolean to bool   #1588   (paulcadman)</li> <li>Improve the test for eta-expansion of constructors and builtins   #1583   (lukaszcz)</li> <li>Properly newline expressions in the pretty printer   #1581   (janmasrovira)</li> <li>Letrec lifting #1579   (janmasrovira)</li> <li>Add softlines between applications and hang definitions   #1578   (janmasrovira)</li> <li>Parse optional type info in JVC files   #1575   (lukaszcz)</li> <li>Fix symbol numbering bug   #1574   (lukaszcz)</li> <li>1569 rewrite the test for lambda lifting to use evaluation   #1572   (janmasrovira)</li> <li>Remove lambda from reservedSymbols   #1568   (lukaszcz)</li> <li>Keywords refactor #1566   (janmasrovira)</li> <li>remove \u2254 from the language and replace it by :=   #1563   (janmasrovira)</li> <li>JuvixReg #1551   (lukaszcz)</li> <li>Remove duplicate function in concrete analysis   #1550   (ii8)</li> <li>Evaluator minor style refactor   #1547   (janmasrovira)</li> <li>Properly handle top lambdas in the termination checker   #1544   (janmasrovira)</li> <li>Mutual inference #1543   (janmasrovira)</li> <li>Autocomplete \".jvc\" input files for core {eval, read} commands   #1542   (paulcadman)</li> <li>Add \u2013show-de-bruijn to <code>core eval</code> command   #1540   (paulcadman)</li> <li>Inductive types should depend on the types of their constructors   #1537   (lukaszcz)</li> <li>Parser labels #1535   (janmasrovira)</li> <li>JuvixAsm #1432   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v025-2022-09-14","title":"v0.2.5 (2022-09-14)","text":"<p>Full Changelog</p> <p>Fixed bugs:</p> <ul> <li>Properly type check patterns that need normalization   #1472   (janmasrovira)</li> <li>Detect nested patterns as smaller in the termination checker   #1524</li> <li>Fix developBeta in Core/Extra.hs   #1487   (lukaszcz)</li> <li>Core/Extra/Recursors/Collector bugfix   #1510   (lukaszcz)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Replace -&gt; by := in lambda syntax   #1533   (janmasrovira)</li> <li>'Match' with complex patterns in Core   #1530   (lukaszcz)</li> <li>Refactor CLI #1527   (janmasrovira)</li> <li>Add CanonicalProjection   #1526   (janmasrovira)</li> <li>Make comma a delimiter   #1525   (lukaszcz)</li> <li>Detect nested patterns as smaller in the termination checker   #1524   (janmasrovira)</li> <li>Disallow tab characters as spaces   #1523   (janmasrovira)</li> <li>Refactor <code>destruct</code> in Core/Extra/Base   #1522   (lukaszcz)</li> <li>JuvixCore primitive types   #1521   (lukaszcz)</li> <li>Enable autocompletion for the \u2013theme flag   #1519   (janmasrovira)</li> <li>Stripped version of Core Node datatype   #1518   (lukaszcz)</li> <li>Add <code>internal core read</code> command   #1517   (janmasrovira)</li> <li>Implement some instances for BinderList   #1515   (janmasrovira)</li> <li>Back recursor types with type families   #1514   (janmasrovira)</li> <li>Eager evaluation of Constr arguments   #1513   (lukaszcz)</li> <li>Dynamic type in Core   #1508   (lukaszcz)</li> <li>LetRec in Core #1507   (lukaszcz)</li> <li>Add Haddock and Agda licenses   #1506   (janmasrovira)</li> <li>Fix docs webapp examples CI build   #1505   (paulcadman)</li> <li>Add CLI usage examples doc and integrate with README   #1504   (paulcadman)</li> <li>Refactor BinderInfo   #1503   (lukaszcz)</li> <li>Make <code>juvix compile</code> default to native target   #1502   (paulcadman)</li> <li>Refactor Node datatype   #1501   (lukaszcz)</li> <li>Clean up import list in Pipeline   #1499   (jonaprieto)</li> <li>Remove mono #1497   (jonaprieto)</li> <li>Remove Haskell support   #1496   (jonaprieto)</li> <li>Implement lambda lifting   #1494   (janmasrovira)</li> <li>Document Emacs installation and the 'exec-path' problem   #1493   (lukaszcz)</li> <li>Add \u2013allow-different-user to workflow stack command   #1492   (paulcadman)</li> <li>Stack with github actions permissions workaround   #1490   (paulcadman)</li> <li>Restructure recursors and add some lens interfaces   #1489   (janmasrovira)</li> <li>Add a github action to build a static linux binary   #1488   (paulcadman)</li> <li>Fix developBeta in Core/Extra.hs   #1487   (lukaszcz)</li> <li>Add an option to show name ids in errors   #1486   (lukaszcz)</li> </ul>"},{"location":"CHANGELOG/#v024-2022-08-19","title":"v0.2.4 (2022-08-19)","text":"<p>Full Changelog</p> <p>(Special version for Heliax's retreat in Italy)</p> <p>Implemented enhancements:</p> <ul> <li>Add \u2013stdin flag #1459   (janmasrovira)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix typechecker #1458   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>use \u2013stdin in flycheck mode   #1460   (janmasrovira)</li> <li>Add a native compile target for demos   #1457   (paulcadman)</li> <li>Small changes for the presentation   #1456   (jonaprieto)</li> <li>Fixes TicTacToe Web example   #1454   (paulcadman)</li> <li>Upgrade to ghc-9.2.4   #1451   (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v023-2022-08-15","title":"v0.2.3 (2022-08-15)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>add <code>name</code> and <code>version</code> to <code>juvix.yaml</code> #1422   (janmasrovira)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Properly handle paragraphs in judoc   #1447   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Give a proper type to literal natural numbers   #1453   (janmasrovira)</li> <li>Add the option to output json in the <code>juvix internal highlight</code>   command #1450   (janmasrovira) for supporting the   new Juvix Mode for Visual Studio Code   (jonaprieto)</li> <li>Allow _ in Wasm exported names to support Anoma signature   #1449   (paulcadman)</li> <li>Add Towers of Hanoi and Pascal triangle examples   #1446   (paulcadman)</li> <li>Add <code>juvix init</code> command   #1445   (janmasrovira)</li> <li>Refactor pretty to reduce duplication   #1443   (janmasrovira)</li> <li>Add initial support for examples in Html documentation   #1442   (janmasrovira)</li> <li>Add revisions to README   #1440   (jonaprieto)</li> <li>CI: Run build on push to main   #1437   (paulcadman)</li> <li>Add doctor subcommand   #1436   (paulcadman)</li> <li>CI checkout repo before cache and use recommended cache strategy   #1435   (paulcadman)</li> <li>Various documentation adjustments   #1434   (paulcadman)</li> <li>Setup Clang before building docs in CI   #1433   (paulcadman)</li> <li>Major revisions to Makefile   #1431   (jonaprieto)</li> <li>Do not add <code>-src</code> suffix to links in HTML when running <code>juvix html</code> #1429   (paulcadman)</li> <li>Add a Web version of TicTacToe   #1427   (paulcadman)</li> <li>WASM import all non-compile axioms with alphanum names in entrypoint   #1426   (paulcadman)</li> <li>Export all functions with alpha numeric names from entrypoint module   #1425   (paulcadman)</li> <li>Refactor #1420   (jonaprieto)</li> <li>Permit axiom without a compile block   #1418   (paulcadman)</li> <li>Implement an html documentation generator similar to haddock (#1413)   #1416   (janmasrovira)</li> <li>Fix version shell test for 0.2.2   #1415   (paulcadman)</li> <li>Remove Int from stdlib and update SimpleFungibleToken example   #1414   (paulcadman)</li> </ul>"},{"location":"CHANGELOG/#v022-2022-07-25","title":"v0.2.2 (2022-07-25)","text":"<p>Full Changelog</p> <p>Implemented enhancements:</p> <ul> <li>Compute name dependency graph and filter unreachable definitions   #1408   (lukaszcz)</li> <li>Support type aliases   #1404   (janmasrovira)</li> <li>Add debugging custom function to Prelude   #1401   (jonaprieto)</li> <li>Add positivity check for data types   #1393   (jonaprieto)</li> <li>Keep qualified names   #1392   (janmasrovira)</li> <li>Direct translation from MicroJuvix to MiniC   #1386   (lukaszcz)</li> <li>Widens the accepted symbol list   #1385   (mariari)</li> <li>Check all the type parameter names are different when declaring an   inductive type #1377   (jonaprieto)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Curly braces are allowed nested in patterns   #1380   (janmasrovira)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Add <code>Fail</code> effect (#1409)   #1411   (janmasrovira)</li> <li>Refactor of typechecking and other checking processes   #1410   (jonaprieto)</li> <li>Use bold for code in scoper error messages   #1403   (janmasrovira)</li> <li>Replace ppSimple by text   #1402   (jonaprieto)</li> <li>Implement some error messages (#1396)   #1400   (lukaszcz)</li> <li>Refactor childs of pattern parentheses and braces   #1398   (janmasrovira)</li> <li>Update Juvix standard-library   #1389   (jonaprieto)</li> <li>Fix documentation generation   #1387   (jonaprieto)</li> <li>Adds Collatz sequence generator example   #1384   (paulcadman)</li> <li>html-examples #1381   (jonaprieto)</li> <li>Refine hole in type signature to function type   #1379   (janmasrovira)</li> <li>Type checking fails when the type of a pattern is not given by the   signature #1378   (janmasrovira)</li> <li>Set cname for gh-pages action   #1376   (paulcadman)</li> <li>Add fibonacci sequence example program   #1375   (paulcadman)</li> <li>Fix Changelog links and minors   #1371   (jonaprieto)</li> <li>Add Version number to the emacs mode   #1320   (mariari)</li> </ul>"},{"location":"CHANGELOG/#new-name-juvix","title":"New name: Juvix","text":"<p>Since version 0.2.2, the project has been renamed from \"Mini Juvix\" to \"Juvix\". The new name reflects the fact that the project is no longer just a compiler for a subset of Juvix, but a full implementation of the language. Affected by this change are:</p> <ul> <li>Github repository moved from the Heliax organization to the Anoma   organization. \"anoma/juvix\" is the new repository name.</li> <li>All references to \"Mini Juvix\" have been replaced with \"Juvix\".   Unfortunetly,</li> </ul> <p>due to the move, the old links to the Mini Juvix repository are broken and will not be fixed.</p>"},{"location":"CHANGELOG/#v021-2022-07-12","title":"v0.2.1 (2022-07-12)","text":"<p>Implemented enhancements:</p> <ul> <li>Specialize commands of/for internal use MiniJuvix-#270   (jonaprieto)</li> <li>Improve handling of location information for different objs   MiniJuvix-#263 (jonaprieto)</li> <li>Add issues and PR templates MiniJuvix-#261   (jonaprieto)</li> <li>Throw error when reading a file that conflicts with embedded stdlib   MiniJuvix-#243 (paulcadman)</li> <li>Embed standard library in the minijuvix binary MiniJuvix-#210   (paulcadman)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fixed a bug with the path to walloc.c MiniJuvix-#237   (lukaszcz)</li> <li>Perform ScopedToAbstract exactly once for each module MiniJuvix-#223   (paulcadman)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Label renaming MiniJuvix-#275   (jonaprieto)</li> <li>Update link to discord MiniJuvix-#264   (Romainua)</li> <li>Include <code>open import</code> statements when generating HTML MiniJuvix-#260   (paulcadman)</li> <li>Renaming MiniJuvix to Juvix MiniJuvix-#259   (jonaprieto)</li> <li>Updates tests to use the updated standard library MiniJuvix-#253   (paulcadman)</li> <li>Enforce C99 standard in the generated C files MiniJuvix-#252   (lukaszcz)</li> <li>Restore mascot images to the minijuvix book MiniJuvix-#250   (paulcadman)</li> <li>Allow jumping to another module in emacs MiniJuvix-#249   (janmasrovira)</li> <li>Restore Juvix mascot image to README MiniJuvix-#248   (paulcadman)</li> <li>Add emacs option <code>minijuvix-disable-embedded-stdlib</code> MiniJuvix-#247   (paulcadman)</li> <li>Deprecate GHC backend MiniJuvix-#244   (lukaszcz)</li> <li>Removed 'eval' and 'print' keywords (#214) MiniJuvix-#242   (lukaszcz)</li> <li>Add option to disable minijuvix input method MiniJuvix-#239   (janmasrovira)</li> <li>Remove the 'match' keyword MiniJuvix-#238   (lukaszcz)</li> <li>Removed tests/positive/HelloWorld.mjuvix and specified clang version   in the documentation MiniJuvix-#236   (lukaszcz)</li> <li>Filter symbol entries properly in the scoper MiniJuvix-#234   (janmasrovira)</li> <li>Use the ModulesCache for <code>open</code> statements in ScopedToAbstract pass   MiniJuvix-#224 (paulcadman)</li> <li>README: Include <code>--recursive</code> in git clone command to fetch stdlib   MiniJuvix-#211 (paulcadman)</li> <li>Update project description v0.2.0 MiniJuvix-#209   (jonaprieto)</li> <li>Unify AST representation of types and expressions in MicroJuvix   MiniJuvix-#188 (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v020-2022-06-28","title":"v0.2.0 (2022-06-28)","text":"<p>Implemented enhancements:</p> <ul> <li>Support built in types MiniJuvix-#192   (janmasrovira)</li> <li>Support partial application and closure passing in C backend   MiniJuvix-#190 (paulcadman)</li> <li>Allow <code>open import</code> statements MiniJuvix-#175   (janmasrovira)</li> <li>Remove TypeAny and adapt typechecking for literals MiniJuvix-#173   (janmasrovira)</li> <li>Allow holes to be refined into function types MiniJuvix-#165   (janmasrovira)</li> <li>Support implicit arguments MiniJuvix-#144   (janmasrovira)</li> <li>Add support for holes in type signatures MiniJuvix-#141   (janmasrovira)</li> <li>Support function closures with no environment in minic   MiniJuvix-#137 (paulcadman)</li> <li>Add holes for expressions in function clauses and inference support   MiniJuvix-#136 (janmasrovira)</li> <li>Add \"-Oz\" optimization flag to clang args MiniJuvix-#133   (paulcadman)</li> <li>Add version and help option and root command to the CLI   MiniJuvix-#131 (jonaprieto)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Fix: Ignore implicit patterns and arguments in termination checking   MiniJuvix-#172 (janmasrovira)</li> <li>Fix: pretty printing for terminating keyword MiniJuvix-#145   (jonaprieto)</li> </ul> <p>Merged pull requests:</p> <ul> <li>Fix: proper error handling for typechecker errors MiniJuvix-#189   (jonaprieto)</li> <li>Add juvix version info and date to HTML output MiniJuvix-#186   (jonaprieto)</li> <li>Fix: Add check for constructor return types MiniJuvix-#182   (jonaprieto)</li> <li>Use Abstract name in Abstract syntax and Micro/MonoJuvix   MiniJuvix-#181 (janmasrovira)</li> <li>Add an option to specify the path where to put the HTML output   MiniJuvix-#179 (jonaprieto)</li> <li>Upgrade to ghc-9.2.3 MiniJuvix-#178   (janmasrovira)</li> <li>Replace dead link in README with a link to the Juvix book   MiniJuvix-#177 (paulcadman)</li> <li>Embed HTML assets in the juvix binary MiniJuvix-#176   (paulcadman)</li> <li>Fix: identifiers with a keyword prefix cannot be parsed   MiniJuvix-#171 (janmasrovira)</li> <li>Improve filepath equality MiniJuvix-#170   (janmasrovira)</li> <li>Update validity predicate milestone example to 0.2 syntax   MiniJuvix-#167 (paulcadman)</li> <li>Fix links in documentation and update to new syntax MiniJuvix-#163   (paulcadman)</li> <li>Update stdlib to work with version 0.2 MiniJuvix-#160   (janmasrovira)</li> <li>Update README usage example to use the compile command   MiniJuvix-#158 (paulcadman)</li> <li>Remove dead code related to the pipeline MiniJuvix-#156   (janmasrovira)</li> <li>Add negative test for AppLeftImplicit MiniJuvix-#154   (janmasrovira)</li> <li>Add positive test designed for implicit arguments MiniJuvix-#153   (janmasrovira)</li> <li>Remove ExpressionTyped from MicroJuvix MiniJuvix-#143   (janmasrovira)</li> <li>Revision for package.yaml and minor deletions MiniJuvix-#135   (jonaprieto)</li> </ul>"},{"location":"CHANGELOG/#v014-2022-05-30","title":"v0.1.4 (2022-05-30)","text":"<p>Merged pull requests:</p> <ul> <li>Generic Errors and refactoring MiniJuvix-#123   (jonaprieto)</li> <li>Only generates docs if the pull request merges MiniJuvix-#121   (jonaprieto)</li> <li>Add initial docs generation website MiniJuvix-#119   (jonaprieto)</li> <li>Fix internal link in README MiniJuvix-#116   (paulcadman)</li> <li>Add minic-runtime for linking without libc MiniJuvix-#113   (paulcadman)</li> <li>Add termination checking to the pipeline MiniJuvix-#111   (jonaprieto)</li> <li>Support uncurried higher order functions MiniJuvix-#110   (paulcadman)</li> <li>Improve error generation and handling MiniJuvix-#108   (janmasrovira)</li> <li>Add MiniC tests with clang+wasi-sdk MiniJuvix-#105   (paulcadman)</li> <li>Add usage example and move developer docs MiniJuvix-#96   (paulcadman)</li> <li>Refactor warning related stuff MiniJuvix-#91   (janmasrovira)</li> <li>Remove Agda backend MiniJuvix-#86   (paulcadman)</li> </ul> <p>Implemented enhancements:</p> <ul> <li>Add <code>compile</code> subcommand to generate binaries MiniJuvix-#128</li> <li>Add intervals to flycheck errors MiniJuvix-#124</li> <li>Improve error handling in juvix-mode MiniJuvix-#107</li> <li>Support multiple modules in compilation MiniJuvix-#93</li> <li>Add compile command to CLI MiniJuvix-#130   (paulcadman)</li> <li>Use Interval in GenericErrors MiniJuvix-#125   (janmasrovira)</li> <li>Remove dev in the CI and other tweaks MiniJuvix-#118   (jonaprieto)</li> <li>Highlight comments correctly MiniJuvix-#106   (janmasrovira)</li> <li>Support multiple modules in compilation MiniJuvix-#100   (janmasrovira)</li> <li>New target syntax and modular VP examples MiniJuvix-#92   (jonaprieto)</li> </ul> <p>Fixed bugs:</p> <ul> <li>Missing error messages when using throw/error MiniJuvix-#117</li> <li>Fix highlight of comments MiniJuvix-#104</li> <li>Fix juvix-mode coloring for projects with multiple modules   MiniJuvix-#101</li> <li>Fix <code>highlight</code> command for modules with import statements   MiniJuvix-#102 (janmasrovira)</li> </ul> <p>Closed issues:</p> <ul> <li>Deprecate the class JuvixError MiniJuvix-#115</li> <li>Add ToGenericError instance for the infix parsing errors   MiniJuvix-#114</li> <li>Compile to WASM without linking libc MiniJuvix-#112</li> <li>Add the termination checker to the pipeline MiniJuvix-#109</li> <li>Use clang + wasi-sdk instead of emcc to compile to WASM   MiniJuvix-#103</li> <li>Move developer tooling docs out of README MiniJuvix-#95</li> <li>Add pre-commit checks to CI checks MiniJuvix-#94</li> <li>Support higher order functions in C backend MiniJuvix-#90</li> <li>Remove dev from the list of branches in the CI MiniJuvix-#89</li> <li>Refactor warning related stuff MiniJuvix-#87</li> <li>The Juvix website MiniJuvix-#51</li> </ul>"},{"location":"CHANGELOG/#v013-2022-05-05","title":"v0.1.3 (2022-05-05)","text":"<p>Closed issues:</p> <ul> <li>Monomorphisation naming inconsistency MiniJuvix-#84</li> <li>Remove BackendAgda MiniJuvix-#83</li> <li>Change terminating keyword behavior MiniJuvix-#81</li> <li>MonoJuvix <code>ExpressionTyped</code> is never used MiniJuvix-#79</li> <li>Bump stackage nightly and delete <code>allow-newer: true</code> from   <code>stack.yaml</code> MiniJuvix-#75</li> <li>Generate automatically CHANGELOG and Github Release Notes   MiniJuvix-#73</li> <li>Make flag \u2013show-name-ids global MiniJuvix-#61</li> <li>Add C code generation backend MiniJuvix-#60</li> <li>Add polymorphism MiniJuvix-#59</li> <li>Add the compile keyword to the frontend syntax (support up to   Scoping) MiniJuvix-#58</li> <li>Error with undefined or underscores MiniJuvix-#54</li> <li>Add support for other GHC and Stack stable version MiniJuvix-#52</li> <li>Autodetect output ANSI support when prettyprinting MiniJuvix-#38</li> <li>Terminating for type signatures MiniJuvix-#11</li> </ul> <p>Merged pull requests:</p> <ul> <li>Remove agda backend MiniJuvix-#86   (paulcadman)</li> <li>84 monomorphisation naming inconsistency MiniJuvix-#85   (janmasrovira)</li> <li>Change terminating keyword behavior MiniJuvix-#82   (jonaprieto)</li> <li>Remove unused constructor ExpressionTyped in Monojuvix MiniJuvix-#80   (janmasrovira)</li> <li>Stricter stack builds and pedantic mode for CI MiniJuvix-#78   (jonaprieto)</li> <li>Bump stackage version and remove allow-newer MiniJuvix-#76   (janmasrovira)</li> <li>Add automatically updates/issues/merged PRs to the changelog   MiniJuvix-#74 (jonaprieto)</li> <li>Add terminating keyword MiniJuvix-#71   (jonaprieto)</li> <li>Monomorphization MiniJuvix-#70   (janmasrovira)</li> <li>Remove StatementCompile in AST after scoping MiniJuvix-#69   (paulcadman)</li> <li>Add C code generation backend MiniJuvix-#68   (paulcadman)</li> <li>Check if stderr supports ANSI and print accordingly MiniJuvix-#67   (janmasrovira)</li> <li>Add support for compile (by Jonathan) MiniJuvix-#66   (paulcadman)</li> <li>Add NameIdGen effect to the pipeline MiniJuvix-#64   (janmasrovira)</li> <li>Make the <code>--show-name-ids</code> flag global MiniJuvix-#63   (janmasrovira)</li> <li>Implement type checker with polymorphism MiniJuvix-#62   (janmasrovira)</li> </ul>"},{"location":"CHANGELOG/#v012-2022-04-11","title":"v0.1.2 (2022-04-11)","text":"<p>Closed issues:</p> <ul> <li>Add en emacs mode with support for scoped highlighting MiniJuvix-#25</li> <li>Add support for project root detection through a juvix.yaml file   MiniJuvix-#24</li> <li>Add CLI cmd to generate juvix autocompletion files for fish and zsh   MiniJuvix-#23</li> <li>Add pretty and typecheck subcommands to the microjuvix CLI   MiniJuvix-#21</li> <li>Translate identifiers from MicroJuvix to MiniHaskell (valid Haskell)   MiniJuvix-#19</li> <li>Implement the MiniHaskell to Haskell translation (prettyprinter)   MiniJuvix-#18</li> <li>Implementation of a typechecker for MicroJuvix MiniJuvix-#16</li> <li>Add references to the Abstract AST to update compilation to   MiniHaskell MiniJuvix-#12</li> <li>Order in the house MiniJuvix-#10</li> </ul> <p>Merged pull requests:</p> <ul> <li>The Juvix project now follows the same goals as the original Juvix   project. MiniJuvix-#7 (jonaprieto)</li> <li>Dev\u2192main MiniJuvix-#6 (jonaprieto)</li> <li>Big update including termination checking MiniJuvix-#5   (janmasrovira)</li> <li>Parser and scoper MiniJuvix-#3   (jonaprieto)</li> <li>Upgrade to ghc9 and use hpack MiniJuvix-#2   (janmasrovira)</li> <li>Merge MiniJuvix-#1 (jonaprieto)</li> </ul>"},{"location":"CHANGELOG/#v011-2022-03-25","title":"v0.1.1 (2022-03-25)","text":"<ul> <li>Add support in the parser/scoper for Axiom backends</li> <li>Add support for <code>foreign</code> keyword</li> <li>Add flag <code>--no-colors</code> for the scope command</li> <li>Upgrade to GHC 9.2.2</li> <li>Improve resolution of local symbols in the scoper</li> <li>Several new tests related to ambiguous symbols</li> <li>Add <code>--version</code> flag</li> <li>Add InfoTableBuilder effect for the scoper</li> </ul> <p>Closed issues:</p> <ul> <li>Add diff output to the test suite MiniJuvix-#9</li> <li>Improve scoper ambiguity error messages MiniJuvix-#8</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing to Juvix","text":"<p>Thank you for considering contributing to Juvix! We welcome all contributions, big or small, of any kind. We appreciate any help/feedback we can get.</p>"},{"location":"CONTRIBUTING/#getting-started","title":"Getting Started","text":"<p>Make sure you have followed the installation instructions and have a working Juvix installation. You can also use the web-based development environment ready to the Juvix development, Juvix Github Codespace</p> <ol> <li>Fork the repository.</li> <li>Clone your forked repository to your local machine.</li> <li>Install Stack if you    haven't already.</li> <li>Build the project by running <code>stack build</code>. To build the project with    optimizations, run <code>stack build --fast</code>. To install the binaries to your    local <code>~/.local/bin</code>, run <code>stack install</code>.</li> <li>Run the tests by running <code>stack test</code>.</li> <li>Make sure to install the pre-commit binary, so you    can run the pre-commit hooks by running <code>make precommit</code> in the root    directory of the project. All the Pull Requests will be checked by the    pre-commit hooks.</li> </ol>"},{"location":"CONTRIBUTING/#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your changes: <code>git checkout -b my-branch-name</code>. In case you are working on an issue, please name your branch after the issue number, e.g. <code>issue-123</code>.</li> <li>Make your changes and commit them with a descriptive message.</li> <li>Push your changes to your forked repository: <code>git push origin my-branch-name</code>.</li> <li>Submit a pull request to the main repository with a concise description of your changes.</li> <li>Make sure that your pull request passes all the tests and pre-commit hooks.</li> </ol>"},{"location":"CONTRIBUTING/#haskell-code-style","title":"Haskell Code Style","text":"<p>We value readability and maintainability over saving lines of code. The best source of truth for the Juvix code style is the existing codebase. We strongly encourage you to look at the existing code and follow the same style. Open an issue if you have any questions, or better yet, join our Discord and ask there!</p> <p>Some basic guidelines when writing code:</p> <ul> <li>Use clear and descriptive names for variables, functions, and types.</li> <li>Keep functions short and focused on a single task. Separate functions when   they start to get too long.</li> <li>Use comments to explain complex or non-obvious code.</li> <li>Run <code>make format</code> to format your code with <code>ormolu</code>.</li> </ul>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>Please include tests for any new functionality or bug fixes. The tests are located in the <code>test</code> directory, the tests are written in Haskell and use the tasty framework. To run the tests, run <code>stack test</code>. If you are changing the CLI, please also update the smoke tests in the <code>tests/smoke</code> directory.</p>"},{"location":"CONTRIBUTING/#code-review","title":"Code Review","text":"<p>All pull requests will be reviewed by at least one member of the development team. Feedback may be provided on the code itself, as well as on the tests and documentation.</p> <p>Thank you for contributing to Juvix!</p>"},{"location":"LICENSE/","title":"LICENSE","text":"<pre><code>                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    &lt;one line to give the program's name and a brief idea of what it does.&gt;\n    Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    &lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n&lt;https://www.gnu.org/licenses/&gt;.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n&lt;https://www.gnu.org/licenses/why-not-lgpl.html&gt;.\n</code></pre>"},{"location":"overview/","title":"Juvix","text":"CI Status   Codebase   <p>Juvix is an open-source, constantly evolving functional programming language designed for writing privacy-preserving decentralized applications. Using Juvix, developers can write high-level programs which can be compiled to WASM directly, or through VampIR to circuits for private execution with Taiga on Anoma or Ethereum.</p>"},{"location":"overview/#getting-started","title":"Getting Started","text":"<p>To get started with Juvix, head over to the documentation website to learn more about the language and its features. You can also find installation instructions and tutorials to help you get started with writing Juvix programs. You can download the latest release from the Juvix GitHub repository or use the web-based development environment, Juvix Github Codespace, which provides a pre-configured workspace ready to use with Juvix and the Haskell toolchain installed.</p>"},{"location":"overview/#language-features","title":"Language features","text":"<p>Juvix is designed with a focus on safety. The Juvix compiler runs several static analyses which guarantee the absence of runtime errors. Analyses performed include termination and type checking. As a result, functional programs, especially validity predicates, can be written with greater confidence in their correctness.</p> <p>Some language features in Juvix include:</p> <ul> <li>Haskell/Agda-like syntax with support for Unicode</li> <li>Type inference</li> <li>Parametric polymorphism</li> <li>User defined inductive data types</li> <li>Higher-order functions</li> <li>Referential transparency</li> </ul> <p>The Juvix module system allows developers to break down their programs into smaller, reusable modules that can be compiled separately and combined to create larger programs. These modules can be used to build libraries, which can then be documented using Juvix's built-in documentation generation tool, see for example, the Juvix standard library's website. For further details, please refer to the Juvix book which includes our latest updates.</p>"},{"location":"overview/#related-projects","title":"Related projects","text":"<p>If you're interested in Juvix, you may also want to explore the following related projects:</p> Project Description GEB Intermediate language for writing compilers and one of the Juvix backends. VampIR Proof-system-agnostic language for writing arithmetic circuits and one of the GEB backends. Taiga A framework for generalized shielded state transitions."},{"location":"overview/#resources","title":"Resources","text":"<p>Here is a summary of resources to help you learn more about Juvix:</p>"},{"location":"overview/#documentation","title":"Documentation","text":"Resource Description Official website The official website of Juvix, where you can find documentation, changelog, tutorials, and community resources. GitHub repository The official GitHub repository of Juvix, where you can find the source code and contribute to the project."},{"location":"overview/#community","title":"Community","text":"Resource Description Discord community The Juvix community on Discord is a space where you can connect with the developers behind Juvix and other members of the community who are passionate about privacy-preserving decentralized applications. It's a place where you can ask for help with using Juvix, discuss the latest features and updates, and get involved in the project. Twitter The official Twitter account of Juvix, where you can stay up-to-date with the latest news and announcements."},{"location":"overview/#libraries","title":"Libraries","text":"Resource Description Standard library The Juvix standard library is a collection of pre-written functions and modules that come bundled with the Juvix programming language. It provides developers with a set of common and useful tools that they can use to build their Juvix programs without having to write everything from scratch."},{"location":"overview/#ide-support","title":"IDE support","text":"Resource Description VSCode extension Support for the Juvix programming language with features such as syntax highlighting, error checking and many more directly in the VSCode editor. Emacs Juvix mode A major mode for Emacs that provides support for writing Juvix programs."},{"location":"overview/#development-environments","title":"Development environments","text":"Resource Description Juvix Standard Lib Codespace A web-based development environment for the Juvix standard library on GitHub. It provides a pre-configured workspace with the Juvix standard library installed and ready to use, so you can start using the library in your projects. Some examples of Juvix programs are also loaded in this environment. Juvix Github Codespace This codespace provides a pre-configured workspace with Juvix and the Haskell toolchain installed. Everything is ready to use, so you can start developing/inspecting the Juvix compiler right away."},{"location":"overview/#installation","title":"Installation","text":"Resource Description Homebrew Juvix formula A formula for Homebrew, a package manager for macOS and Linux, that allows you to easily install Juvix on your system. Juvix Nightly builds Users can download and use these nightly builds to experiment with the latest changes to the Juvix Compiler. Nightly builds may contain new features, bug fixes, and other improvements to Juvix that are still in development and have not yet been released in an official version."},{"location":"overview/#contributing","title":"Contributing","text":"<p>If you're interested in contributing to Juvix, please see the contributing guidelines for more information. We welcome contributions of all kinds, from bug reports and feature requests to code contributions and documentation improvements.</p>"},{"location":"overview/#license","title":"License","text":"<p>Juvix is open-source software released under the GNU General Public License v3.0. See the LICENSE file for more information.</p>"},{"location":"quick-start/","title":"Quick Start","text":"<p>To install Juvix, follow the instructions in the Installation How-to.</p> <p>After installation, run <code>juvix --help</code> to see the list of commands.</p> <p>Run Juvix doctor to check your system setup:</p> <pre><code>juvix doctor\n</code></pre>"},{"location":"quick-start/#cli-usage-examples","title":"CLI Usage Examples","text":"<p>Create a new package:</p> <pre><code>juvix init\n</code></pre> <p>Compile a source file into an executable:</p> <pre><code>juvix compile path/to/source.juvix\n</code></pre> <p>Compile a source file into a WebAssembly binary:</p> <pre><code>juvix compile -t wasm path/to/source.juvix\n</code></pre> <p>Launch the REPL:</p> <pre><code>juvix repl\n</code></pre> <p>Typecheck a source file:</p> <pre><code>juvix typecheck path/to/source.juvix\n</code></pre> <p>Generate HTML representations of a source file and its imports:</p> <pre><code>juvix html --recursive path/to/source.juvix\n</code></pre>"},{"location":"quick-start/#the-hello-world-example","title":"The Hello World example","text":"<p>This is the Juvix source code of the traditional Hello World program.</p> <pre><code>-- HelloWorld.juvix\nmodule HelloWorld;\n\nopen import Stdlib.Prelude;\n\nmain : IO;\nmain := printStringLn \"hello world!\";\n\nend;\n</code></pre> <p>To compile and run a binary generated by Juvix, save the source code to a file called <code>HelloWorld.juvix</code> and run the following command from the directory containing it:</p> <pre><code>juvix compile HelloWorld.juvix\n./HelloWorld\n</code></pre> <p>You should see the output: <code>hello world!</code></p> <p>The source code can also be compiled to a WebAssembly binary. This requires some additional setup. See the Installation How-to for more information. You can also run <code>juvix doctor</code> to check your setup.</p> <pre><code>juvix compile --target wasm HelloWorld.juvix\nwasmer HelloWorld.wasm\n</code></pre>"},{"location":"about/community/","title":"Juvix community","text":"<p>Join us on our Discord server</p> <p>This project is part of a bigger effort called Anoma. Anoma is a suite of protocols and mechanisms for self-contained, self-sovereign coordination. Join the Anoma project.</p>"},{"location":"blog/","title":"Juvix Blog","text":"<p>Hola and welcome to the Juvix blog!</p> <p>Welcome to our cosy corner, where we dive into the world of functional programming and next-generation distributed apps! We'll be exploring Juvix and beyond, discussing fascinating aspects and applications. So come on in, and let's embark on this exciting journey together!</p>"},{"location":"blog/#what-can-you-expect","title":"What can you expect?","text":"<p>Throughout our articles, you'll discover functional programming (FP), and potentially, implementation notes pertinent to the ongoing development cycles of Juvix. Our primary objective is to share our insights about Juvix while encouraging discussions centred on functional programming concepts and methodologies.</p>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/","title":"Stay Positive with Your Data Types","text":"<p>In this blog post, we will investigate the notion of strictly positive inductive data types, which is a condition that Juvix mandates for a data type to be considered well-typed.</p> <p>An inductive type is considered strictly positive if it either:</p> <ol> <li>Does not appear within the argument types of its constructors, or</li> <li>Appears strictly positively within the argument types of its constructors.</li> </ol> <p>A name is considered strictly positive for an inductive type if it never appears in a negative position within the argument types of its constructors. The term negative position denotes instances located to the left of an arrow in a type constructor argument.</p>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/#example","title":"Example","text":"<p>Consider the following data type <code>X</code> where <code>A</code> and <code>B</code> are types in scope:</p> <pre><code>  type X :=\n    | c0 : (B -&gt; X) -&gt; X\n    | c1 : (X -&gt; A) -&gt; X;\n</code></pre> <p>In this example, the type <code>X</code> occurs strictly positive in the constructor <code>c0</code>, but negatively in the constructor <code>c1</code> in the type argument <code>X -&gt; A</code>. Therefore, <code>X</code> is not strictly positive.</p> <p>Positive parameters can also be described as those that do not occur in negative positions. For instance, the type <code>B</code> in the <code>c0</code> constructor above appears to the left of the arrow <code>B-&gt;X</code>, placing <code>B</code> in a negative position. It is essential to consider negative parameters when verifying strictly positive data types, as they might enable the definition of non-strictly positive data types.</p> <p>Let us consider another example:</p> <pre><code>  type T0 (A : Type) :=\n    | c0 : (A -&gt; T0 A) -&gt; T0 A;\n</code></pre> <pre><code>  type T1 :=\n    | c1 : T0 T1 -&gt; T1;\n</code></pre> <p>In this example, the type <code>T0</code> is strictly positive, while the type <code>T1</code> is not. It is only after unfolding the type application <code>T0 (T1 A)</code> in the data constructor <code>c1</code> that we can determine <code>T1</code> occurs in a negative position due to <code>T0</code>. More specifically, the type parameter <code>A</code> of <code>T0</code> is negative.</p>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/#bypassing-the-strict-positivity-condition","title":"Bypassing the Strict Positivity Condition","text":"<p>To bypass the positivity check in a data type declaration, you can annotate it with the <code>positive</code> keyword. Alternatively, you can use the CLI global flag <code>--no-positivity</code> when type checking a <code>Juvix</code> file.</p> <pre><code>  positive\n  type T0 (A : Type) :=\n    | c0 : (T0 A -&gt; A) -&gt; T0 A;\n</code></pre>"},{"location":"blog/2022/07/25/stay-positive-with-your-data-types/#examples-of-non-strictly-positive-data-types","title":"Examples of Non-Strictly Positive Data Types","text":"<ul> <li>The <code>Bad</code> data type is not strictly positive due to the negative parameter <code>A</code>   of <code>Tree</code>.</li> </ul> <pre><code>  type Tree (A : Type) :=\n    | leaf : Tree A\n    | node : (A -&gt; Tree A) -&gt; Tree A;\n</code></pre> <pre><code>  type Bad :=\n    | bad : Tree Bad -&gt; Bad;\n</code></pre> <ul> <li><code>A</code> is a negative parameter.</li> </ul> <pre><code>  type B (A : Type) :=\n    | b : (A -&gt; B (B A -&gt; A)) -&gt; B A;\n</code></pre>"},{"location":"explanations/typetheory/","title":"Type theory","text":""},{"location":"explanations/totality/coverage/","title":"Coverage checking","text":""},{"location":"explanations/totality/positive/","title":"Strictly positive data types","text":""},{"location":"explanations/totality/termination/","title":"Termination","text":"<p>To prevent inconsistencies arising from function declarations, Juvix mandates that every function passes its termination checker. Nevertheless, this requirement can be challenging to meet; thus, we provide users with two distinct methods for bypassing this check:</p>"},{"location":"explanations/totality/termination/#keyword","title":"Keyword","text":"<p>Utilize the terminating keyword to annotate function type signatures as terminating. In the following example we mark the function <code>fun</code> as terminating.</p> <pre><code>terminating\nfun : A \u2192 B;\n</code></pre> <p>Note</p> <p>Annotating a function with the <code>terminating</code> keyword indicates that all of its function clauses meet the termination checker's criteria. For mutual recursive functions, to bypass the termination checker, all involved functions must be annotated as <code>terminating</code>.</p>"},{"location":"explanations/totality/termination/#cli-flag","title":"CLI flag","text":"<p>Utilizing the global CLI flag --no-termination.</p> <pre><code>juvix typecheck --no-termination MyProgram.juvix\n</code></pre> <p>Note</p> <p>Please note that our termination checker has certain limitations, as it only accepts a subset of recursive functions. The algorithm used in the termination checker is a minor adaptation of the one employed for checking termination in the Foetus language.</p>"},{"location":"howto/compilation/","title":"Compiling simple programs","text":"<p>A Juvix file must declare a module whose name corresponds exactly to the name of the file. For example, a file <code>Hello.juvix</code> must declare a module <code>Hello</code>:</p> <pre><code>-- Hello world example. This is a comment.\nmodule Hello;\n\n-- Import the standard library prelude, including the 'String' type\nopen import Stdlib.Prelude;\n\nmain : String;\nmain := \"Hello world!\";\n</code></pre> <p>A file compiled to an executable must define the zero-argument function <code>main</code> of type <code>IO</code> which is evaluated when running the program.</p> <p>To compile the file <code>Hello.juvix</code> type <code>juvix compile Hello.juvix</code>. Typing <code>juvix compile --help</code> will list all options to the <code>compile</code> command.</p>"},{"location":"howto/compilation/#compilation-targets","title":"Compilation targets","text":"<p>Since version 0.3 Juvix supports three compilation targets. The targets are specified with the <code>-t</code> option: <code>juvix compile -t target file.juvix</code>.</p> <ol> <li><code>native</code>. This is the default. Produces a native 64bit executable     for your machine.</li> <li><code>wasm32-wasi</code>. Produces a WebAssembly binary which uses the WASI     runtime.</li> <li><code>geb</code>. Produces a GEB input file.</li> </ol>"},{"location":"howto/compilation/#compilation-options","title":"Compilation options","text":"<p>To see all compilation options type <code>juvix compile --help</code>. The most commonly used options are:</p> <ul> <li><code>-t target</code>: specify the target,</li> <li><code>-g</code>: generate debug information and runtime assertions,</li> <li><code>-o file</code>: specify the output file.</li> </ul>"},{"location":"howto/compilation/#juvix-projects","title":"Juvix projects","text":"<p>A Juvix project is a collection of Juvix modules inside one main project directory containing a <code>juvix.yaml</code> metadata file. The name of each module must coincide with the path of the file it is defined in, relative to the project's root directory. For example, if the file is <code>root/Data/List.juvix</code> then the module must be called <code>Data.List</code>, assuming <code>root</code> is the project's directory.</p> <p>To interactively initialize a Juvix project in the current directory, use <code>juvix init</code>.</p> <p>To check that Juvix is correctly detecting your project's root, you can run the command <code>juvix dev root File.juvix</code>.</p> <p>See also: Modules Reference.</p>"},{"location":"howto/installing/","title":"Dependencies","text":"<p>You need Clang / LLVM version 13 or later. Note that on macOS the preinstalled clang does not support the wasm target, so use e.g. <code>brew install llvm</code> instead.</p> <p>If you want to compile to WebAssembly, you also need:</p> <ul> <li>wasmer</li> <li>wasi-sdk</li> <li>wasm-ld - the LLVM linker for WASM (NB: On   Linux you may need to install the <code>lld</code> package; on macOS this is   installed as part of <code>llvm</code>).</li> </ul> <p>See below for instructions on how to install the dependencies.</p>"},{"location":"howto/installing/#installing-juvix","title":"Installing Juvix","text":""},{"location":"howto/installing/#macos","title":"MacOS","text":"<p>The easiest way to install Juvix on MacOS is by using Homebrew.</p> <p>To install the homebrew-juvix tap, run:</p> <pre><code>brew tap anoma/juvix\n</code></pre> <p>To install Juvix, run:</p> <pre><code>brew install juvix\n</code></pre> <p>Helpful information can also be obtained by running:</p> <pre><code>brew info juvix\n</code></pre>"},{"location":"howto/installing/#linux-x8664","title":"Linux x86<sub>64</sub>","text":"<p>A Juvix compiler binary executable for Linux x86<sub>64</sub> is available on the Juvix release page.</p> <p>To install this executable, download and unzip the linked file and move it to a directory on your shell's <code>PATH</code>.</p> <p>For example if <code>~/.local/bin</code> is on your shell's <code>PATH</code>, you can install Juvix as follows:</p> <pre><code>cd /tmp\ncurl -OL https://github.com/anoma/juvix/releases/download/v0.3.1/juvix-linux_x86_64-v0.3.1.zip\nunzip juvix-linux_x86_64-v0.3.1.zip\nmv juvix-linux_x86_64-v0.3.1 ~/.local/bin/juvix\n</code></pre>"},{"location":"howto/installing/#building-juvix-from-source","title":"Building Juvix from source","text":"<p>To install Juvix from source you must clone the Github repository. Then Juvix can be installed with the following commands. We assume you have Stack and GNU Make installed.</p> <pre><code>git clone --recursive https://github.com/anoma/juvix.git\ncd juvix\nmake install\n</code></pre> <p>The C compiler and linker paths can be specified as options to the <code>make install</code> command, e.g.</p> <pre><code>make install CC=path/to/clang LIBTOOL=path/to/llvm-ar\n</code></pre> <p>On MacOS, you can alternatively run the following command for Homebrew. The flag <code>--HEAD</code> used below is optional \u2013 use it to build the latest version of Juvix in the <code>main</code> branch on Github.</p> <pre><code>brew install --build-from-source --HEAD juvix --verbose\n</code></pre>"},{"location":"howto/installing/#building-the-project-with-cabal","title":"Building the project with <code>cabal</code>","text":"<p>We recommend to use the <code>stack</code> build tool with this project.</p> <p>If you prefer the <code>cabal</code> build tool instead, then you need to generate the <code>juvix.cabal</code> file using hpack before running <code>cabal build</code>.</p> <p>You also need to compile the runtime first:</p> <pre><code>make runtime\ncabal build\n</code></pre>"},{"location":"howto/installing/#installing-dependencies","title":"Installing dependencies","text":"<p>To install <code>wasi-sdk</code> you need to download <code>libclang_rt</code> and <code>wasi-sysroot</code> precompiled archives from the wasi-sdk release page and:</p> <ol> <li> <p>Extract the <code>libclang_rt.builtins-wasm32-wasi-*.tar.gz</code> archive in     the <code>clang</code> installation root (for example <code>/usr/lib/clang/13</code> on     Ubuntu or <code>`brew --prefix llvm`</code> on macOS).</p> <p>For example on macOS with <code>homebrew clang</code>:</p> </li> </ol> <pre><code>cd `brew --prefix llvm`\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/libclang_rt.builtins-wasm32-wasi-15.0.tar.gz -OL\ntar xf libclang_rt.builtins-wasm32-wasi-15.0.tar.gz\n</code></pre> <ol> <li> <p>Extract the <code>wasi-sysroot-*.tar.gz</code> archive on your local system and     set <code>WASI_SYSROOT_PATH</code> to its path.</p> <p>For example:</p> </li> </ol> <pre><code>cd ~\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/wasi-sysroot-15.0.tar.gz -OL\ntar xf wasi-sysroot-15.0.tar.gz\nexport WASI_SYSROOT_PATH=~/wasi-sysroot\n</code></pre>"},{"location":"howto/judoc/","title":"Documenting Juvix programs with Judoc","text":""},{"location":"notes/lsp/","title":"LSP support","text":"<p>We provide a sample <code>hie.yaml</code> configuration file for both <code>cabal</code> and <code>stack</code>.</p> <p>If you prefer <code>stack</code>, run:</p> <pre><code>cp stack.hie.yaml hie.yaml\n</code></pre> <p>If you prefer <code>cabal</code>, run:</p> <pre><code>cp cabal.hie.yaml hie.yaml\n</code></pre>"},{"location":"notes/runtime-benchmark-results/","title":"Benchmarks of the new Juvix runtime","text":"<p>Benchmarked version: commit 148ececb4d4259eacbb980f5992073a3ac611d82 from 31.10.2022</p>"},{"location":"notes/runtime-benchmark-results/#summary","title":"Summary","text":"<p>We benchmark several programs manually compiled into the primitives of the new Juvix runtime. The code corresponds closely to the code that will be generated by the new compilation process, with basic low-level optimisations (unboxing, untagging, etc.) but without any high-level optimisations on JuvixCore (inlining, specialisation, constant folding, fusion, etc.). This corresponds to the compilation process planned for the 0.4 milestone.</p> <p>We compare the running time and memory usage with analogous programs written in Haskell, OCaml, JuvixCore (using the evaluator), current Juvix (with the \"direct\" transpilation to C) and C.</p> <p>The results suggest that for most first-order programs the new compilation process will produce code with running time comparable to the code produced by the native OCaml compiler. For higher-order programs heavy on closure manipulation, the results are acceptable but noticeably worse, especially with third-order functions (i.e. functions which take functions taking functions). This could, however, be alleviated by implementing the specialisation optimisation (see the \"specialised\" column in the `ackermann` and `mapfun` benchmarks). Besides, functional programs of order higher than two are rare.</p> <p>The comparisons with OCaml and Haskell were not entirely fair because the new Juvix runtime does not perform garbage collection. The overhead of garbage collection is particularly visible on the `mergesort` benchmark which creates many intermediate data structures that are quickly discarded. With proper memory management, the running time results on first-order programs for the new Juvix runtime are expected to become slightly worse than for the native OCaml compiler.</p> <p>For simple programs operating on integers which don't require any heap memory allocation (`fibonacci` and `combinations` benchmarks), the direct transpilation to C in the current Juvix seems to perform best (behind only C). The reason is that for very simple programs `clang` can better optimise the output of such a direct transpiler. The main problem with the transpilation to C approach is that it cannot scale to reliably work for more complex programs, as evidenced by the segfaults, longer running time and higher memory use on other benchmarks.</p> <p>In addition to the `fibonacci` and `combinations` benchmarks, the advantage of direct transpilation for very simple programs is also visible on the `fold` benchmark where a simple loop over a list dominates the running time. However, this is partly because the compilation of closures in current Juvix is incorrect allowing it to be more efficient.</p>"},{"location":"notes/runtime-benchmark-results/#benchmark-programs","title":"Benchmark programs","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci-compute-the-nth-fibonacci-number-modulo-228-n-100000000","title":"fibonacci: compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)","text":"<p>The Nth Fibonacci number is computed in O(N). Needs only constant stack space and no heap memory. This benchmark tests the efficiency of tail recursion and arithmetic operations.</p>"},{"location":"notes/runtime-benchmark-results/#combinations-count-combinations-of-numbers-1-to-n-having-sum-n-n-100","title":"combinations: count combinations of numbers 1 to N having sum N (N = 100)","text":"<p>This benchmark tests the efficiency of general recursion. No heap memory needs to be allocated. Uses stack space proportional to N. The running time is exponential in N.</p>"},{"location":"notes/runtime-benchmark-results/#prime-compute-the-nth-prime-n-16384","title":"prime: compute the Nth prime (N = 16384)","text":"<p>The Nth prime number is computed via the Eratosthenes sieve. A list of N primes is created. No intermediate lists are discarded (garbage collection not needed). This benchmark tests the efficiency of tail recursion, arithmetic operations, list cell allocation and access.</p>"},{"location":"notes/runtime-benchmark-results/#mergesort-merge-sort-a-list-of-n-integers-n-2000000","title":"mergesort: merge sort a list of N integers (N = 2\u2019000\u2019000)","text":"<p>At each level of merge sort intermediate lists are created and discarded. The running time for this benchmark largely depends on the efficiency of memory management. Here one may observe the overhead of garbage collection or the memory blow-up if no garbage collection is used.</p>"},{"location":"notes/runtime-benchmark-results/#maybe-optionally-sum-n-integers-from-a-binary-tree-k-times-n-220-k-100","title":"maybe: optionally sum N integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)","text":"<p>If a fixed number k is encountered in the tree then the result is `Nothing`, otherwise it is `Just sum`. The computation is repeated for values of k from 0 to K. This tests the efficiency of handling optional values and data structure access.</p>"},{"location":"notes/runtime-benchmark-results/#fold-fold-a-list-of-n-integers-k-times-n-100000-k-1000","title":"fold: fold a list of N integers K times (N = 100\u2019000, K = 1000)","text":"<p>The sum of N natural numbers is computed via fold<sub>left</sub> (tail-recursive). The computation is repeated K times. The list is created only once, so that allocation time does not dominate. This benchmark tests the efficiency of closure call and list cell access.</p>"},{"location":"notes/runtime-benchmark-results/#cps-compute-the-nth-fibonacci-number-modulo-228-with-cps-n-100000000","title":"cps: compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)","text":"<p>The function computing the Nth Fibonacci number is written in continuation-passing style, tail-recursively calling a continuation supplied as an argument. This benchmark tests the efficiency of closure call and allocation.</p>"},{"location":"notes/runtime-benchmark-results/#mapfold-map-and-fold-a-list-of-n-integers-k-times-n-10000-k-10000","title":"mapfold: map and fold a list of N integers K times (N = 10000, K = 10000)","text":"<p>This benchmark tests the efficiency of standard higher-order functions on lists, closure call and memory management. The program allocates O(K) intermediate lists of length N which are quickly discarded.</p>"},{"location":"notes/runtime-benchmark-results/#ackermann-compute-ack3-n-with-the-higher-order-ackermann-function-definition-n-11","title":"ackermann: compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)","text":"<p>The higher-order Ackermann function definition iterates an iteration of function compositions. Hence, it uses a third-order invocation of an iteration function. This benchmark tests the efficiency of creating and calling second-order closures, and of partial application.</p>"},{"location":"notes/runtime-benchmark-results/#mapfun-successively-map-k-functions-to-a-list-of-n-integers-k-100-n-10000","title":"mapfun: successively map K functions to a list of N integers (K = 100, N = 10000)","text":"<p>The benchmark stores K second-order closures in a list, maps them successively to a list of K closures, and then successively maps the K closures from the result to a list of N integers. This benchmark tests the efficiency of manipulating closures and storing them in data structures.</p> <p>The benchmark programs can be found in `tests/benchmark` in the Juvix source directory.</p>"},{"location":"notes/runtime-benchmark-results/#methodology","title":"Methodology","text":"<p>For each program the total running time (elapsed real time) and memory use (maximum resident set size) were measured on an M1 iMac with no significant background activity. Averages of several runs were taken. The variance was negligible, unless indicated otherwise by providing a range.</p>"},{"location":"notes/runtime-benchmark-results/#results","title":"Results","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci-compute-the-nth-fibonacci-number-modulo-228-n-100000000_1","title":"fibonacci: compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.26 0.35 0.35 0.23 13.15 10.03 0.39 0.35 0.94 0.16 0.22 Memory use (MB, max RSS) 1.5 3.8 1.3 8.8 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#combinations-count-all-combinations-of-numbers-1-to-n-having-sum-n-n-1000","title":"combinations: count all combinations of numbers 1 to N having sum N (N = 1000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 6.67 11.25 3.22 5.1 441.71 5.48 5.48 6.53 41.08 2.69 4.80 Memory use (MB, max RSS) 1.5 3.9 1.3 8.9 22.3 9.6 9.6 1.7 1.9 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#prime-compute-the-nth-prime-n-16384_1","title":"prime: compute the Nth prime (N = 16384)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.52 1.91 segfault 3.09 167.04 3.85 3.85 1.68 14.82 0.12 0.13 Memory use (MB, max RSS) 1.7 4.0 segfault 9.3 24.4 9.8 9.6 2.2 2.2 1.4 4.0"},{"location":"notes/runtime-benchmark-results/#mergesort-merge-sort-a-list-of-n-integers-n-2000000_1","title":"mergesort: merge sort a list of N integers (N = 2\u2019000\u2019000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.40 0.31 3.55 1.32 22.45 2.86 2.90 1.95 3.52 0.15 0.15 Memory use (MB, max RSS) 1973.7 720.4 5046.7 2729.8 1728.9 253.6 253.6 172.6 343.1 24.4 26.8"},{"location":"notes/runtime-benchmark-results/#maybe-optionally-sum-n-non-zero-integers-from-a-binary-tree-k-times-n-220-k-100","title":"maybe: optionally sum N non-zero integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.64 3.29 1.57 22.75 5.58 0.59 0.30 3.57 0.27 0.50 Memory use (MB, max RSS) 1.6 3.8 2646.1 1320.9 22.4 5560.7 9.7 3.9 4.0 1.3 4.1"},{"location":"notes/runtime-benchmark-results/#fold-fold-a-list-of-n-integers-k-times-n-100000-k-1000_1","title":"fold: fold a list of N integers K times (N = 100\u2019000, K = 1000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.54 0.35 0.23 15.27 0.58 0.58 0.36 1.80 NA NA Memory use (MB, max RSS) 3.1 4.6 4.4 10.6 43.4 12.7 12.7 5.9 5.9 NA NA"},{"location":"notes/runtime-benchmark-results/#cps-compute-the-nth-fibonacci-number-modulo-228-with-cps-n-100000000_1","title":"cps: compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.43 0.52 1.56 stack overflow 20.22 10.04 0.39 0.35 1.60 0.16 0.25 Memory use (MB, max RSS) 1.5 3.9 1539.3 stack overflow 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfold-map-and-fold-a-list-of-n-integers-k-times-n-10000-k-10000_1","title":"mapfold: map and fold a list of N integers K times (N = 10000, K = 10000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.01 1.59 2.74 1.81 38.24 1.29 2.42 1.43 4.22 NA NA Memory use (MB, max RSS) 2154.5 893.0 3059.1 1542.0 26.4 10.6 10.7 7.5 10-20 NA NA"},{"location":"notes/runtime-benchmark-results/#ackermann-compute-ack3-n-with-the-higher-order-ackermann-function-definition-n-11_1","title":"ackermann: compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.92 1.21 0.30 0.65 segfault runtime error 11.71 0.87 0.47 0.54 1.35 0.00 0.14 Memory use (MB, max RSS) 2.6 4.1 2.3 3.9 segfault runtime error 23.3 13.6 9.6 2.0 3.6 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfun-successively-map-k-functions-to-a-list-of-n-integers-k-100-n-10000_1","title":"mapfun: successively map K functions to a list of N integers (K = 100, N = 10000)","text":"New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.27 1.04 0.39 0.46 segfault runtime error 4.18 1.85 0.95 0.19 0.68 NA NA Memory use (MB, max RSS) 3209.8 1229.7 21.8 13.2 segfault runtime error 33.0 13.6 11.6 5.3 7.9 NA NA <p>Comments</p>"},{"location":"notes/runtime-benchmark-results/#new-juvix-runtime-denotes-c-programs-written-using-the-primitives","title":"\"New Juvix runtime\" denotes C programs written using the primitives","text":"<p>of the new Juvix runtime. These programs were \"manually\" compiled from the corresponding Juvix/JuvixCore programs, according to the new Juvix compilation concept. They correspond closely to the code that will be generated by the basic version of the new compilation process, without any high-level optimisations (inlining, specialisation, fusion, constant folding) but with basic low-level memory representation optimisations (unboxing, untagging, etc). This version of the new compilation process should be finished with the 0.4 milestone.</p>"},{"location":"notes/runtime-benchmark-results/#the-specialised-column-for-new-juvix-runtime-denotes-a-version","title":"The \"specialised\" column for \"New Juvix runtime\" denotes a version","text":"<p>of the corresponding \"New Juvix runtime\" benchmark program for which specialisation of higher-order functions was manually performed (to simulate the effects of the high-level specialisation optimisation).</p>"},{"location":"notes/runtime-benchmark-results/#current-juvix-denotes-juvix-programs-compiled-with-the-current","title":"\"Current Juvix\" denotes Juvix programs compiled with the current","text":"<p>compilation process via a \"direct\" translation to C. For a fair comparison, all number operations were implemented using native binary C integers (exposed via `foreign` and `compile` blocks) without overflow check, instead of using the unary Nat from the standard library. For Haskell, we use the fixed-precision Int instead of the arbitrary-precision Integer.</p>"},{"location":"notes/runtime-benchmark-results/#for-the-simplest-benchmark-programs-without-heap-memory-allocation","title":"For the simplest benchmark programs without heap memory allocation","text":"<p>(e.g. `fibonacci`, `combinations`), the performance of \"Current Juvix\" is comparable to or better than that of \"New Juvix runtime\". This is because `clang` managed to eliminate (tail) recursion and optimise the code to essentially the same or better thing. The main problem with the current \"direct\" transpilation to C approach is that it cannot scale to reliably work for more complex programs. By \"more complex\" I mean larger program size, more functions, more complex patterns of recursion and/or the use of more functional programming features (including functional data structures). I don't mean higher computational complexity or more resource use.</p>"},{"location":"notes/runtime-benchmark-results/#the-segfaults-and-runtime-errors-for-current-juvix-are","title":"The segfaults and runtime errors for \"Current Juvix\" are","text":"<p>consequences of incorrectly generated code (current compilation of partial application is not entirely correct) or stack overflows (when `clang` didn't figure out how to eliminate tail recursion).</p>"},{"location":"notes/runtime-benchmark-results/#the-comparison-with-current-juvix-is-not-entirely-fair-for","title":"The comparison with \"Current Juvix\" is not entirely fair for","text":"<p>benchmarks that test the manipulation and calling of closures (e.g. `fold`). Current Juvix achieves good performance (when it doesn't segfault) at the expense of correctness: partial application is not compiled correctly and fixing this would require a fundamental change in closure representation.</p>"},{"location":"notes/runtime-benchmark-results/#the-comparison-with-haskell-and-ocaml-compilers-is-not-entirely","title":"The comparison with Haskell and OCaml compilers is not entirely","text":"<p>fair, because the new Juvix runtime does not perform garbage collection. With the GC overhead, I would expect the Juvix runtime results for native compilation of first-order programs to become a bit worse than the native OCaml versions. The GC overhead is particularly noticeable for the `mergesort` benchmark which creates many large intermediate lists. The memory usage of the Juvix runtime is much higher on this benchmark than the memory usage of OCaml or Haskell versions. The relatively small time difference between the OCaml native and bytecode versions of `mergesort` also indicates that GC accounts for a significant part of the running time.</p>"},{"location":"notes/runtime-benchmark-results/#another-small-overhead-will-be-introduced-by-bounds-checking-for","title":"Another small overhead will be introduced by bounds checking for","text":"<p>integer operations. Currently, the new Juvix runtime operates on unboxed 31-bit (or 63-bit) integers without checking for integer overflow.</p>"},{"location":"notes/runtime-benchmark-results/#if-we-decide-to-default-to-transparent-arbitrary-precision-integers","title":"If we decide to default to transparent arbitrary-precision integers,","text":"<p>then another small overhead will be introduced by the need to check the integer representation with each arithmetic operation.</p>"},{"location":"notes/runtime-benchmark-results/#admittedly-the-programs-were-deliberately-written-in-a-way-to-make","title":"Admittedly, the programs were deliberately written in a way to make","text":"<p>high-level optimisations unnecessary, except specialisation for higher-order functions (mostly in `ackermann` and `mapfun`). This also explains the good performance of the OCaml native compiler which doesn't do much high-level optimisation.</p>"},{"location":"notes/runtime-benchmark-results/#in-the-current-juvix-and-ocaml-version-of-mergesort-to-avoid","title":"In the \"Current Juvix\" and OCaml version of `mergesort`, to avoid","text":"<p>stack overflow the `merge` function was written tail-recursively with accumulator reversal at the end. This is not necessary for the new Juvix runtime, because the stack is dynamically extended when needed.</p>"},{"location":"notes/runtime-benchmark-results/#as-evidenced-by-the-combinations-benchmark-for-non-tail-recursive","title":"As evidenced by the `combinations` benchmark, for non-tail-recursive","text":"<p>direct calls our code performs worse than the code which uses the C / WebAssembly stack and function call mechanisms. However, in general it is impossible to directly use the C / WebAssembly stack and call mechanisms for a purely functional language. Since we dynamically allocate the stack segments when needed, stack overflow is impossible. This is convenient in an eager functional language. Otherwise, one needs to rewrite all functions operating on large data to use tail recursion. We pay for this convenience with a small overhead, which is the main reason for poorer performance on `combinations` where stack manipulation cost dominates.</p>"},{"location":"notes/runtime-benchmark-results/#haskells-laziness-seems-to-introduce-more-overhead-than-i","title":"Haskell's laziness seems to introduce more overhead than I","text":"<p>expected. This would explain the comparatively better performance of the native OCaml compiler. The problem is particularly stark when Haskell's strictness analysis fails for some reason, as in the `fibonacci` benchmark. The second \"Haskell\" column with the \"-XStrict\" flag for GHC indicates the version of the benchmark compiled with strictness as the default.</p>"},{"location":"notes/runtime-benchmark-results/#the-c-versions-of-the-programs-were-written-to-take-advantage-of-cs","title":"The C versions of the programs were written to take advantage of C's","text":"<p>imperative features, e.g., using arrays instead of lists, loops instead of recursion. No C versions are provided for some benchmarks designed to test specifically functional language features.</p>"},{"location":"notes/runtime-benchmark-results/#with-the-new-juvix-runtime-the-32-bit-webassembly-version-of","title":"With the new Juvix runtime, the 32-bit WebAssembly version of","text":"<p>`mergesort` is faster than the 64-bit native version because it needs roughly half as much memory (the word size is 4 bytes instead of 8). The difference is even starker between the WebAssembly and native versions of `mergesort` for \"Current Juvix\".</p>"},{"location":"notes/runtime-benchmark-results/#there-seems-to-be-a-memory-leak-in-the-juvixcore-evaluator-this-is","title":"There seems to be a memory leak in the JuvixCore evaluator. This is","text":"<p>what happens too often when one uses a lazy language.</p>"},{"location":"notes/runtime-benchmark-results/#haskell-also-leaks-memory-in-the-fibonacci-benchmark-despite-it","title":"Haskell also leaks memory in the Fibonacci benchmark, despite it","text":"<p>being a simple tail-recursive program. It seems strictness analysis didn't work.</p>"},{"location":"reference/benchmarks/","title":"Benchmarks","text":""},{"location":"reference/examples/","title":"Example programs","text":""},{"location":"reference/examples/#examples-of-programs-written-in-juvix","title":"Examples of programs written in Juvix","text":"<p>The following links are clickable versions of their corresponding Juvix programs. The HTML output is generated by running <code>juvix html --recursive FileName.juvix</code>.</p> <ul> <li>HelloWorld.juvix</li> <li>Fibonacci.juvix</li> <li>Hanoi.juvix</li> <li>PascalsTriangle.juvix</li> <li>Collatz.juvix</li> <li>TicTacToe.juvix</li> </ul> <p>The Juvix standard library contains common functions that can be used in Juvix programs.</p>"},{"location":"reference/judoc/","title":"Judoc syntax reference","text":"<p>Judoc is used to document parts of your code. You can attach Judoc blocks to the following entities:</p> <ol> <li>A module.</li> <li>A type definition.</li> <li>A constructor definition.</li> <li>A type signature of a function.</li> <li>An axiom definition.</li> </ol> <p>In order to attach documentation to any of these entities, write blocks of documentation before them:</p> <ol> <li>For modules:</li> </ol> <pre><code>--- This module is cool\nmodule Cool;\n..\n</code></pre> <ol> <li>For type definitions:</li> </ol> <pre><code>--- Unary representation of natural numbers\ntype Nat : Type :=\n  | --- Nullary constructor representing number 0\n    zero : Nat\n  | --- Unary constructor representing the successor of a natural number\n    suc : Nat -&gt; Nat;\n</code></pre> <ol> <li>For type signatures (and likewise for axioms):</li> </ol> <pre><code>--- The polymorphic identity function\nid : {A : Type} -&gt; A -&gt; A;\n</code></pre> <p>Next we define the syntax of Judoc blocks.</p>"},{"location":"reference/judoc/#block","title":"Block","text":"<p>A block can be one of these:</p> <ol> <li>A paragraph.</li> <li>An example.</li> </ol> <p>Blocks are separated by a line with only <code>---</code>. For instance, this is a sequence of two blocks:</p> <pre><code>--- First block\n---\n--- Second block\n</code></pre> <p>Note that the following is a single block since it lacks the <code>---</code> separator:</p> <pre><code>--- First block\n\n--- Still first block\n</code></pre>"},{"location":"reference/judoc/#paragraph","title":"Paragraph","text":"<p>A paragraph is a non-empty sequence of lines.</p> <p>For instance, the following is a paragraph with two lines:</p> <pre><code>--- First line\n--- Second line\n</code></pre> <p>Note that a rendered paragraph will have have no line breaks. If you want to have line breaks, you will need to split the paragraph. Hence, the paragraph above will be rendered as</p> <pre><code>First line Second line\n</code></pre>"},{"location":"reference/judoc/#line","title":"line","text":"<p>A line starts with <code>---</code> and is followed by a non-empty sequence of atoms.</p> <p>For instance, the following is a valid line:</p> <pre><code>--- A ;Pair Int Bool; contains an ;Int; and a ;Bool;\n</code></pre>"},{"location":"reference/judoc/#atom","title":"Atom","text":"<p>An atom is either:</p> <ol> <li>A string of text (including spaces but not line breaks).</li> <li>An inline Juvix expression surrounded by <code>;</code>.</li> </ol> <p>For instance, the following are valid atoms:</p> <ol> <li><code>I am some text.</code></li> <li><code>;Pair Int Bool;</code></li> </ol>"},{"location":"reference/judoc/#example","title":"Example","text":"<p>An example is of the following form</p> <pre><code>--- &gt;&gt;&gt; someExpression ;\n</code></pre> <p>The <code>someExpression</code> can span multiple lines and it must be ended with a <code>;</code>. For instance:</p> <pre><code>--- &gt;&gt;&gt; 1\n        + 2\n        + 3;\n</code></pre>"},{"location":"reference/stdlib/","title":"Standard library","text":"<p>The Juvix standard library contains common functions that can be used in Juvix programs.</p>"},{"location":"reference/language/axioms/","title":"Axiom","text":"<p>Axioms or postulates can be introduced by using the <code>axiom</code> keyword. For example, let us imagine one wants to write a program that assumes A is a type, and there exists a term x that inhabits A. Then the program would look like the following.</p> <pre><code>module axioms;\n\naxiom A : Type;\n\naxiom x : A;\n</code></pre> <p>Terms introduced by the <code>axiom</code> keyword lack any computational content. Programs containing axioms not marked as builtins cannot be compiled to most targets.</p>"},{"location":"reference/language/builtins/","title":"Built-ins","text":"<p>Juvix has support for the built-in natural type and a few functions that are compiled to efficient primitives.</p>"},{"location":"reference/language/builtins/#built-in-inductive-definitions","title":"Built-in inductive definitions","text":"<pre><code>builtin nat\ntype Nat :=\n  | zero : Nat\n  | suc : Nat \u2192 Nat;\n</code></pre>"},{"location":"reference/language/builtins/#builtin-function-definitions","title":"Builtin function definitions","text":"<pre><code>infixl 6 +;\nbuiltin nat-plus\n+ : Nat \u2192 Nat \u2192 Nat;\n+ zero b := b;\n+ (suc a) b := suc (a + b);\n</code></pre>"},{"location":"reference/language/builtins/#builtin-axiom-definitions","title":"Builtin axiom definitions","text":"<pre><code>open import Stdlib.System.IO;\nbuiltin nat-print\naxiom printNat : Nat \u2192 IO;\n</code></pre>"},{"location":"reference/language/comments/","title":"Comments","text":"<p>Comments follow the same syntax as in <code>Haskell</code> and <code>Agda</code>. Be aware, Juvix has no support for nested comments.</p> <ul> <li>Inline Comment</li> </ul> <pre><code>-- This is a comment!\n</code></pre> <ul> <li>Region comment</li> </ul> <pre><code>{-\n    This is a comment!\n-}\n</code></pre> <ul> <li>Judoc inline comments. These are used to document functions and types. See Judoc for more information.</li> </ul> <pre><code>--- This is a Judoc comment!\n</code></pre>"},{"location":"reference/language/control/","title":"Control structures","text":""},{"location":"reference/language/control/#case","title":"Case","text":"<p>A case expression has the following syntax:</p> <pre><code>case value\n| pat1 := branch1\n..\n| patN := branchN\n</code></pre> <p>For example, one can evaluate the following expression in the REPL:</p> <pre><code>Stdlib.Prelude&gt; case 2 | zero := 0 | suc x := x | _ := 19\n1\n</code></pre>"},{"location":"reference/language/control/#lazy-builtins","title":"Lazy builtins","text":"<p>The standard library provides several builtin functions which are treated specially and evaluated lazily. These builtins must always be fully applied.</p> <ul> <li><code>if condition branch1 branch2</code>. First evaluates <code>condition</code>, if true   evaluates and returns <code>branch1</code>, otherwise evaluates and returns   <code>branch2</code>.</li> <li><code>a || b</code>. Lazy disjunction. First evaluates <code>a</code>, if true returns   true, otherwise evaluates and returns <code>b</code>.</li> <li><code>a &amp;&amp; b</code>. Lazy conjunction. First evaluates <code>a</code>, if false returns   false, otherwise evaluates and returns <code>b</code>.</li> <li><code>a &gt;&gt; b</code>. Sequences two IO actions. Lazy in the second argument.</li> </ul>"},{"location":"reference/language/datatypes/","title":"Data types","text":"<p>A data type declaration consists of:</p> <ul> <li>The <code>type</code> keyword,</li> <li>a unique name for the type,</li> <li>the <code>:=</code> symbol, and</li> <li>a non-empty list of constructor declarations (functions for   building the elements of the data type).</li> </ul> <p>The simplest data type is the <code>Unit</code> type with one constructor called <code>unit</code>.</p> <pre><code>type Unit := unit : Unit;\n</code></pre> <p>In the following example, we declare the type <code>Nat</code> \u2013 the unary representation of natural numbers. This type comes with two constructors: <code>zero</code> and <code>suc</code>. Example elements of type <code>Nat</code> are the number one represented by <code>suc zero</code>, the number two represented by <code>suc (suc zero)</code>, etc.</p> <pre><code>type Nat :=\n  | zero : Nat\n  | suc : Nat -&gt; Nat;\n</code></pre> <p>Constructors can be used like normal functions or in patterns when defining functions by pattern matching. For example, here is a function adding two natural numbers:</p> <pre><code>infixl 6 +;\n+ : Nat -&gt; Nat -&gt; Nat;\n+ zero b := b;\n+ (suc a) b := suc (a + b);\n</code></pre> <p>A data type can possess type parameters. When a data type has a type parameter <code>A</code>, it is referred to as polymorphic in <code>A</code>. A classic example of this concept is the <code>List</code> type, which is polymorphic in the type of its list elements.</p> <pre><code>  infixr 5 ::;\n  type List (A : Type) :=\n    | nil : List A\n    | :: : A -&gt; List A -&gt; List A;\n</code></pre> <p>The following function determines whether an element is in a list or not.</p> <pre><code>  open import Stdlib.Data.Bool using {Bool; false; ||};\n\n  elem :\n    {A : Type} -&gt; (A -&gt; A -&gt; Bool) -&gt; A -&gt; List A -&gt; Bool;\n  elem _ _ nil := false;\n  elem eq s (x :: xs) := eq s x || elem eq s xs;\n</code></pre> <p>For more examples of inductive types and how to use them, see the Juvix standard library.</p>"},{"location":"reference/language/functions/","title":"Function declarations","text":"<p>A function declaration consists of a type signature and a group of function clauses.</p> <p>In the following example, we define a function <code>multiplyByTwo</code>. The first line <code>multiplyByTwo : Nat -&gt; Nat;</code> is the type signature and the second line <code>multiplyByTwo n := 2 * n;</code> is a function clause.</p> <pre><code>open import Stdlib.Data.Nat;\nmultiplyByTwo : Nat -&gt; Nat;\nmultiplyByTwo n := 2 * n;\n</code></pre> <p>A function may have more than one function clause. When a function is called, the first clause that matches the arguments is used.</p> <p>The following function has two clauses.</p> <pre><code>open import Stdlib.Data.Bool;\nneg : Bool -&gt; Bool;\nneg true := false;\nneg false := true;\n</code></pre> <p>When <code>neg</code> is called with <code>true</code>, the first clause is used and the function returns <code>false</code>. Similarly, when <code>neg</code> is called with <code>false</code>, the second clause is used and the function returns <code>true</code>.</p>"},{"location":"reference/language/functions/#mutually-recursive-functions","title":"Mutually recursive functions","text":"<p>Function declarations can depend on each other recursively. In the following example, we define a function that checks if a number is <code>even</code> by calling a function that checks if a number is <code>odd</code>.</p> <pre><code>open import Stdlib.Data.Nat;\nopen import Stdlib.Data.Bool;\n\nopen import Stdlib.Prelude;\n\nodd : Nat -&gt; Bool;\neven : Nat -&gt; Bool;\n\nodd zero := false;\nodd (suc n) := even n;\n\neven zero := true;\neven (suc n) := odd n;\n</code></pre>"},{"location":"reference/language/functions/#anonymous-functions","title":"Anonymous functions","text":"<p>Anonymous functions, or lambdas, are introduced with the syntax:</p> <pre><code>\\{| pat1 .. patN_1 := clause1\n  | ..\n  | pat1 .. patN_M := clauseM }\n</code></pre> <p>The first pipe <code>|</code> is optional. Instead of <code>\\</code> one can also use <code>\u03bb</code>.</p> <p>An anonymous function just lists all clauses of a function without naming it. Any function declaration can be converted to use anonymous functions:</p> <pre><code>open import Stdlib.Prelude;\n\nodd : Nat -&gt; Bool;\neven : Nat -&gt; Bool;\n\nodd := \\{\n  | zero := false\n  | (suc n) := even n\n};\n\neven := \\{\n  | zero := true\n  | (suc n) := odd n\n};\n</code></pre>"},{"location":"reference/language/functions/#short-definitions","title":"Short definitions","text":"<p>A function definition can be written in one line, with the body immediately following the signature:</p> <pre><code>open import Stdlib.Data.Nat;\nmultiplyByTwo : Nat -&gt; Nat := \\{ n := 2 * n };\n</code></pre>"},{"location":"reference/language/let/","title":"Local definitions","text":"<p>Local definitions are introduced with the <code>let</code> construct.</p> <pre><code>open import Stdlib.Prelude;\n\nsum : List Nat -&gt; Nat;\nsum lst :=\n  let\n    go : Nat -&gt; List Nat -&gt; Nat;\n    go acc nnil := acc;\n    go acc (x :: xs) := go (acc + x) xs;\n  in\n  go zero lst;\n</code></pre> <p>The declarations within a <code>let</code> statement share the same syntax as those inside a module. However, their visibility is limited to the expression that follows the <code>in</code> keyword.</p>"},{"location":"reference/language/modules/","title":"Module system","text":""},{"location":"reference/language/modules/#defining-a-module","title":"Defining a module","text":"<p>The <code>module</code> keyword stars the declaration of a module followed by its name and body. The module declaration ends with the <code>end</code> keyword.</p> <pre><code>-- ModuleName.juvix\nmodule ModuleName;\n\nend;\n</code></pre> <p>A Juvix project is a collection of Juvix modules inside one main project folder containing a metadata file named <code>juvix.yaml</code>. Each Juvix file has to define a module of the same name. The name of the module must coincide with the path of its file relative to its project's root directory. For example, if the file is <code>root/Data/List.juvix</code> then the module must be called <code>Data.List</code>, assuming <code>root</code> is the project's folder.</p> <p>To check that Juvix is correctly detecting your project's root, one can run the command <code>juvix dev root File.juvix</code>.</p>"},{"location":"reference/language/modules/#importing-modules","title":"Importing modules","text":"<p>To bring into the current scope all module definitions from other external modules, one can use the <code>import</code> keyword along with the corresponding module name. This way, one gets all the imported names qualified.</p> <pre><code>-- A.juvix\nmodule A;\n   axiom\n   Nat : Type;\n\n   axiom\n   zero : Nat;\nend;\n\n-- B.juvix\nmodule B;\n    import A;\n    x : A.Nat;\n    x := A.zero;\n</code></pre> <p>Additionally, one can open an imported module making available all its names by their unqualified name.</p> <pre><code>-- A.juvix\nmodule A;\n   axiom\n   Nat : Type;\n\n   axiom\n   zero : Nat;\nend;\n\n-- B.juvix\nmodule B;\n    import A;\n    open A;\n    x : Nat;\n    x := zero;\nend;\n</code></pre> <p>However, opening modules may create name collisions if you already have the imported names as definitions in the current module. In this case, Juvix will complain with an error, letting you know which symbols are ambiguous. For example, in module <code>B</code> below, the name <code>a</code> is ambiguous.</p> <pre><code>-- A.juvix\nmodule A;\naxiom\nA : Type;\n\naxiom\na : A;\nend;\n\n-- B.juvix\nmodule B;\n\nimport A;\nopen A;\n\naxiom\na : A;\n\nx := a;\nend;\n</code></pre> <p>One alternative here is hiding the name <code>a</code> as follows.</p> <pre><code>-- B.juvix\nmodule B;\nimport A;\nopen A hiding {a};\n\naxiom\na : A;\n\n\nx := a;\n\nend;\n</code></pre> <p>Now, we can use the <code>open import</code> syntax to simplify the <code>import-open</code> statements.</p> <p>Instead of having:</p> <pre><code>import Prelude;\nopen Prelude;\n</code></pre> <p>We simplify it by the expression:</p> <pre><code>open import Prelude;\n</code></pre> <p>The <code>hiding</code> keyword can be used within an <code>open-import</code> statement.</p> <pre><code>-- B.juvix\nmodule A;\nopen import A hiding {a};\n\naxiom\na : A;\n\nx := a;\nend;\n</code></pre>"},{"location":"reference/language/modules/#exporting-symbols","title":"Exporting symbols","text":"<p>The module <code>C</code> below does not typecheck. Both symbols, originally defined in module <code>A</code>, are not visible in module <code>C</code> after importing <code>B</code>. The symbols <code>A</code> and <code>a</code> are not exported by the module <code>B</code>. To export symbols from an imported module, one can use the <code>public</code> keyword at the end of the corresponding <code>open</code> statement. For example, the module <code>C</code> typechecks after marking the import of <code>A</code> as <code>public</code> in module <code>B</code>.</p> <pre><code>-- A.juvix\nmodule A;\naxiom\nA : Type;\n\naxiom\na : A;\n\nend;\n\n-- B.juvix\nmodule B;\nopen import A;\nend;\n\n-- C.juvix\nmodule C;\nopen import B;\n\nx : A;\nx := a;\nend;\n</code></pre> <p>Fix:</p> <pre><code>-- B.juvix\nmodule B;\nopen import A public;\nend;\n</code></pre>"},{"location":"reference/tooling/CLI/","title":"CLI","text":""},{"location":"reference/tooling/CLI/#usage","title":"Usage","text":"<pre><code>juvix [Global options] ((-v|--version) | (-h|--help) | COMPILER_CMD | UTILITY_CMD)\n</code></pre>"},{"location":"reference/tooling/CLI/#informative-options","title":"Informative options","text":"<ul> <li><code>-v,--version</code> Print the version and exit</li> <li><code>-h,--help</code> Show this help text</li> </ul>"},{"location":"reference/tooling/CLI/#global-command-flags","title":"Global Command flags","text":"<ul> <li><code>--no-colors</code> Disable globally ANSI formatting</li> <li><code>--show-name-ids</code> Show the unique number of each identifier when   pretty printing</li> <li><code>--only-errors</code> Only print errors in a uniform format (used by   juvix-mode)</li> <li><code>--no-termination</code> Disable termination checking</li> <li><code>--no-positivity</code> Disable positivity checking for inductive types</li> <li><code>--no-stdlib</code> Do not use the standard library</li> </ul>"},{"location":"reference/tooling/CLI/#main-commands","title":"Main Commands","text":"<ul> <li><code>html</code> Generate HTML output from a Juvix file</li> <li><code>typecheck</code> Typecheck a Juvix file</li> <li><code>compile</code> Compile a Juvix file</li> </ul>"},{"location":"reference/tooling/CLI/#utility-commands","title":"Utility Commands","text":"<ul> <li><code>doctor</code> Perform checks on your Juvix development environment</li> <li><code>init</code> Interactively initialize a Juvix project in the current   directory</li> </ul>"},{"location":"reference/tooling/CLI/#dev-commands","title":"Dev Commands","text":"<pre><code>juvix dev COMMAND\n</code></pre> <ul> <li><code>parse</code> Parse a Juvix file</li> <li><code>scope</code> Parse and scope a Juvix file</li> <li><code>highlight</code> Highlight a Juvix file</li> <li><code>core</code> Subcommands related to JuvixCore</li> <li><code>asm</code> Subcommands related to JuvixAsm</li> <li><code>root</code> Show the root path for a Juvix project</li> <li><code>termination</code> Subcommands related to termination checking</li> <li><code>internal</code> Subcommands related to Internal</li> <li><code>minic</code> Translate a Juvix file to a subset of C</li> </ul>"},{"location":"reference/tooling/CLI/#cli-auto-completion-scripts","title":"CLI Auto-completion Scripts","text":"<p>The Juvix CLI can generate auto-completion scripts. Follow the instructions below for your shell.</p> <p>NB: You may need to restart your shell after installing the completion script.</p>"},{"location":"reference/tooling/CLI/#bash","title":"Bash","text":"<p>Add the following line to your bash init script (for example <code>~/.bashrc</code>).</p> <pre><code>eval \"$(juvix --bash-completion-script juvix)\"\n</code></pre>"},{"location":"reference/tooling/CLI/#fish","title":"Fish","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --fish-completion-script juvix\n  &gt; ~/.config/fish/completions/juvix.fish\n</code></pre>"},{"location":"reference/tooling/CLI/#zsh","title":"ZSH","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --zsh-completion-script juvix &gt; $DIR_IN_FPATH/_juvix\n</code></pre> <p>where <code>$DIR_IN_FPATH</code> is a directory that is present on the ZSH FPATH variable (which you can inspect by running <code>echo $FPATH</code> in the shell).</p>"},{"location":"reference/tooling/doctor/","title":"Juvix Doctor","text":"<p>The <code>juvix doctor</code> command can help you to troubleshoot problems with your development environment. For each problem the doctor finds they'll be a link to a section on this page to help you fix it.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-clang-command","title":"Could not find the clang command","text":"<p>The Juvix compiler uses the Clang compiler version 13 or later to generate binaries. You need to have Clang available on your system <code>$PATH</code>.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos","title":"MacOS","text":"<p>Use Homebrew:</p> <pre><code>brew install llvm\n</code></pre> <p>NB: The distribution of Clang that comes with XCode does not support the <code>Wasm</code> target so you must install the standard Clang distribution.</p>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install clang lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S llvm lld\n</code></pre>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasm-ld-command","title":"Could not find the wasm-ld command","text":"<p>The Juvix compiler required <code>wasm-ld</code> (the Wasm linker) to produce <code>Wasm</code> binaries.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos_1","title":"MacOS","text":"<p><code>wasm-ld</code> is included in the Homebrew llvm distribution:</p> <pre><code>brew install llvm\n</code></pre>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux_1","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux_1","title":"Arch Linux","text":"<pre><code>sudo pacman -S lld\n</code></pre>"},{"location":"reference/tooling/doctor/#newer-clang-version-required","title":"Newer Clang version required","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-target","title":"Clang does not support the wasm32 target","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-wasi-target","title":"Clang does not support the wasm32-wasi target","text":"<p>Juvix uses WASI - The Wasm System Interface to produce binaries that can be executed using a Wasm runtime. The files necessary to setup Clang with <code>wasm32-wasi</code> support are available at wasi-sdk.</p> <p>To install the <code>wasm32-wasi</code> target for Clang you need to do two things:</p>"},{"location":"reference/tooling/doctor/#install-libclang_rtbuiltins-wasm32a-into-your-clang-distribution","title":"Install <code>libclang_rt.builtins-wasm32.a</code> into your Clang distribution","text":"<ol> <li> <p>Obtain <code>libclang_rt.builtins-wasm32-wasi-16.0.tar.gz</code> from the     wasi-sdk     releases page.</p> </li> <li> <p>Untar the file and place the file     <code>lib/wasi/libclang_rt.builtins-wasm32.a</code> into your Clang     distribution directory.</p> <p>On MacOS, if you installed llvm using homebrew you can find the Clang distribution directory using <code>brew --prefix llvm</code>. You should then place the builtins file at <code>`brew --prefix llvm`/lib/wasi/libclang_rt.builtins-wasm32.a</code>.</p> <p>On Linux the Clang distribution directory will be something like <code>/usr/lib/clang/13.0.1</code> where <code>13.0.1</code> is the version of Clang that you have installed. You should then place the builtins file at <code>/usr/lib/clang/13.0.1/lib/wasi/libclang_rt.builtins-wasm32</code>.</p> </li> </ol>"},{"location":"reference/tooling/doctor/#download-the-wasi-sysroot-and-set-wasi_sysroot_path","title":"Download the WASI sysroot and set <code>WASI_SYSROOT_PATH</code>","text":"<ol> <li>Obtain <code>wasi-sysroot-16.0.tar.gz</code> from the wasi-sdk     releases page.</li> <li>Untar the file and set the environment variable <code>WASI_SYSROOT_PATH</code>     to that location.</li> </ol>"},{"location":"reference/tooling/doctor/#environment-variable-wasi_sysroot_path-is-not-set","title":"Environment variable <code>WASI_SYSROOT_PATH</code> is not set","text":"<p>Set the <code>WASI_SYSROOT_PATH</code> to the directory where you installed the <code>wasi-sdk</code> sysroot files. See installing the WASI sysroot.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasmer-command","title":"Could not find the wasmer command","text":"<p>The Juvix test suite uses Wasmer as a Wasm runtime to execute compiled Wasm binaries. See the Wasmer documentation to see how to install it.</p>"},{"location":"reference/tooling/emacs/","title":"Emacs mode","text":""},{"location":"reference/tooling/emacs/#emacs-mode","title":"Emacs Mode","text":"<p>There is an Emacs mode available for Juvix. Currently, it supports syntax highlighting for well-scoped modules.</p> <p>To get started, clone the Juvix Emacs mode repository:</p> <pre><code>git clone https://github.com/anoma/juvix-mode.git\n</code></pre> <p>To install it add the following lines to your Emacs configuration file:</p> <pre><code>(push \"/path/to/juvix-mode/\" load-path)\n(require 'juvix-mode)\n</code></pre> <p>Make sure that Juvix is installed in your <code>PATH</code>.</p> <p>The Juvix major mode will be activated automatically for <code>.juvix</code> files.</p>"},{"location":"reference/tooling/emacs/#keybindings","title":"Keybindings","text":"Key Function Name Description <code>C-c C-l</code> <code>juvix-load</code> Runs the scoper and adds semantic syntax highlighting <code>M-.</code> <code>juvix-goto-definition</code> Go to the definition of symbol at point <code>C-c C-f</code> <code>juvix-format-buffer</code> Format the current buffer"},{"location":"reference/tooling/emacs/#emacs-installation","title":"Emacs installation","text":"<p>Most Linux distributions contain an Emacs package which can be installed with your package manager (<code>sudo apt install emacs</code> on Ubuntu). On macOS, it is recommended to install Emacs Plus via Homebrew: <code>brew install emacs-plus</code>. Using the Emacs Homebrew casks is not recommended.</p>"},{"location":"reference/tooling/emacs/#common-problems","title":"Common problems","text":"<ul> <li>Error \"Symbol's value as variable is void: sh:1:\"</li> </ul> <p>Make sure the juvix executable is on the Emacs' <code>exec-path</code>. Note   that <code>exec-path</code> may be different from your shell's <code>PATH</code>. This is   particularly common on macOS with Emacs launched from GUI instead of   the terminal.</p> <p>The easiest way to resolve this issue is to install the   exec-path-from-shell   package (available on MELPA). Alternatively, one may set <code>exec-path</code>   to match shell <code>PATH</code> by following the instructions from   EmacsWiki.</p>"},{"location":"reference/tooling/testing/","title":"Testing","text":""},{"location":"reference/tooling/testing/#dependencies","title":"Dependencies","text":"<p>See Installing dependencies for instructions on how to setup the testing environment for the WASM compiler tests.</p>"},{"location":"reference/tooling/testing/#running","title":"Running","text":"<p>Run tests using:</p> <pre><code>stack test\n</code></pre> <p>To run tests, ignoring all the WASM tests:</p> <pre><code>stack test --ta '-p \"! /slow tests/\"'\n</code></pre>"},{"location":"tutorials/emacs/","title":"Juvix Emacs mode tutorial","text":"<p>First, follow the instructions in the Emacs Mode Reference to install the Juvix Emacs mode. Once you've successfully set it up, create a file <code>Hello.juvix</code> with the following content.</p> <pre><code></code></pre> <p>Type Ctrl+C+Ctrl+L to run the scoper and highlight the syntax.</p> <p>If you make a mistake in your program, it is automatically underlined in red with the error message popping up when you hover the mouse pointer over the underlined part.</p> <p>For example, in the following program the identifier <code>printStringLna</code> should be underlined with the error message \"Symbol not in scope\".</p> <pre><code>module Hello;\n\nopen import Stdlib.Prelude;\n\nmain : IO;\nmain := printStringLna \"Hello world!\";\n\nend;\n</code></pre> <p>If error underlining doesn't work, make sure you have the <code>flycheck</code> mode turned on. It should be turned on automatically when loading <code>juvix-mode</code>, but in case this doesn't work you can enable it with <code>M-x flycheck-mode</code>.</p> <p>Let's extend our program with another definition.</p> <pre><code>module Hello;\n\nopen import Stdlib.Prelude;\n\nprint : IO;\nprint := printStringLn \"Hello world!\";\n\nmain : IO;\nmain := print;\n\nend;\n</code></pre> <p>Place the cursor on the <code>print</code> call in the function clause of <code>main</code> and press <code>M-.</code>. The cursor will jump to the definition of <code>print</code> above. This also works across files and for definitions from the standard library. You can try using <code>M-.</code> to jump to the definition of <code>printStringLn</code>.</p> <p>One more feature of the Juvix Emacs mode is code formatting. To format the content of the current buffer, type Ctrl+C+Ctrl+F. Here is the result.</p> <pre><code>module Hello;\n  open import Stdlib.Prelude;\n\n  print : IO;\n  print := printStringLn \"Hello world!\";\n\n  main : IO;\n  main := print;\nend;\n</code></pre>"},{"location":"tutorials/learn/","title":"Juvix tutorial","text":""},{"location":"tutorials/learn/#juvix-repl","title":"Juvix REPL","text":"<p>After installing Juvix, launch the Juvix REPL:</p> <pre><code>juvix repl\n</code></pre> <p>The response should be similar to:</p> <pre><code>Juvix REPL version 0.3: https://juvix.org. Run :help for help\nOK loaded: ./.juvix-build/stdlib/Stdlib/Prelude.juvix\nStdlib.Prelude&gt;\n</code></pre> <p>Currently, the REPL supports evaluating expressions but it does not yet support adding new definitions. To see the list of available REPL commands type <code>:help</code>.</p>"},{"location":"tutorials/learn/#basic-expressions","title":"Basic expressions","text":"<p>You can try evaluating simple arithmetic expressions in the REPL:</p> <pre><code>Stdlib.Prelude&gt; 3 + 4\n7\nStdlib.Prelude&gt; 1 + 3 * 7\n22\nStdlib.Prelude&gt; div 35 4\n8\nStdlib.Prelude&gt; mod 35 4\n3\nStdlib.Prelude&gt; sub 35 4\n31\nStdlib.Prelude&gt; sub 4 35\n0\n</code></pre> <p>By default, Juvix operates on non-negative natural numbers. Natural number subtraction is implemented by the function <code>sub</code>. Subtracting a bigger natural number from a smaller one yields <code>0</code>.</p> <p>You can also try boolean expressions</p> <pre><code>Stdlib.Prelude&gt; true\ntrue\nStdlib.Prelude&gt; not true\nfalse\nStdlib.Prelude&gt; true &amp;&amp; false\nfalse\nStdlib.Prelude&gt; true || false\ntrue\nStdlib.Prelude&gt; if true 1 0\n1\n</code></pre> <p>and strings, pairs and lists:</p> <pre><code>Stdlib.Prelude&gt; \"Hello world!\"\n\"Hello world!\"\nStdlib.Prelude&gt; (1, 2)\n(1, 2)\nStdlib.Prelude&gt; 1 :: 2 :: nil\n1 :: 2 :: nil\n</code></pre> <p>In fact, you can use all functions and types from the Stdlib.Prelude module of the standard library, which is preloaded by default.</p> <pre><code>Stdlib.Prelude&gt; length (1 :: 2 :: nil)\n3\nStdlib.Prelude&gt; null (1 :: 2 :: nil)\nfalse\nStdlib.Prelude&gt; swap (1, 2)\n(2, 1)\n</code></pre>"},{"location":"tutorials/learn/#files-modules-and-compilation","title":"Files, modules and compilation","text":"<p>Currently, the REPL does not support adding new definitions. To define new functions or data types, you need to put them in a separate file and either load the file in the REPL with <code>:load file.juvix</code> or compile the file to a binary executable with the shell command <code>juvix compile file.juvix</code>.</p> <p>To conveniently edit Juvix files, an Emacs mode and a VSCode extension are available.</p> <p>A Juvix file must declare a module whose name corresponds exactly to the name of the file. For example, a file <code>Hello.juvix</code> must declare a module <code>Hello</code>:</p> <pre><code>-- Hello world example. This is a comment.\nmodule Hello;\n  -- Import the standard library prelude, including the 'String' type\n  open import Stdlib.Prelude;\n\n  main : String;\n  main := \"Hello world!\";\nend;\n</code></pre> <p>A file compiled to an executable must define the zero-argument function <code>main</code> which is evaluated when running the program. The definition of <code>main</code> can have any non-function type, e.g., <code>String</code>, <code>Bool</code> or <code>Nat</code>. The generated executable prints the result of evaluating <code>main</code>.</p>"},{"location":"tutorials/learn/#data-types-and-functions","title":"Data types and functions","text":"<p>To see the type of an expression, use the <code>:type</code> REPL command:</p> <pre><code>Stdlib.Prelude&gt; :type 1\nNat\nStdlib.Prelude&gt; :type true\nBool\n</code></pre> <p>The types <code>Nat</code> and <code>Bool</code> are defined in the standard library.</p> <p>The type <code>Bool</code> has two constructors <code>true</code> and <code>false</code>.</p> <pre><code>  type Bool :=\n    | true : Bool\n    | false : Bool;\n</code></pre> <p>The constructors of a data type can be used to build elements of the type. They can also appear as patterns in function definitions. For example, the <code>not</code> function is defined in the standard library by:</p> <pre><code>  not : Bool -&gt; Bool;\n  not true := false;\n  not false := true;\n</code></pre> <p>The first line is the signature which specifies the type of the definition. In this case, <code>not</code> is a function from <code>Bool</code> to <code>Bool</code>. The signature is followed by two function clauses which specify the function result depending on the shape of the arguments. When a function call is evaluated, the first clause that matches the arguments is used.</p> <p>In contrast to languages like Python, Java or C/C++, Juvix doesn't require parentheses for function calls. All the arguments are just listed after the function. The general pattern for function application is: <code>func arg1 arg2 arg3 ...</code></p> <p>A more complex example of a data type is the <code>Nat</code> type from the standard library:</p> <pre><code>  type Nat :=\n    | zero : Nat\n    | suc : Nat -&gt; Nat;\n</code></pre> <p>The constructor <code>zero</code> represents <code>0</code> and <code>suc</code> represents the successor function \u2013 <code>suc n</code> is the successor of <code>n</code>, i.e., <code>n+1</code>. For example, <code>suc zero</code> represents <code>1</code>. The number literals <code>0</code>, <code>1</code>, <code>2</code>, etc., are just shorthands for appropriate expressions built using <code>suc</code> and <code>zero</code>.</p> <p>The constructors of a data type specify how the elements of the type can be constructed. For instance, the above definition specifies that an element of <code>Nat</code> is either:</p> <ul> <li><code>zero</code>, or</li> <li><code>suc n</code> where <code>n</code> is an element of <code>Nat</code>, i.e., it is constructed by   applying <code>suc</code> to appropriate arguments (in this case the argument   of <code>suc</code> has type <code>Nat</code>).</li> </ul> <p>Any element of <code>Nat</code> can be built with the constructors in this way \u2013 there are no other elements. Mathematically, this is an inductive definition, which is why the data type is called inductive.</p> <p>If implemented directly, the above unary representation of natural numbers would be extremely inefficient. The Juvix compiler uses a binary number representation under the hood and implements arithmetic operations using corresponding machine instructions, so the performance of natural number arithmetic is similar to other programming languages. The <code>Nat</code> type is a high-level presentation of natural numbers as seen by the user who does not need to worry about low-level arithmetic implementation details.</p> <p>One can use <code>zero</code> and <code>suc</code> in pattern matching, like any other constructors:</p> <pre><code>  infixl 6 +;\n  + : Nat -&gt; Nat -&gt; Nat;\n  + zero b := b;\n  + (suc a) b := suc (a + b);\n</code></pre> <p>The <code>infixl 6 +</code> declares <code>+</code> to be an infix left-associative operator with priority 6. The <code>+</code> is an ordinary function, except that function application for <code>+</code> is written in infix notation. The definitions of the clauses of <code>+</code> still need the prefix notation on the left-hand sides.</p> <p>The <code>a</code> and <code>b</code> in the patterns on the left-hand sides of the clauses are variables which match arbitrary values of the corresponding type. They can be used on the right-hand side to refer to the values matched. For example, when evaluating</p> <pre><code>(suc (suc zero)) + zero\n</code></pre> <p>the second clause of <code>+</code> matches, assigning <code>suc zero</code> to <code>a</code> and <code>zero</code> to <code>b</code>. Then the right-hand side of the clause is evaluated with <code>a</code> and <code>b</code> substituted by these values:</p> <pre><code>suc (suc zero + zero)\n</code></pre> <p>Again, the second clause matches, now with both <code>a</code> and <code>b</code> being <code>zero</code>. After replacing with the right-hand side, we obtain:</p> <pre><code>suc (suc (zero + zero))\n</code></pre> <p>Now the first clause matches and finally we obtain the result</p> <pre><code>suc (suc zero)\n</code></pre> <p>which is just <code>2</code>.</p> <p>The function <code>+</code> is defined like above in the standard library, but the Juvix compiler treats it specially and generates efficient code using appropriate CPU instructions.</p>"},{"location":"tutorials/learn/#pattern-matching","title":"Pattern matching","text":"<p>The patterns in function clauses do not have to match on a single constructor \u2013 they may be arbitrarily deep. For example, here is an (inefficient) implementation of a function which checks whether a natural number is even:</p> <pre><code>  even : Nat -&gt; Bool;\n  even zero := true;\n  even (suc zero) := false;\n  even (suc (suc n)) := even n;\n</code></pre> <p>This definition states that a natural number <code>n</code> is even if either <code>n</code> is <code>zero</code> or, recursively, <code>n-2</code> is even.</p> <p>If a subpattern is to be ignored, then one can use a wildcard <code>_</code> instead of naming the subpattern.</p> <pre><code>  isPositive : Nat -&gt; Bool;\n  isPositive zero := false;\n  isPositive (suc _) := true;\n</code></pre> <p>The above function could also be written as:</p> <pre><code>    isPositive : Nat -&gt; Bool;\n    isPositive zero := false;\n    isPositive _ := true;\n</code></pre> <p>It is not necessary to define a separate function to perform pattern matching. One can use the <code>case</code> syntax to pattern match an expression directly.</p> <pre><code>Stdlib.Prelude&gt; case (1, 2)\n  | (suc _, zero) := 0\n  | (suc _, suc x) := x\n  | _ := 19\n1\n</code></pre>"},{"location":"tutorials/learn/#comparisons-and-conditionals","title":"Comparisons and conditionals","text":"<p>To use the comparison operators on natural numbers, one needs to import the <code>Stdlib.Data.Nat.Ord</code> module. The comparison operators are not in <code>Stdlib.Prelude</code> to avoid clashes with user-defined operators for other data types. The functions available in <code>Stdlib.Data.Nat.Org</code> include: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>/=</code>, <code>min</code>, <code>max</code>.</p> <p>For example, one may define the function <code>max3</code> by:</p> <pre><code>  open import Stdlib.Prelude;\n  open import Stdlib.Data.Nat.Ord;\n\n  max3 : Nat -&gt; Nat -&gt; Nat -&gt; Nat;\n  max3 x y z := if (x &gt; y) (max x z) (max y z);\n</code></pre> <p>The conditional <code>if</code> is a special function which is evaluated lazily, i.e., first the condition (the first argument) is evaluated, and then depending on its truth-value one of the branches (the second or the third argument) is evaluated and returned.</p> <p>By default, evaluation in Juvix is eager (or strict), meaning that the arguments to a function are fully evaluated before applying the function. Only <code>if</code>, <code>||</code> and <code>&amp;&amp;</code> are treated specially and evaluated lazily. These special functions cannot be partially applied (see Partial application and higher-order functions below).</p>"},{"location":"tutorials/learn/#local-definitions","title":"Local definitions","text":"<p>Juvix supports local definitions with let-expressions.</p> <pre><code>  f : Nat -&gt; Nat;\n  f a :=\n    let\n      x : Nat := a + 5;\n      y : Nat := a * 7 + x;\n    in x * y;\n</code></pre> <p>The variables <code>x</code> and <code>y</code> are not visible outside <code>f</code>.</p> <p>One can also use multi-clause definitions in <code>let</code>-expressions, with the same syntax as definitions inside a module. For example:</p> <pre><code>  even : Nat -&gt; Bool;\n  even :=\n    let\n      even' : Nat -&gt; Bool;\n      odd' : Nat -&gt; Bool;\n      even' zero := true;\n      even' (suc n) := odd' n;\n      odd' zero := false;\n      odd' (suc n) := even' n;\n    in even';\n</code></pre> <p>The functions <code>even'</code> and <code>odd'</code> are not visible outside <code>even</code>.</p>"},{"location":"tutorials/learn/#recursion","title":"Recursion","text":"<p>Juvix is a purely functional language, which means that functions have no side effects and all variables are immutable. An advantage of functional programming is that all expressions are referentially transparent \u2013 any expression can be replaced by its value without changing the meaning of the program. This makes it easier to reason about programs, in particular to prove their correctness. No errors involving implicit state are possible, because the state is always explicit.</p> <p>In a functional language, there are no imperative loops. Repetition is expressed using recursion. In many cases, the recursive definition of a function follows the inductive definition of a data structure the function analyses. For example, consider the following inductive type of lists of natural numbers:</p> <pre><code>  type NList :=\n    | nnil : NList\n    | ncons : Nat -&gt; NList -&gt; NList;\n</code></pre> <p>An element of <code>NList</code> is either <code>nnil</code> (empty) or <code>ncons x xs</code> where <code>x : Nat</code> and <code>xs : NList</code> (a list with head <code>x</code> and tail <code>xs</code>).</p> <p>A function computing the length of a list may be defined by:</p> <pre><code>  -- Nat here is the built-in type for natural numbers\n  -- coming from the standard library\n  nlength : NList -&gt; Nat;\n  nlength nnil := 0;\n  nlength (ncons _ xs) := nlength xs + 1;\n</code></pre> <p>The definition follows the inductive definition of <code>NList</code>. There are two function clauses for the two constructors. The case for <code>nnil</code> is easy \u2013 the constructor has no arguments and the length of the empty list is <code>0</code>. For a constructor with some arguments, one typically needs to express the result of the function in terms of the constructor arguments, usually calling the function recursively on the constructor's inductive arguments (for <code>ncons</code> this is the second argument). In the case of <code>ncons _ xs</code>, we recursively call <code>nlength</code> on <code>xs</code> and add <code>1</code> to the result.</p> <p>Let's consider another example \u2013 a function which returns the maximum of the numbers in a list or 0 for the empty list.</p> <pre><code>  open import Stdlib.Data.Nat.Ord using {max};\n  nmaximum : NList -&gt; Nat;\n  nmaximum nnil := 0;\n  nmaximum (ncons x xs) := max x (nmaximum xs);\n</code></pre> <p>Again, there is a clause for each constructor. In the case for <code>ncons</code>, we recursively call the function on the list tail and take the maximum of the result and the list head.</p> <p>For an example of a constructor with more than one inductive argument, consider binary trees with natural numbers in nodes.</p> <pre><code>  type Tree :=\n    | leaf : Nat -&gt; Tree\n    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;\n</code></pre> <p>The constructor <code>node</code> has two inductive arguments (the second and the third) which represent the left and the right subtree.</p> <p>A function which produces the mirror image of a tree may be defined by:</p> <pre><code>  mirror : Tree -&gt; Tree;\n  mirror (leaf x) := leaf x;\n  mirror (node x l r) := node x (mirror r) (mirror l);\n</code></pre> <p>The definition of <code>mirror</code> follows the definition of <code>Tree</code>. There are two recursive calls for the two inductive constructors of <code>node</code> (the subtrees).</p>"},{"location":"tutorials/learn/#partial-application-and-higher-order-functions","title":"Partial application and higher-order functions","text":"<p>Strictly speaking, all Juvix functions have only one argument. Multi-argument functions are really functions which return a function which takes the next argument and returns a function taking another argument, and so on for all arguments. The function type former <code>-&gt;</code> (the arrow) is right-associative. Hence, the type, e.g., <code>Nat -&gt; Nat -&gt; Nat</code> when fully parenthesised becomes <code>Nat -&gt; (Nat -&gt; Nat)</code>. It is the type of functions which given an argument of type <code>Nat</code> return a function of type <code>Nat -&gt; Nat</code> which itself takes an argument of type <code>Nat</code> and produces a result of type <code>Nat</code>. Function application is left-associative. For example, <code>f a b</code> when fully parenthesised becomes <code>(f a) b</code>. So it is an application to <code>b</code> of the function obtained by applying <code>f</code> to <code>a</code>.</p> <p>Since a multi-argument function is just a one-argument function returning a function, it can be partially applied to a smaller number of arguments than specified in its definition. The result is an appropriate function. For example, <code>sub 10</code> is a function which subtracts its argument from <code>10</code>, and <code>(+) 1</code> is a function which adds <code>1</code> to its argument. If the function has been declared as an infix operator (like <code>+</code>), then for partial application one needs to enclose it in parentheses.</p> <p>A function which takes a function as an argument is a higher-order function. An example is the <code>nmap</code> function which applies a given function to each element in a list of natural numbers.</p> <pre><code>  nmap : (Nat -&gt; Nat) -&gt; NList -&gt; NList;\n  nmap _ nnil := nnil;\n  nmap f (ncons x xs) := ncons (f x) (nmap f xs);\n</code></pre> <p>The application</p> <pre><code>nmap \\{ x := div x 2 } lst\n</code></pre> <p>divides every element of <code>lst</code> by <code>2</code>, rounding down the result. The expression</p> <pre><code>\\{ x := div x 2 }\n</code></pre> <p>is an unnamed function, or a lambda, which divides its argument by <code>2</code>.</p>"},{"location":"tutorials/learn/#polymorphism","title":"Polymorphism","text":"<p>The type <code>NList</code> we have been working with above requires the list elements to be natural numbers. It is possible to define lists polymorphically, parameterising them by the element type. This is similar to generics in languages like Java, C++ or Rust. Here is the polymorphic definition of lists from the standard library:</p> <pre><code>  infixr 5 ::;\n  type List (A : Type) :=\n    | nil : List A\n    | :: : A -&gt; List A -&gt; List A;\n</code></pre> <p>The constructor <code>::</code> is declared as a right-associative infix operator with priority 5. The definition has a parameter <code>A</code> which is the element type.</p> <p>Now one can define the <code>map</code> function polymorphically:</p> <pre><code>  map : {A B : Type} -&gt; (A -&gt; B) -&gt; List A -&gt; List B;\n  map f nil := nil;\n  map f (h :: hs) := f h :: map f hs;\n</code></pre> <p>This function has two implicit type arguments <code>A</code> and <code>B</code>. These arguments are normally omitted in function application \u2013 they are inferred automatically during type checking. The curly braces indicate that the argument is implicit and should be inferred.</p> <p>In fact, the constructors <code>nil</code> and <code>::</code> also have an implicit argument: the type of list elements. All type parameters of a data type definition become implicit arguments of the constructors.</p> <p>Usually, the implicit arguments in a function application can be inferred. However, sometimes this is not possible and then the implicit arguments need to be provided explicitly by enclosing them in braces:</p> <pre><code>f {implArg1} .. {implArgK} arg1 .. argN\n</code></pre> <p>For example, <code>nil {Nat}</code> has type <code>List Nat</code> while <code>nil</code> by itself has type <code>{A : Type} -&gt; List A</code>.</p>"},{"location":"tutorials/learn/#tail-recursion","title":"Tail recursion","text":"<p>Any recursive call whose result is further processed by the calling function needs to create a new stack frame to save the calling function environment. This means that each such call will use a constant amount of memory. For example, a function <code>sum</code> implemented as follows will use an additional amount of memory proportional to the length of the processed list:</p> <pre><code>  sum : NList -&gt; Nat;\n  sum nnil := 0;\n  sum (ncons x xs) := x + sum xs;\n</code></pre> <p>This is not acceptable if you care about performance. In an imperative language, one would use a simple loop going over the list without any memory allocation. In pseudocode:</p> <pre><code>sum : Nat := 0;\n\nwhile (lst /= nil) do\nbegin\n  sum := sum + head lst;\n  lst := tail lst;\nend;\n\nresult := sum;\n</code></pre> <p>Fortunately, it is possible to rewrite this function to use tail recursion. A recursive call is tail recursive if its result is also the result of the calling function, i.e., the calling function returns immediately after it without further processing. The Juvix compiler guarantees that all tail calls will be eliminated, i.e., that they will be compiled to simple jumps without extra memory allocation. In a tail recursive call, instead of creating a new stack frame, the old one is reused.</p> <p>The following implementation of <code>sum</code> uses tail recursion.</p> <pre><code>  sum : NList -&gt; Nat;\n  sum lst :=\n    let\n      go : Nat -&gt; NList -&gt; Nat;\n      go acc nnil := acc;\n      go acc (ncons x xs) := go (acc + x) xs;\n    in go 0 lst;\n</code></pre> <p>The first argument of <code>go</code> is an accumulator which holds the sum computed so far. It is analogous to the <code>sum</code> variable in the imperative loop above. The initial value of the accumulator is 0. The function <code>go</code> uses only constant additional memory overall. The code generated for it by the Juvix compiler is equivalent to an imperative loop.</p> <p>Most imperative loops may be translated into tail recursive functional programs by converting the locally modified variables into accumulators and the loop condition into pattern matching. For example, here is an imperative pseudocode for computing the nth Fibonacci number in linear time. The variables <code>cur</code> and <code>next</code> hold the last two computed Fibonacci numbers.</p> <pre><code>cur : Nat := 0;\nnext : Nat := 1;\n\nwhile (n /= 0) do\nbegin\n  tmp := next;\n  next := cur + next;\n  cur := tmp;\n  n := n - 1;\nend;\n\nresult := cur;\n</code></pre> <p>An equivalent functional program is:</p> <pre><code>    fib : Nat -&gt; Nat;\n    fib :=\n      let\n        go : Nat -&gt; Nat -&gt; Nat -&gt; Nat;\n        go cur _ zero := cur;\n        go cur next (suc n) := go next (cur + next) n;\n      in go 0 1;\n</code></pre> <p>A naive definition of the Fibonacci function runs in exponential time:</p> <pre><code>    fib : Nat -&gt; Nat;\n    fib zero := 0;\n    fib (suc zero) := 1;\n    fib (suc (suc n)) := fib n + fib (suc n);\n</code></pre> <p>Tail recursion is less useful when the function needs to allocate memory anyway. For example, one could make the <code>map</code> function from the previous section tail recursive, but the time and memory use would still be proportional to the length of the input because of the need to allocate the result list.</p>"},{"location":"tutorials/learn/#totality-checking","title":"Totality checking","text":"<p>By default, the Juvix compiler requires all functions to be total. Totality consists of:</p> <ul> <li>termination and coverage for function declarations, and</li> <li>strict positivity for user-defined   data types.</li> </ul> <p>The termination check ensures that all functions are structurally recursive, i.e., all recursive call are on structurally smaller values \u2013 subpatterns of the matched pattern. For example, the termination checker rejects the definition</p> <pre><code>    fact : Nat -&gt; Nat;\n    fact x := if (x == 0) 1 (x * fact (sub x 1));\n</code></pre> <p>because the recursive call is not on a subpattern of a pattern matched on in the clause. One can reformulate this definition so that it is accepted by the termination checker:</p> <pre><code>    fact : Nat -&gt; Nat;\n    fact zero := 1;\n    fact x@(suc n) := x * fact n;\n</code></pre> <p>Sometimes, such a reformulation is not possible. Then one can use the <code>terminating</code> keyword to forgo the termination check.</p> <pre><code>  terminating\n  log2 : Nat -&gt; Nat;\n  log2 n := if (n &lt;= 1) 0 (suc (log2 (div n 2)));\n</code></pre> <p>Coverage checking ensures that there are no unhandled patterns in function clauses or <code>case</code> expressions. For example, the following definition is rejected because the case <code>suc zero</code> is not handled:</p> <pre><code>    even : Nat -&gt; Bool;\n    even zero := true;\n    even (suc (suc n)) := even n;\n</code></pre> <p>Since coverage checking forces the user to specify the function for all input values, it may be unclear how to implement functions which are typically partial. For example, the <code>tail</code> function on lists is often left undefined for the empty list. One solution is to return a default value. In the Juvix standard library, <code>tail</code> is implemented as follows, returning the empty list when the argument is empty.</p> <pre><code>  tail : {A : Type} -&gt; List A -&gt; List A;\n  tail (_ :: xs) := xs;\n  tail nil := nil;\n</code></pre> <p>Another solution is to wrap the result in the <code>Maybe</code> type from the standard library, which allows representing optional values. An element of <code>Maybe A</code> is either <code>nothing</code> or <code>just x</code> with <code>x : A</code>.</p> <pre><code>  type Maybe (A : Type) :=\n    | nothing : Maybe A\n    | just : A -&gt; Maybe A;\n</code></pre> <p>For example, one could define the tail function as:</p> <pre><code>    tail' : {A : Type} -&gt; List A -&gt; Maybe (List A);\n    tail' (_ :: xs) := just xs;\n    tail' nil := nothing;\n</code></pre> <p>Then the user needs to explicitly check if the result of the function contains a value or not:</p> <pre><code>case tail' lst\n| just x := ...\n| nothing := ...\n</code></pre>"},{"location":"tutorials/learn/#exercises","title":"Exercises","text":"<p>You have now learnt the very basics of Juvix. To consolidate your understanding of Juvix and functional programming, try doing some of the following exercises. To learn how to write more complex Juvix programs, see the advanced tutorial and the Juvix program examples.</p>"},{"location":"tutorials/learn/#exercise-1","title":"Exercise 1","text":"<p>Define a function <code>prime : Nat -&gt; Nat</code> which checks if a given natural number is prime.</p> <p>Tip</p> <p>A number is prime if it is greater than 1 and has no divisors other than 1 and itself.</p>"},{"location":"tutorials/learn/#exercise-2","title":"Exercise 2","text":"<p>What is wrong with the following definition?</p> <pre><code>half : Nat -&gt; Nat;\nhalf n := if (n &lt; 2) 0 (half (n - 2) + 1);\n</code></pre> <p>How can you reformulate this definition so that it is accepted by Juvix?</p>"},{"location":"tutorials/learn/#exercise-3","title":"Exercise 3","text":"<p>Define a polymorphic function which computes the last element of a list. What is the result of your function on the empty list?</p>"},{"location":"tutorials/learn/#exercise-4","title":"Exercise 4","text":"<p>A suffix of a list <code>l</code> is any list which can be obtained from <code>l</code> by removing some initial elements. For example, the suffixes of <code>1 :: 2 :: 3 :: nil</code> are:</p> <ul> <li><code>1 :: 2 :: 3 :: nil</code>,</li> <li><code>2 :: 3 :: nil</code>,</li> <li><code>3 :: nil</code>, and</li> <li><code>nil</code>.</li> </ul> <p>Define a function which computes the list of all suffixes of a given list, arranged in descending order of their lengths.</p>"},{"location":"tutorials/learn/#exercise-5","title":"Exercise 5","text":"<p>Recall the <code>Tree</code> type from above.</p> <pre><code>  type Tree :=\n    | leaf : Nat -&gt; Tree\n    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;\n</code></pre> <p>Analogously to the <code>map</code> function for lists, define a function</p> <pre><code>tmap : (Nat -&gt; Nat) -&gt; Tree -&gt; Tree;\n</code></pre> <p>which applies a function to all natural numbers stored in a tree.</p>"},{"location":"tutorials/learn/#exercise-6","title":"Exercise 6","text":"<p>Modify the <code>Tree</code> type from Exercise 5 to be polymorphic in the element type, and then repeat the previous exercise.</p>"},{"location":"tutorials/learn/#exercise-7","title":"Exercise 7","text":"<p>Write a tail recursive function which reverses a list.</p>"},{"location":"tutorials/learn/#exercise-8","title":"Exercise 8","text":"<p>Write a tail recursive function which computes the factorial of a natural number.</p>"},{"location":"tutorials/learn/#exercise-9","title":"Exercise 9","text":"<p>Define a function</p> <pre><code>comp : {A : Type} -&gt; List (A -&gt; A) -&gt; A -&gt; A\n</code></pre> <p>which composes all functions in a list. For example,</p> <pre><code>comp (suc :: (*) 2 :: \\{x := sub x 1} :: nil)\n</code></pre> <p>should be a function which given <code>x</code> computes <code>2(x - 1) + 1</code>.</p>"},{"location":"tutorials/nodejs-interop/","title":"NodeJS Interop","text":"<p>A Juvix module can be compiled to a Wasm module. When a Wasm module is instantiated by a host, functions from the host can be injected into a Wasm module and functions from the Wasm module can be called by the host.</p> <p>In this tutorial you will see how to call host functions in Juvix and call Juvix functions from the host using the Wasm mechanism.</p>"},{"location":"tutorials/nodejs-interop/#the-juvix-module","title":"The Juvix module","text":"<p>The following Juvix module has two functions.</p> <p>The function <code>hostDisplayString</code> is an <code>axiom</code> with no corresponding <code>compile</code> block that implements it. We will inject an implementation for this function when we instantiate the module from NodeJS.</p> <p>The function <code>juvixRender</code> is a normal Juvix function. We will call this from NodeJS.</p> <pre><code>-- NodeJsInterop.juvix\nmodule NodeJsInterop;\n\nopen import Stdlib.Prelude;\n\naxiom hostDisplayString : String \u2192 IO;\n\njuvixRender : IO;\njuvixRender := hostDisplayString \"Hello World from Juvix!\";\n\nend;</code></pre>"},{"location":"tutorials/nodejs-interop/#compiling-the-juvix-module","title":"Compiling the Juvix module","text":"<p>The Juvix module can be compiled using the following command:</p> <pre><code>juvix compile -t wasm -r standalone NodeJsInterop.juvix</code></pre> <p>This will create a file containing a Wasm module called <code>NodeJsInterop.wasm</code>.</p>"},{"location":"tutorials/nodejs-interop/#the-nodejs-module","title":"The NodeJS module","text":"<p>The following NodeJS module demonstrates both calling a Juvix function from NodeJS and injecting a NodeJS function into a Juvix module.</p> <p>The NodeJS function <code>hostDisplayString</code> is passed to the Wasm module <code>NodeJSInterop.wasm</code> when it is instantiated. After instantiation the Juvix function <code>juvixRender</code> is called.</p> <p>The functions <code>ptrToCstr</code> and <code>cstrlen</code> are necessary to convert the <code>char</code> pointer passed from Juvix to a JS <code>String</code>.</p> <pre><code>// NodeJSInterop.js\nconst fs = require('fs');\nlet wasmModule = null;\n\nfunction cstrlen(mem, ptr) {\n    let len = 0;\n    while (mem[ptr] != 0) {\n        len++;\n        ptr++;\n    }\n    return len;\n}\n\nfunction ptrToCstr(ptr) {\n    const wasmMemory = wasmModule.instance.exports.memory.buffer;\n    const mem = new Uint8Array(wasmMemory);\n    const len = cstrlen(mem, ptr);\n    const bytes = new Uint8Array(wasmMemory, ptr, len);\n    return new TextDecoder().decode(bytes);\n}\n\nfunction hostDisplayString(strPtr) {\n    const text = ptrToCstr(strPtr);\n    console.log(text);\n}\n\nconst wasmBuffer = fs.readFileSync(\"NodeJsInterop.wasm\");\nWebAssembly.instantiate(wasmBuffer, {\n    env: {\n        hostDisplayString,\n    }\n}).then((w) =&gt; {\n    wasmModule = w;\n    wasmModule.instance.exports.juvixRender();\n});</code></pre>"},{"location":"tutorials/nodejs-interop/#running-the-wasm-module","title":"Running the Wasm module","text":"<p>Now you should have the files <code>NodeJsInterop.wasm</code> and <code>NodeJsInterop.js</code> in the same directory. Run the following command to execute the module:</p> <pre><code>node NodeJsInterop.js</code></pre> <p>You should see the following output:</p> <pre><code>Hello World from Juvix!</code></pre>"},{"location":"tutorials/vscode/","title":"Juvix VSCode extension tutorial","text":"<p>To install the Juvix VSCode extension, click on the \"Extensions\" button in the left panel and search for the \"Juvix\" extension by Heliax.</p> <p>Once you've installed the Juvix extension, you can open a Juvix file. For example, create a <code>Hello.juvix</code> file with the following content.</p> <pre><code></code></pre> <p>Syntax should be automatically highlighted for any file with <code>.juvix</code> extension. You can jump to the definition of an identifier by pressing F12 or control-clicking it. To apply the Juvix code formatter to the current file, use Shift+Ctrl+I.</p> <p>In the top right-hand corner of the editor window you should see several buttons. Hover the mouse pointer over a button to see its description. The functions of the buttons are as follows.</p> <ul> <li>Load file in REPL (Shift+Alt+R). Launches the Juvix REPL in a   separate window and loads the current file into it. You can then   evaluate any definition from the loaded file.</li> <li>Typecheck (Shift+Alt+T). Type-checks the current file.</li> <li>Compile (Shift+Alt+C). Compiles the current file. The resulting   native executable will be left in the directory of the file.</li> <li>Run (Shift+Alt+X). Compiles and runs the current file. The output of   the executable run is displayed in a separate window.</li> <li>Html preview. Generates HTML documentation for the current file and   displays it in a separate window.</li> </ul>"}]}