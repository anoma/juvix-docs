{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stemmer","stopWordFilter","trimmer"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Juvix a language for intent-centric and declarative decentralized applications","text":"<p>Install Juvix on your machine</p> <p>  Try Juvix now on Codespaces</p> <p>Juvix is an open-source functional language with static typing and strict semantics. It is the programming language for the Anoma's blockchain. The primary purpose of this language is to encode Anoma's intents, enabling private and transparent execution through Taiga on the Anoma blockchain.</p> <p>Juvix, initially designed for Anoma, provides features typical of any high-level programming language with many more on the horizon. It can compile programs into native executable, WASM, and arithmetic circuits using VampIR or Geb, facilitating zero-knowledge proofs.</p> <p>Stay tuned for Juvix updates! Follow us on  Twitter and join our  Discord community.</p> Taiga SimulatorTransaction lifecycle <p>How to write intents in Juvix to validate transactions in Anoma is further elaborated in both the Taiga Simulator repository and the Juvix Workshop.</p> <pre><code>sequenceDiagram\n    UserWallet -&gt;&gt;Taiga API: use intent to create ptxs\n    Taiga API  --&gt;&gt;UserWallet: returns ptxs\n    UserWallet  -&gt;&gt;Solvers: send a ptxs\n    Solvers   -&gt;&gt;Solvers: match/broadcast ptxs\n    Solvers  --&gt;&gt;Taiga API: create helper ptxs\n    Taiga API  --&gt;&gt;Solvers: gives helper ptxs\n    Solvers   -&gt;&gt;Taiga API: create a tx\n    Taiga API  --&gt;&gt;Solvers: returns a finalized tx\n    Solvers  -&gt;&gt;Finaliser : submit finalized transaction\n        Finaliser -&gt;&gt; Taiga API: verify the finalized transaction\n    Taiga API -&gt;&gt; Finaliser: return the result (valid/invalid)\n    Finaliser --&gt;&gt; Blockchain: commit a (balanced) tx\n    Blockchain -&gt;&gt; Blockchain: run consensus Typhon alg.\n    Blockchain -&gt;&gt; Taiga API: verify the transaction\n    Taiga API --&gt;&gt; Blockchain: return the result (valid/invalid)</code></pre> <ul> <li> <p> How-to guides</p> <p>Learn how to install Juvix on macOS or Linux, as well as compile and    document your Juvix projects.</p> <p> Quick start </p> <p> How-to guides </p> </li> <li> <p> Tutorials</p> <p>Master the essentials of Juvix through a series of tailored examples, tutorials and technical explanations.</p> <p> Learn Juvix in 5 minutes</p> </li> </ul> <ul> <li> <p> Talks and Workshops</p> <p>A collection of talks and workshop videos showcasing Juvix. Gain valuable insights and inspiration from our presentations at various conferences.</p> <p> Juvix videos</p> </li> <li> <p> Reference</p> <p>Explore the Language reference, milestone examples, and tooling documentation!</p> <p> Reference</p> </li> <li> <p> Blog</p> <p>Check out our blog to discover new features in the upcoming release, along with helpful examples and more. And, don't forget to join us on Discord.</p> <p> Blog</p> <p> Join us</p> </li> <li> <p> Open Source, GPL3.0</p> <p>Juvix is licensed under GPL3 and available on GitHub.</p> <p> License</p> </li> </ul>"},{"location":"#a-brief-of-what-juvix-is-about","title":"... a brief of what Juvix is about","text":""},{"location":"#intents-in-juvix-for-anomas-dapps","title":"Intents in Juvix for Anoma's dApps","text":"<p>What is an intent? An intent, in essence, is a high-level description, a message sent by programs to indicate changes of a desired state.</p> <p>Take for instance, Alice's intent. Her intent is to trade either two units of resource <code>B</code> or one unit of resource <code>A</code> for a unit of <code>Dolphin</code>. Bob, on the other hand, is willing to exchange one unit of resource <code>A</code> for 1 <code>Dolphin</code>. How can we write these intents in Juvix? The conditions for Alice's intent is presented in Juvix on the right, a logic function that validates the transaction.</p> <p>See here the full Juvix code for this example.</p> Two-party exchange <pre><code>flowchart LR\n    A((Alice)) -- \"Intent 1:\\ntrade 1 A or 2 B for 1 Dolphin\" ---&gt; B[Taiga]\n    X((Bob)) -- \"Intent 2:\\ntrade 1 Dolphin for 1 A\" ---&gt; B\n    B --&gt; P[Pool]\n    S((Solver)) &lt;----&gt; P\n    P -- \"Intent solving\" --&gt; Z(\"Finalized\\nTransaction\")\n    Z --&gt; O[(Anoma)]</code></pre>"},{"location":"#anomataiga-simulator","title":"<code>anoma/taiga-simulator</code>","text":"Partial transactionsAlice IntentLogics <pre><code>module Alice;\n  -- Alice is willing to exchange either 2 B or 1 A for 1 Dolphin.\n  partialTransaction : PartialTx :=\n    mkPartialTx\n      (consumedPair := A.mkResource 1, B.mkResource 2;\n      createdPair := AliceIntent.mkResource 1, dummyResource);\nend;\n\nmodule Bob;\n  partialTransaction : PartialTx :=\n    mkPartialTx\n      (consumedPair := Dolphin.mkResource 1, dummyResource;\n      createdPair := A.mkResource 1, dummyResource);\nend;\n\nmodule Solver;\n  partialTransaction : PartialTx :=\n    mkPartialTx\n      (consumedPair := AliceIntent.mkResource 1, dummyResource;\n      createdPair := Dolphin.mkResource 1, B.mkResource 2);\nend;\n</code></pre> <pre><code>module AliceIntent;\n  logicFunction : ResourceKind -&gt; PartialTx -&gt; Bool\n    | kind tx :=\n      let\n        createdRs : List Resource := createdResources tx;\n        createdHashes : List LogicHash :=\n          map Resource.logicHash createdRs;\n      in isCreated kind\n        || (quantityOfDenom Dolphin.denomination createdRs\n            == ofNat 1\n          &amp;&amp; quantityOfDenom A.denomination createdRs == ofNat 1)\n        || quantityOfDenom Dolphin.denomination createdRs == ofNat 1\n        &amp;&amp; quantityOfDenom B.denomination createdRs == ofNat 2;\n\n  --- This will be computed from the logic function\n  logicHash : LogicHash := 1;\n\n  staticData : ByteString := 3 :: nil;\n\n  denomination : Denomination := 1 :: staticData;\n\n  mkResource (n : Int) : Resource :=\n    mkResource'\n      (logicHash := logicHash;\n      staticData := staticData;\n      dynamicData := nil;\n      quantity := n);\nend;\n</code></pre> <pre><code>logicFunctions : Map LogicHash LogicFunction :=\n  mkLogicFunctionMap\n    ((AliceIntent.logicHash, AliceIntent.logicFunction) :: nil);\n</code></pre> <pre><code>twoPartyExchange : Test :=\n    let\n        txs : List PartialTx :=\n        Alice.partialTransaction\n            :: Bob.partialTransaction\n            :: Solver.partialTransaction\n            :: nil;\n    in testCase\n        \"two party exchange\"\n        (assertTrue\n        \"expected two-party exchange transactions to validate\"\n        (checkTransaction logicFunctions txs));\n</code></pre>"},{"location":"#arithmetic-circuits-zero-knowledge-proofs","title":"Arithmetic Circuits / Zero-knowledge Proofs","text":"<p>An arithmetic circuit is an algebraic representation, essentially expressing a system of polynomial equations in a universal, canonical form that model the computation of a program. Arithmetic circuits are used in zero-knowledge proofs and Juvix can compile programs into these representations via our in-house compiler VampIR.</p> <pre><code>flowchart LR\n    A[Juvix file]  -- Juvix --&gt; B[VampIR circuit]\n    B -- VampIR --&gt; C[PLONK or Halo2 circuit]</code></pre> <pre><code>juvix compile -t vampir Hash.juvix\n</code></pre> <p>The VampIR file can then be compiled to a PLONK circuit:</p> <pre><code>vamp-ir plonk setup -m 14 -o input.pp\nvamp-ir plonk compile -u input.pp -s Hash.pir -o c.plonk\n</code></pre> <p>A zero-knowledge proof that <code>hash 1367</code> is equal to <code>3</code> can then be generated from the circuit:</p> <pre><code>vamp-ir plonk prove -u input.pp \\\n                    -c c.plonk \\\n                    -o proof.plonk -i Hash.json\n</code></pre> <p>This proof can then be verified:</p> <pre><code>vamp-ir plonk verify -u input.pp -c c.plonk -p proof.plonk\n</code></pre>"},{"location":"#anomajuvix-workshop","title":"<code>anoma/juvix-workshop</code>","text":"Hash.juvixHash.json <pre><code>module Hash;\n\nimport Stdlib.Prelude open;\n\n{-# unroll: 30 #-}\nterminating\npower' (acc a b : Nat) : Nat :=\n  let\n    acc' : Nat := if (mod b 2 == 0) acc (acc * a);\n  in if (b == 0) acc (power' acc' (a * a) (div b 2));\n\npower : Nat \u2192 Nat := power' 1 2;\n\nhash' : Nat -&gt; Nat -&gt; Nat\n  | (suc n@(suc (suc m))) x :=\n    if\n      (x &lt; power n)\n      (hash' n x)\n      (mod (div (x * x) (power m)) (power 6))\n  | _ x := x * x;\n\nhash : Nat -&gt; Nat := hash' 16;\n\nmain : Nat -&gt; Nat := hash;\n</code></pre> <pre><code>{\n    \"in\": \"1367\",\n    \"out\": \"3\"\n}\n</code></pre> <p>Note</p> <p>For further details, refer to Compiling Juvix programs to arithmetic circuits via Vamp-IR.</p>"},{"location":"#juvix-is-growing-fast","title":"Juvix is growing fast!","text":""},{"location":"juvix-packages/","title":"Juvix Packages and Projects","text":""},{"location":"juvix-packages/#quick-start","title":"Quick Start","text":"<p>To install a package, you must sure that you have created the <code>Package.juvix</code> file. You can run <code>juvix init</code> to get a template <code>Package.juvix</code> file. A more detailed description on the usage of <code>Package.juvix</code> can be found in How to setup a Juvix project. For now, one example is provided below. Put the following in your <code>Package.juvix</code> file within  the directory of your project.</p> <pre><code> module Package;\n\n import PackageDescription.V1 open;\n\n package : Package := defaultPackage {name := \"lanaguage\"};\n</code></pre> <ul> <li> <p> <code>anoma/juvix-containers</code></p> DescriptionInstall <p>Immutable container types for Juvix.</p> <ul> <li> <p> BinaryTree, Map, Queue, Set, Tree, UnbalancedSet, and much more to come.</p> </li> <li> <p> Tests using anoma/juvix-test.</p> </li> </ul> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"juvix-containers\" \"v0.7.1\"\n</code></pre> </li> <li> <p> <code>anoma/juvix-quickcheck</code></p> DescriptionInstall <p>This package provides property-based testing for the Juvix programming language inspired by the popular Haskell library, QuickCheck.</p> <ul> <li> Automated testing: Generate random test cases to validate properties of Juvix code.</li> </ul> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"juvix-quickcheck\" \"v0.8.0\"\n--8-- [end:juvix-quickcheck]\n; \ngithub \"anoma\" \"juvix-stdlib\" \"86f9e82c34395f3e0447c58566bc92347603ebd3\"\n;\ngithub \"anoma\" \"taiga-simulator\" \"fd0ac317735bb2752e40f1fa0dd06b2de432bfd5\"\n]};\n</code></pre> </li> <li> <p> <code>anoma/juvix-stdlib</code></p> DescriptionInstall <p>Shipped with Juvix, the standard library provides a set of useful functions and types for writing Juvix programs.</p> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"juvix-stdlib\" \"86f9e82c34395f3e0447c58566bc92347603ebd3\"\n</code></pre> </li> <li> <p> <code>anoma/juvix-test</code></p> DescriptionInstall <p>A unit testing framework for Juvix programs.</p> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"juvix-test\" \"v0.6.1\"\n</code></pre> </li> </ul>"},{"location":"juvix-packages/#projects-using-juvix","title":"Projects using Juvix","text":"<ul> <li> <p> <code>anoma/taiga-simulator</code></p> DescriptionInstall <p>The Taiga Simulator is a Juvix function that simulates the Taiga execution model.</p> <p>Add the following to your <code>Package.juvix</code> file in the <code>dependencies</code> field:</p> <pre><code>github \"anoma\" \"taiga-simulator\" \"fd0ac317735bb2752e40f1fa0dd06b2de432bfd5\"\n</code></pre> </li> <li> <p> <code>anoma/juvix-e2e-demo</code></p> <p>A project for demostrating the process of generating arithmetic circuits from high-level specifications. This CodeSpace includes all the necessary compilers for circuit generation, such as Juvix, GEB, and VampIR. Furthermore, it features the Juvix VSCode extension to simplify writing Juvix programs and allows users to interact with and evaluate the resulting GEB/VampIR programs.</p> </li> </ul> <p>Please let us know if you are using Juvix in your project. Opening an issue or a pull request to add it to this list.</p>"},{"location":"juvix-packages/#other-small-example-programs","title":"Other Small Example Programs","text":"<p>The following links are clickable versions of their corresponding Juvix program. The sources can be found in the examples/milestone directory in the Juvix repository. The webpages can be generated by running the following command:</p> <pre><code>juvix html --recursive FileName.juvix\n</code></pre> <ul> <li>HelloWorld.juvix</li> <li>Fibonacci.juvix</li> <li>Hanoi.juvix</li> <li>PascalsTriangle.juvix</li> <li>Collatz.juvix</li> <li>TicTacToe.juvix</li> </ul>"},{"location":"about/community/","title":"Juvix community","text":"<p>Join us on our Discord server</p> <p>This project is part of a bigger effort called Anoma. Anoma is a suite of protocols and mechanisms for self-contained, self-sovereign coordination. Join the Anoma project.</p>"},{"location":"about/license/","title":"License","text":"<pre><code>                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. &lt;https://fsf.org/&gt;\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    &lt;one line to give the program's name and a brief idea of what it does.&gt;\n    Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    &lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n&lt;https://www.gnu.org/licenses/&gt;.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n&lt;https://www.gnu.org/licenses/why-not-lgpl.html&gt;.\n</code></pre>"},{"location":"about/overview/","title":"Juvix Project Overview","text":"CI Status   Codebase   <p>Juvix is an open-source, constantly evolving functional programming language designed for writing privacy-preserving decentralized applications. Using Juvix, developers can write high-level programs which can be compiled to WASM directly, or through VampIR to circuits for private execution with Taiga on Anoma or Ethereum.</p>"},{"location":"about/overview/#getting-started","title":"Getting Started","text":"<p>To get started with Juvix, head over to the documentation website to learn more about the language and its features. You can also find installation instructions and tutorials to help you get started with writing Juvix programs. You can download the latest release from the Juvix GitHub repository or use the web-based development environment, Juvix Github Codespace, which provides a pre-configured workspace ready to use with Juvix and the Haskell toolchain installed.</p>"},{"location":"about/overview/#language-features","title":"Language features","text":"<p>Juvix is designed with a focus on safety. The Juvix compiler runs several static analyses which guarantee the absence of runtime errors. Analyses performed include termination and type checking. As a result, functional programs, especially validity predicates, can be written with greater confidence in their correctness.</p> <p>Some language features in Juvix include:</p> <ul> <li>Haskell/Agda-like syntax with support for Unicode</li> <li>Type inference</li> <li>Parametric polymorphism</li> <li>User defined inductive data types</li> <li>Higher-order functions</li> <li>Referential transparency</li> </ul> <p>The Juvix module system allows developers to break down their programs into smaller, reusable modules that can be compiled separately and combined to create larger programs. These modules can be used to build libraries, which can then be documented using Juvix's built-in documentation generation tool, see for example, the Juvix standard library's website. For further details, please refer to the Juvix book which includes our latest updates.</p>"},{"location":"about/overview/#related-projects","title":"Related projects","text":"<p>If you're interested in Juvix, you may also want to explore the following related projects:</p> Project Description GEB Intermediate language for writing compilers and one of the Juvix backends. VampIR Proof-system-agnostic language for writing arithmetic circuits and one of the GEB backends. Taiga A framework for generalized shielded state transitions."},{"location":"about/overview/#resources","title":"Resources","text":"<p>Here is a summary of resources to help you learn more about Juvix:</p>"},{"location":"about/overview/#documentation","title":"Documentation","text":"Resource Description Official website The official website of Juvix, where you can find documentation, changelog, tutorials, and community resources. GitHub repository The official GitHub repository of Juvix, where you can find the source code and contribute to the project."},{"location":"about/overview/#community","title":"Community","text":"Resource Description Discord community The Juvix community on Discord is a space where you can connect with the developers behind Juvix and other members of the community who are passionate about privacy-preserving decentralized applications. It's a place where you can ask for help with using Juvix, discuss the latest features and updates, and get involved in the project. Twitter The official Twitter account of Juvix, where you can stay up-to-date with the latest news and announcements."},{"location":"about/overview/#libraries","title":"Libraries","text":"Resource Description Standard library The Juvix standard library is a collection of pre-written functions and modules that come bundled with the Juvix programming language. It provides developers with a set of common and useful tools that they can use to build their Juvix programs without having to write everything from scratch."},{"location":"about/overview/#ide-support","title":"IDE support","text":"Resource Description VSCode extension Support for the Juvix programming language with features such as syntax highlighting, error checking and many more directly in the VSCode editor. Emacs Juvix mode A major mode for Emacs that provides support for writing Juvix programs."},{"location":"about/overview/#development-environments","title":"Development environments","text":"Resource Description Juvix Standard Lib Codespace A web-based development environment for the Juvix standard library on GitHub. It provides a pre-configured workspace with the Juvix standard library installed and ready to use, so you can start using the library in your projects. Some examples of Juvix programs are also loaded in this environment. Juvix Github Codespace This codespace provides a pre-configured workspace with Juvix and the Haskell toolchain installed. Everything is ready to use, so you can start developing/inspecting the Juvix compiler right away."},{"location":"about/overview/#installation","title":"Installation","text":"Resource Description Homebrew Juvix formula A formula for Homebrew, a package manager for macOS and Linux, that allows you to easily install Juvix on your system. Juvix Nightly builds Users can download and use these nightly builds to experiment with the latest changes to the Juvix Compiler. Nightly builds may contain new features, bug fixes, and other improvements to Juvix that are still in development and have not yet been released in an official version."},{"location":"about/overview/#contributing","title":"Contributing","text":"<p>If you're interested in contributing to Juvix, please see the contributing guidelines for more information. We welcome contributions of all kinds, from bug reports and feature requests to code contributions and documentation improvements.</p>"},{"location":"about/overview/#license","title":"License","text":"<p>Juvix is open-source software released under the GNU General Public License v3.0. See the LICENSE file for more information.</p>"},{"location":"about/talks/","title":"Talks and workshops","text":"<p>On this page you will find a collection of our talks and workshop videos showcasing Juvix.</p> <p>In these videos we delve into the fascinating world of this powerful language, uncovering its core principles, and demonstrating real-world examples of Juvix applications.</p> <p>Gain valuable insights and inspiration from our presentations at various conferences.</p>"},{"location":"about/talks/#2023","title":"2023","text":"<ul> <li>Veronika Romashkina (2023, July 10). Juvix: Towards a Functional Programming Language for Decentralized Applications and Beyond [Video]. Retrieved from YouTube. Link to the video</li> </ul>"},{"location":"about/talks/#2022","title":"2022","text":"<ul> <li>Paul Cadman (2022, July 20). Juvix [Video]. Retrieved from YouTube. Link to the video</li> </ul>"},{"location":"about/team/","title":"Juvix Team","text":""},{"location":"about/team/#core-team","title":"Core team","text":"<ul> <li>Paul Cadman</li> <li>Jonathan Cubides</li> <li>\u0141ukasz Czajka</li> <li>Artem Gureev</li> <li>Jan Mas Rovira</li> </ul>"},{"location":"about/team/#anoma-contributors","title":"Anoma contributors","text":"<ul> <li>Christopher Goes</li> <li>Jeremy Orleans</li> <li>Terence Rokop</li> </ul>"},{"location":"about/team/#past-members","title":"Past members","text":"<ul> <li>Veronika Romashkina</li> </ul>"},{"location":"blog/","title":"Juvix Blog","text":"<p>Welcome! Join us in our cozy corner as we explore functional programming and next-generation distributed apps, sharing insights on Juvix, its development, and discussing related concepts. Stay tuned for our upcoming events and let's embark on this exciting journey together!</p>"},{"location":"blog/ethprague/","title":"Join Juvix Team at ETHPrague","text":"<p>The Juvix team is excited to announce our participation in ETHPrague 2023, an Ethereum-focused event happening in Prague, Czech Republic, from June 8-11.</p> <p>Join us for an immersive experience where you can learn about the current state of the Juvix language, explore and create real-world applications built with Juvix, and engage in discussions about the future possibilities and exciting plans we have in store.</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#the-event","title":"The event","text":"<p>ETHPrague is a premier blockchain event that brings together the global Ethereum community to discuss the future of Ethereum, blockchain technology, and new concepts. It provides a platform for knowledge sharing, networking, and collaboration among enthusiasts, experts, and visionaries.</p> <p>The event features an impressive lineup of speakers, including the esteemed Vitalik Buterin. With engaging panels, workshops, and even a hackathon, ETHPrague offers abundant opportunities to learn, network, and connect with exceptional individuals and communities.</p> <p>The event will take place from June 8th to June 11th in the beautiful city of Prague, Czech Republic. For more information, please visit the official event webpage.</p> <p>Make sure to mark your calendar for the following key sessions:</p> <ul> <li>Talk by Veronika Romashkina: On Saturday, June 10th, from 14:10 - 14:30   at the Institute of Cryptoanarchy, Veronika, Developer Relations at Heliax,   will present a talk titled \"Juvix: Toward a Functional Programming Language   for Decentralized Applications and Beyond.\"</li> <li>Workshop by Paul Cadman: Also on Saturday, June 10th, from 16:20 - 17:20   at the Paper Hub, Paul, Compiler Engineer at Heliax, will host a workshop   titled \"Discovering Juvix: The High-Level Functional Programming Language   for Building Next-Generation dApps.\"</li> </ul>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#explore-juvix-talk-highlights","title":"Explore Juvix: Talk Highlights","text":"<p>During the talk, you'll get an in-depth introduction to Juvix, an innovative language for developing next-generation decentralized applications. Juvix combines the strengths of functional languages with efficient compilation to low-level languages like C or LLVM, providing a powerful and transparent coding experience.</p> <p>Designed with a strong type system and a focus on referential transparency, Juvix incorporates the best features of existing functional languages. We'll explore Juvix's current state, including its compiler phases and language features, and discuss the ongoing development progress and the challenges we face in creating a robust tool for the rapidly evolving world of decentralised applications. With the power of the high-level language Juvix you can grasp on the easier way to create arithmetic circuits for zero-knowledge proofs.</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#engage-in-the-workshop-hands-on-experience","title":"Engage in the Workshop: Hands-On Experience","text":"<p>In addition to the introductory presentation, we invite you to join our practical workshop session on Juvix. It's an excellent opportunity to dive deeper into Juvix and get hands-on experience.</p> <p>During the workshop, our team will guide you through creating your first Juvix application. How exciting is that! We'll assist you with installing the Juvix compiler and related tools, provide an overview of the Juvix language, and explore some fascinating Juvix applications.</p> <p>To get started, simply clone the workshop GitHub repository. It contains all the necessary instructions to prepare for the workshop in advance. Don't worry if you encounter any questions or challenges along the way \u2014 we'll be there to support and assist you during the workshop.</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/ethprague/#meet-the-team","title":"Meet the team","text":"<p>In addition to the talk and workshops, the teams will have a dedicated Namada/Anoma booth at the venue. We'd love for you to stop by, say hi and learn more about the projects. The team would love to hear from you and meet you there.</p> <p>And, of course, your effort and hard work will be rewarded by the unique merch we will be sharing exclusively with the talk and workshop participants. Join the session, or come find us at the Juvix booth at the conference premises to get some for yourself!</p> <p>See you in Prague \ud83c\udde8\ud83c\uddff</p>","tags":["ETHPrague","Workshop"]},{"location":"blog/geb-backend/","title":"Compiling to VampIR through Geb","text":"<p>Before, we discussed the standard normalization approach to compiling Juvix programs to VampIR. An alternative backend is provided by the Geb project currently implemented in Lisp showcasing a categorical view of the needed translations.</p> <p>The post will be devoted to discussing the core ideas of Geb, the practical steps to take in order to use the corresponding pipeline, as well as the current limitations the backend faces.</p> <p>We assume basic familiarity with categorical concepts and VampIR.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#geb-pipeline","title":"Geb Pipeline","text":"<p>Geb is a developing language providing a useful interface for specifying categorical constructs and helping define compilers in terms of functors. The approach is inspired by a classical observation that instead of dealing with 'good' compilation procedures one can instead specify functors between appropriate categories representing the languages in question.</p> <p>In the current state of development, Geb is a fairly simple category in which one can do \"basic arithmetic.\" It is a category freely spanned by terminal/initial objects and finite (co)products with additional constructs for objects representing <code>n</code>-bit natural numbers and the distributivity axiom. The pipeline itself is a string of functors between categories:</p> \\[ \\text {Lambda} \\to \\text {Geb} \\to \\text {Seq} \\mathbb N \\] <p>which are all implemented in Lisp. The morphisms in the final category have a fairly direct interpretation as VampIR programs.</p> <p>Here, Lambda stands for an extension of STLC with natural numbers types of different bit-width and some arithmetic, while Seq\\(\\mathbb N\\) is a category of finite natural number sequences with morphism $$f: (x_1,\\dots,x_n) \\to (y_1,\\dots,y_m) $$ a VampIR function which takes in \\(n\\) inputs with \\(i\\)-th input of bit-length \\(x_i\\) and spits out an \\(m\\)-tuple with \\(i\\)-th outputs of bit-length \\(y_i\\).</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#the-practice","title":"The Practice","text":"<p>In this section, we describe all the practical steps one needs to take in order to compile Juvix code to VampIR using the Geb binary.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-juvix-to-lambda","title":"From Juvix to Lambda","text":"<p>The first step to the compilation is getting Juvix code to compile to Lambda. The translation can be done inside of Juvix itself.</p> <p>Let us create an example using one of the VampIR tests in the codebase. We create a file <code>NotZero.juvix</code> with body</p> <pre><code>module NotZero;\n\nimport Stdlib.Data.Bool open;\nimport Stdlib.Data.Nat open;\nimport Stdlib.Trait open;\n\n-- We need to name the module exactly the same name as the file\nintToBool (x : Nat) : Bool := not (x == 0);\n\n-- We need to include a function named main\n-- for the compilation to succeed\nmain : Nat -&gt; Bool := intToBool;\n</code></pre> <p>and we want to compile it to code that is readable by the Lisp implementation of Geb. We run</p> <pre><code>juvix compile -t geb NotZero.juvix\n</code></pre> <p>which generates a <code>NotZero.lisp</code> file with the following code:</p> <pre><code>(defpackage #:NotZero\n  (:shadowing-import-from :geb.lambda.spec #:pair #:right #:left)\n  (:shadowing-import-from :geb.spec #:case)\n  (:shadowing-import-from :geb.lambda.trans #:int)\n  (:use #:common-lisp #:geb.lambda.spec #:geb)\n  (:export :*entry*))\n\n(in-package :NotZero)\n\n(defparameter *entry*\n  (lamb\n    (list\n      int)\n    (case-on\n      (lamb-eq\n        (index 0)\n        (bit-choice 0))\n      (bit-choice 1)\n      (bit-choice 0))))\n</code></pre> <p>The file generated will be used by the Geb binary where <code>*entry*</code> is a parameter for a term to be compiled. The Lambda code produced is similar to STLC with certain variations. In the above code, we have:</p> <ol> <li><code>int</code> a stand-in for a type of 24-bit numbers</li> <li><code>lamb</code> is lambda abstraction</li> <li><code>case-on</code> is sum type induction</li> <li><code>lamb-eq</code> predicate for checking number equality</li> <li><code>index n</code> is an <code>n</code>-th DeBruijn index</li> <li><code>bit-choice n</code> is a constructor for number <code>n</code></li> </ol>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-lambda-to-vampir","title":"From Lambda to VampIR","text":"<p>After generating the file, one needs to go into the Geb repository, make a binary, creating <code>geb.image</code> file inside the <code>build</code> folder. Next, copy the path of the <code>NotZero.lisp</code> file created, e.g. <code>/home/Juvix_Files/NotZero.lisp</code>. Afterwards, go to the <code>build</code> folder in Geb and feed in:</p> <pre><code>./geb.image -i \"/home/Juvix_Files/NotZero.lisp\" -e \"NotZero:*entry*\" -l -p -o \"NotZero.pir\"\n</code></pre> <p>This will generate a <code>NotZero.pir</code> file in <code>build</code> with the inserted Lambda code compiled to VampIR through Geb.</p> <p>One can remove <code>-o \"NotZero.pir\"</code> in order for the terminal to print the relevant code instead of putting it in a separate file.</p> <p>In the build directory type</p> <pre><code>./geb.image -i \"NotZero.lisp\" -e \"NotZero:*entry*\" -l -p\n</code></pre> <p>Which returns</p> <pre><code>(def entry x1 x2 = {\n   (1 - (iszero x1))\n };)\n</code></pre> <p>Note that the last variable in the function is unused. This will be the case for any compiled function and is due to a compilation side-effect when we go from Lambda to Geb.</p> <p>For further instructions on the use of the binary, consult the Geb documentation.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#interactive-mode","title":"Interactive Mode","text":"<p>If one is interested in using more features than the direct compilation to VampIR, one may use the Geb codebase interactively.</p> <p>To do so, load the system as per the Geb documentation, then go a package preferably using all the relevant lambda code such as <code>geb.lambda.trans</code> by typing</p> <pre><code>CL-USER&gt; (in-package geb.lambda.trans)\n</code></pre> <p>Here one can compile the relevant code to several targets. <code>to-circuit</code> takes a lambda term in an empty context and a name.</p> <p>If we want to compile the identity function on natural numbers <code>(lamb (list int) (index 0))</code> with name <code>id</code> we type</p> <pre><code>TRANS&gt; (to-circuit (lamb (list int) (index 0)) :id)\n</code></pre> <p>Moreover, we can compile this not to a circuit but to Geb in a nil context (which we need to specify explicitly), e.g. by typing</p> <pre><code>TRANS&gt; (to-cat nil (lamb (list int) (index 0)))\n</code></pre> <p>or to Seq\\(\\mathbb N\\) in the nil context by</p> <pre><code>TRANS&gt; (to-seqn (lamb (list int) (index 0)))\n</code></pre> <p>Hence instead of using the binary, we could instead go to the REPL, enter <code>geb.lambda.trans</code> and type in the body of the compiled term:</p> <pre><code> (to-circuit (lamb\n    (list\n      int)\n    (case-on\n      (lamb-eq\n        (index 0)\n        (bit-choice 0))\n      (bit-choice 1)\n      (bit-choice 0))) :entry)\n</code></pre> <p>and get the same output:</p> <pre><code>(def entry x1 x2 = {\n   (1 - (iszero x1))\n };)\n</code></pre> <p>For further utility function discription, please consult the relevant documentation.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#the-theory","title":"The Theory","text":"<p>This section is devoted to describing the core ideas of how the compilation occurs step-by-step.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-juvix-to-lambda_1","title":"From Juvix to Lambda","text":"<p>The transformation of Juvix to Lambda is a pretty easy one compared to the normalization approach partially due to the limitations we will discuss later.</p> <p>The Juvix code gets transformed by</p> <ol> <li>Transforming type names and rescuing needed type signatures, e.g. <code>Nat</code>    becomes primitive <code>Int</code></li> <li>Unrolling recursion</li> <li>Lifting out let-statements</li> <li>Inlining type synonyms</li> <li>Presenting finite indictive datatypes using sum/product type structures</li> </ol> <p>Afterwards, a direct translation to STLC follows.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-lambda-to-geb","title":"From Lambda to Geb","text":"<p>The compilation of Lambda to Geb is actually a canonical one. Geb is secretly a category equivalent to FinSet and in particular, is a Cartesian Closed Category. By a classical result of Lambek-Scott, there is a unique compilation of STLC to Geb preserving STLC structure. All other datatypes are compiled primitively: e.g. <code>plus</code> in Lambda gets compiled to the primitive <code>nat-plus</code>.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-geb-to-seqmathbb-n","title":"From Geb to Seq\\(\\mathbb N\\)","text":"<p>The transformation to the finite-sequence category representing VampIR operations is a bit tricky, yet the point is that each object in Geb has an intuitive notion of bit-width. The object of <code>n</code>-bit numbers has <code>n</code>-width, while <code>bool</code>, the coproduct of two terminal objects, has width <code>1</code>. Products should just append the widths of its parts while coproducts should mark the left bit entries with <code>0</code> while right ones with <code>1</code> to differentiate between the two. Hence all the objects get encoded in this manner with morphisms following a similar fashion.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#from-seqmathbb-n-to-vampir","title":"From Seq\\(\\mathbb N\\) to VampIR","text":"<p>The compilation to VampIR is a straightforward one as the morphisms in Seq\\(\\mathbb N\\) have been chosen in such a way that the category can be directly seen as a model of VampIR. For more detailed info on the compilation, consult the recent report on the pipeline by the Juvix team.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#limitations","title":"Limitations","text":"<p>After describing the Geb backend, we also need to mention current limitations and challenges that the pipeline faces.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#limited-interpretation-power","title":"Limited Interpretation Power","text":"<p>Currently, not all Juvix programs can be interpreted in Geb. As we have mentioned, Geb is just a variation of FinSet, a fairly weak category. We currently do not have support for interpreting any polymorphic type or any infinite datatype.</p> <p>Moreover, as there are no primitive function types in Geb, we also do not have a way to make internal function definitions via constraints in VampIR the way the normalizer compilation does.</p> <p>However, these issues are to be addressed in a newer version of Geb, which will significantly enhance the expressive power of the language.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#heap-exhaustion-for-functions-of-natural-number","title":"Heap Exhaustion for Functions of Natural Number","text":"<p>While Geb seems like a good candidate to do \"categorical arithmetic\" in and hence to compile to arithmetic circuits, the fact that the primitive constructions are very minimal serves as a reason for an exponential blow-up. An object representing <code>n</code>-bit natural number <code>nat-width n</code> is analyzed as a <code>2^n</code> coproduct of terminal objects. So even if we have primitives for natural numbers, for <code>curry</code> and <code>uncurry</code> operations the functions get analyzed bit-by-bit, causing a blow-up.</p> <p>If one compiles complicated functions, even working with 2-bit numbers can cause a heap exhaust.</p> <p>However, that is a problem that occurs when one wants to use Lambda separately and compile arbitrary terms. All the Juvix code that we compile become \\(\\beta\\)-reduced with no function application or lambdas outside of the top of the term remaining. This solves our problem for using Geb as a Juvix backend.</p>","tags":["circuits","vampir"]},{"location":"blog/geb-backend/#heap-exhaustion-for-recursive-functions","title":"Heap Exhaustion for Recursive Functions","text":"<p>The way that we interpret recursive Juvix functions (similarly to the strategy of compiling directly to circuits) comes from unrolling recursion. Currently this creates big Lambda terms and due to current memory-managing constraints, can create a heap exhaust during compilation.</p>","tags":["circuits","vampir"]},{"location":"blog/iterators/","title":"Iterator syntax","text":"<p>A common pattern in functional programming is the traversal of data structures, particularly lists, in a specified order accumulating some values. If you've used languages like Haskell or OCaml, you must have come across the \"fold left\" (<code>foldl</code>) and \"fold right\" (<code>foldr</code>) higher-order functions which implement this pattern. These functions are also available in Juvix. In this blog post, I describe an iterator syntax I designed for Juvix which allows expressing folds (and maps, filters and more) in a readable manner.</p> <p>The next paragraph discusses some issues with using fold functions directly. Don't worry if you've never heard of folds - just skip this paragraph and the rest of the blog post will teach you how to use them in a nice iterator syntax.</p> <p>The problem with folds is that they are hard to read and understand, which results in code that is difficult to maintain. From a fold application, e.g., <code>foldr \\{ acc x := body } a xs</code>, it is not always immediately apparent how the list traversal proceeds. This is especially the case when the function argument is big and spans several lines - then the initial value <code>a</code> of the accumulator and the list <code>xs</code> are syntactically \"disconnected\" from the accumulator variable <code>acc</code> and the current list element <code>x</code>. Personally, I also find it hard to remember which argument is which - this differs between different functional languages. I'm not the first person who noticed this problem. For example, the unreadability of folds was one of the motivations behind introducing a monadic <code>for .. in</code> notation in Lean 4.</p>","tags":["iterators","syntax"]},{"location":"blog/iterators/#the-essence-of-folds","title":"The essence of folds","text":"<p>The anatomy of a fold (left or right) is simple.</p> <ol> <li> <p>We have an accumulator variable <code>acc</code> which we initialise to some value <code>a</code>.</p> </li> <li> <p>We go through a data structure (list) in some specified order (left-to-right    or right-to-left).</p> </li> <li> <p>At each step, we receive the current value of the accumulator <code>acc</code> and the    current element <code>x</code>. From those we need to compute the new value of <code>acc</code>.</p> </li> <li> <p>After going through all elements, the final value of <code>acc</code> is the result of    the fold expression.</p> </li> </ol>","tags":["iterators","syntax"]},{"location":"blog/iterators/#the-for-notation","title":"The for-notation","text":"<p>The Juvix standard library defines two iterators on lists which correspond to list folds:</p> <ul> <li><code>for</code> as a syntactic sugar for fold left (<code>foldl</code>),</li> <li><code>rfor</code> as a syntactic sugar for fold right (<code>foldr</code>).</li> </ul> <p>Iterator application has the syntax:</p> <pre><code>for (acc := a) (x in xs) {body}\n</code></pre> <p>The braces around <code>body</code> are optional.</p> <p>The above <code>for</code> iteration starts with the accumulator <code>acc</code> equal to <code>a</code> and goes through the list <code>xs</code> from left to right (from beginning to end), at each step updating the accumulator to the result of evaluating <code>body</code>. The variables <code>acc</code>, <code>x</code> are locally bound in <code>body</code> where they denote the previous accumulator value (<code>acc</code>) and the current element (<code>x</code>). The final value of the accumulator becomes the value of the entire <code>for</code> expression.</p> <p>For example, the following code computes the sum of all numbers in the list <code>xs</code>:</p> <pre><code>for (acc := 0) (x in xs) {x + acc}\n</code></pre> <p>Product of all numbers in a list:</p> <pre><code>for (acc := 1) (x in xs) {x * acc}\n</code></pre> <p>Reversing a list:</p> <pre><code>for (acc := nil) (x in xs) {x :: acc}\n</code></pre> <p>Counting odd numbers in a list:</p> <pre><code>for (acc := 0) (x in xs) {if (mod x 2 == 0) acc (acc + 1)}\n</code></pre> <p>Sum of squares of positive numbers in a list:</p> <pre><code>for (acc := 0) (x in xs) {if (x &gt; 0) (acc + x * x) acc}\n</code></pre> <p>The <code>for</code> iterator is complemented by the <code>rfor</code> iterator which goes through the list from right to left (from end to beginning).</p> <p>For example, the following code concatenates all lists from a list of lists:</p> <pre><code>rfor (acc := nil) (x in xs) {x ++ acc}\n</code></pre> <p>If we used the <code>for</code> iterator above, the order of concatenations would be reversed.</p> <p>Applying a function <code>f</code> to each element in a list may be implemented with:</p> <pre><code>rfor (acc := nil) (x in xs) {f x :: acc}\n</code></pre> <p>Filtering a list with a predicate <code>p</code>:</p> <pre><code>rfor (acc := nil) (x in xs) {if (p x) (x :: acc) acc}\n</code></pre> <p>The above keeps only the elements that satisfy <code>p</code>. The order of the elements would be reversed if we used <code>for</code> instead of <code>rfor</code>.</p>","tags":["iterators","syntax"]},{"location":"blog/iterators/#maps-filters-and-more","title":"Maps, filters and more","text":"<p>If you're familiar with the <code>map</code> and <code>filter</code> higher-order functions, you probably noticed that the last two examples above provide their implementations using <code>rfor</code>. In fact, one can use the iterator notation directly with <code>map</code> and <code>filter</code>, and several other list functions from the standard library. In this case, there are no explicit accumulators in the notation.</p> <p>The expression</p> <pre><code>map (x in xs) {body}\n</code></pre> <p>is equivalent to (assuming <code>acc</code> doesn't occur in <code>body</code>)</p> <pre><code>rfor (acc := nil) (x in xs) {(body) :: acc}\n</code></pre> <p>or if you're familiar with the standard <code>map</code> function:</p> <pre><code>map \\{ x := body } xs\n</code></pre> <p>Similarly, one can use the notation</p> <pre><code>filter (x in xs) p x\n</code></pre> <p>to filter <code>xs</code> with the predicate <code>p</code>.</p> <p>Other functions that can be used with the iterator syntax are <code>all</code> and <code>any</code> which check whether <code>all</code>, resp. <code>any</code>, elements <code>x</code> in a list satisfy <code>body</code> (which would of course refer to <code>x</code>):</p> <pre><code>all (x in xs) {body}\n\nany (x in xs) {body}\n</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators/#multiple-accumulators","title":"Multiple accumulators","text":"<p>In fact, the <code>acc</code> and <code>x</code> in the iterator syntax don't need to be variables - they can be arbitrary patterns. This is especially useful in conjunction with pairs, allowing to effectively operate on multiple accumulators.</p> <p>For example, to compute the largest and the second-largest element of a list of non-negative numbers one can use:</p> <pre><code>for (n, n' := 0, 0) (x in lst) {if (x &gt;= n) (x, n) (if (x &gt; n') (n, x) (n, n'))}\n</code></pre> <p>where <code>n</code> is the largest and <code>n'</code> the second-largest element found so far.</p> <p>One can also operate on multiple lists simultaneously. For example, the following computes the dot product of the lists <code>xs</code>, <code>ys</code> (assuming they have equal lengths):</p> <pre><code>for (acc := 0) (x, y in zip xs ys) {x * y + acc}\n</code></pre> <p>The <code>zip</code> function creates a list of pairs of elements in the two lists, e.g.,</p> <pre><code>zip (1 :: 2 :: nil) (3 :: 4 :: nil) = (1, 3) :: (2, 4) :: nil\n</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators/#declaring-iterators","title":"Declaring iterators","text":"<p>Iterator syntax can be enabled for any identifier <code>func</code> with the declaration:</p> <pre><code>syntax iterator func;\n</code></pre> <p>Then any iterator application of the form</p> <pre><code>func (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}\n</code></pre> <p>is automatically replaced by</p> <pre><code>func \\{ acc1 .. accn x1 .. xk := body } acc1 .. accn xs1 .. xsk\n</code></pre> <p>The replacement is entirely syntactic and happens before type-checking.</p> <p>It is possible to restrict the number of initialisers (<code>acci := ai</code>) and ranges (<code>xi in xsi</code>) accepted:</p> <pre><code>syntax iterator func {init: n, range: k};\n</code></pre>","tags":["iterators","syntax"]},{"location":"blog/iterators/#further-reading","title":"Further reading","text":"<p>More information on iterators can be found in the Juvix language reference and the Juvix tutorial.</p>","tags":["iterators","syntax"]},{"location":"blog/strictly-positive-data-types/","title":"Stay Positive with Your Data Types","text":"<p>In this discussion, we will explore the concept of strictly positive inductive data types, a critical requirement within the Juvix framework for classifying a data type as well-typed.</p> <p>An inductive type is considered strictly positive if it either:</p> <ol> <li>Does not appear within the argument types of its constructors, or</li> <li>Appears strictly positively within the argument types of its constructors.</li> </ol> <p>A name is considered strictly positive for an inductive type if it never appears in a negative position within the argument types of its constructors. The term negative position denotes instances located to the left of an arrow in a type constructor argument.</p>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types/#example","title":"Example","text":"<p>Consider the following data type <code>X</code> where <code>A</code> and <code>B</code> are types in scope:</p> <pre><code>  type X :=\n    | c0 : (B -&gt; X) -&gt; X\n    | c1 : (X -&gt; A) -&gt; X;\n</code></pre> <p>In this example, the type <code>X</code> occurs strictly positive in the constructor <code>c0</code>, but negatively in the constructor <code>c1</code> in the type argument <code>X -&gt; A</code>. Therefore, <code>X</code> is not strictly positive.</p> <p>Positive parameters can also be described as those that do not occur in negative positions. For instance, the type <code>B</code> in the <code>c0</code> constructor above appears to the left of the arrow <code>B-&gt;X</code>, placing <code>B</code> in a negative position. It is essential to consider negative parameters when verifying strictly positive data types, as they might enable the definition of non-strictly positive data types.</p> <p>Let us consider another example:</p> <pre><code>  type T0 (A : Type) := c0 : (A -&gt; T0 A) -&gt; T0 A;\n</code></pre> <pre><code>  type T1 := c1 : T0 T1 -&gt; T1;\n</code></pre> <p>In this example, the type <code>T0</code> is strictly positive, while the type <code>T1</code> is not. It is only after unfolding the type application <code>T0 (T1 A)</code> in the data constructor <code>c1</code> that we can determine <code>T1</code> occurs in a negative position due to <code>T0</code>. More specifically, the type parameter <code>A</code> of <code>T0</code> is negative.</p>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types/#bypassing-the-strict-positivity-condition","title":"Bypassing the Strict Positivity Condition","text":"<p>To bypass the positivity check in a data type declaration, you can annotate it with the <code>positive</code> keyword. Alternatively, you can use the CLI global flag <code>--no-positivity</code> when type checking a <code>Juvix</code> file.</p> <pre><code>  positive\n  type T0 (A : Type) := c0 : (T0 A -&gt; A) -&gt; T0 A;\n</code></pre>","tags":["type-system","inductive-types"]},{"location":"blog/strictly-positive-data-types/#examples-of-non-strictly-positive-data-types","title":"Examples of Non-Strictly Positive Data Types","text":"<ul> <li>The <code>Bad</code> data type is not strictly positive due to the negative parameter <code>A</code>   of <code>Tree</code>.</li> </ul> <pre><code>  type Tree (A : Type) :=\n    | leaf : Tree A\n    | node : (A -&gt; Tree A) -&gt; Tree A;\n</code></pre> <pre><code>  type Bad := bad : Tree Bad -&gt; Bad;\n</code></pre> <ul> <li><code>A</code> is a negative parameter.</li> </ul> <pre><code>  type B (A : Type) := b : (A -&gt; B (B A -&gt; A)) -&gt; B A;\n</code></pre>","tags":["type-system","inductive-types"]},{"location":"blog/vampir-circuits/","title":"Compiling Juvix programs to arithmetic circuits via Vamp-IR","text":"<p>Since version 0.3.5, the Juvix compiler supports the <code>vampir</code> target which generates Vamp-IR input files that can be compiled to various proof systems based on arithmetic circuits, like Plonk or Halo 2. Vamp-IR is a proof-system-agnostic language for writing arithmetic circuits.</p> <p>In this post, we will not be discussing the details of Vamp-IR or the circuit computation model. Instead, we will describe how high-level functional Juvix programs can be compiled to circuits, what the common pitfalls and current limitations are. The reader is assumed to have at least basic familiarity with Vamp-IR.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#a-simple-circuit-program","title":"A simple circuit program","text":"<p>For a simple example of a Juvix program that can be compiled to an arithmetic circuit via Vamp-IR, we consider computing the 6-bit mid-square hash of a 16-bit number.</p> <pre><code>module MidSquareHash;\n\nimport Stdlib.Prelude open;\n\n--- `pow N` is 2 ^ N\npow : Nat -&gt; Nat\n  | zero := 1\n  | (suc n) := 2 * pow n;\n\n--- `hash N` hashes a number with max N bits (i.e. smaller than 2^N) into 6 bits\n--- (i.e. smaller than 64) using the mid-square algorithm.\nhash : Nat -&gt; Nat -&gt; Nat\n  | (suc n@(suc (suc m))) x :=\n    if\n      (x &lt; pow n)\n      (hash n x)\n      (mod (div (x * x) (pow m)) (pow 6))\n  | _ x := x * x;\n\nmain (x y : Nat) : Bool := hash 16 x == y;\n</code></pre> <p>To compile this file to Vamp-IR type</p> <pre><code>juvix compile -t vampir MidSquareHash.juvix\n</code></pre> <p>This should generate the <code>MidSquareHash.pir</code> file containing the Vamp-IR code.</p> <p>The exact details of the hashing algorithm are not essential here. What matters is that Juvix can compile this ordinary high-level program, which uses recursion, pattern-matching, etc., into low-level Vamp-IR representation. The user does not need to understand arithmetic circuits or Vamp-IR beyond the basics.</p> <p>The Juvix <code>main</code> function is compiled to a Vamp-IR <code>main</code> function which is then used in an equation which connects the inputs (arguments of <code>main</code>) to the ouput of <code>main</code>. For example, for the program above the generated equation is:</p> <pre><code>main x y = 1;\n</code></pre> <p>stating that <code>main x y</code> equals <code>true</code>. The variables <code>x</code>, <code>y</code> are Vamp-IR's private inputs.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#controlling-generated-equations","title":"Controlling generated equations","text":"<p>In principle, any Juvix program can be compiled to a circuit, subject to certain restrictions. When targeting Vamp-IR, the <code>main</code> function must have the type</p> <pre><code>main : ArgTy1 -&gt; .. -&gt; ArgTyN -&gt; ResTy;\n</code></pre> <p>where <code>ArgTyK</code> and <code>ResTy</code> are <code>Nat</code>, <code>Int</code> or <code>Bool</code>. Since Vamp-IR natively supports only numbers (field elements), booleans are represented using <code>1</code> for <code>true</code> and <code>0</code> for <code>false</code>.</p> <p>If the result type <code>ResTy</code> is a boolean (<code>Bool</code>), then the generated Vamp-IR file will contain the equation</p> <pre><code>main arg1 .. argN = 1;\n</code></pre> <p>where <code>arg1</code>, .., <code>argN</code> are the names of inputs to the <code>main</code> function. By default, these are inferred from the variable names in the first clause of <code>main</code>, e.g., compiling</p> <pre><code>main (x y : Nat) : Bool := x == y;\n</code></pre> <p>will generate Vamp-IR code similar to</p> <pre><code>def main x y = equal x y;\n\nmain x y = 1;\n</code></pre> <p>The Vamp-IR input variable names can also be explicitly specified with the <code>argnames</code> pragma, e.g., compiling</p> <pre><code>{-# argnames: [a, b] #-}\nmain (x y : Nat) : Bool := x == y;\n</code></pre> <p>will generate Vamp-IR code similar to</p> <pre><code>def main x y = equal x y;\n\nmain a b = 1;\n</code></pre> <p>If the result type <code>ResTy</code> is <code>Nat</code> or <code>Int</code>, then the generated equation is</p> <pre><code>main arg1 .. argN = out;\n</code></pre> <p>Currently, all Vamp-IR inputs (<code>argK</code>, <code>out</code>) are private, and it is not possible to change the name of <code>out</code>. These technical limitations will be lifted in future Juvix versions.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#recursion-unrolling","title":"Recursion unrolling","text":"<p>Neither arithmetic circuits nor the Vamp-IR intermediate representation support recursion. This means that all Juvix recursive functions need to be unrolled up to a specified depth. Currently, the default unrolling depth is 140, which may be too much or too little depending on your particular program. The unrolling depth can be specified globally on the command line with the <code>--unroll</code> option, or on a per-function basis with the <code>unroll</code> pragma. For example, using</p> <pre><code>{-# unroll: 16 #-}\nhash : Nat -&gt; Nat -&gt; Nat;\n</code></pre> <p>would limit the recusion depth (i.e. the number of possible nested recursive calls) for <code>hash</code> to 16. It is the responsibility of the user to ensure that the recursion unrolling depth is sufficient for all arguments that the function might be applied to in the program. In the above example, <code>hash</code> recurses on its first argument and the call to <code>hash</code> in <code>main</code> provides <code>16</code> as the first argument. Hence, no more than 16 nested recursive calls to <code>hash</code> are possible.</p> <p>If the recursion unrolling depth is too small, i.e. smaller than the actual number of nested recursive calls, then the computation result may be incorrect. On the other hand, the circuit size grows with the unrolling depth, so it's advised to keep it as small as possible.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#compilation-by-normalization","title":"Compilation by normalization","text":"<p>Currently, the Juvix compiler uses a straightforward method to translate Juvix programs to Vamp-IR code: it simply computes the full normal form of the <code>main</code> function. Because of the restrictions we imposed on its type, the normal form of the <code>main</code> function must be an applicative expression built up from variables, constants and arithmetic and boolean operations. Such an expression can be directly translated to the Vamp-IR input format.</p> <p>The disadvantage of performing full normalization is that it may super-exponentially blow up the size of the program. As explained below, this applies in particular to branching recursive functions with at least two recursive calls.</p>","tags":["circuits","vampir"]},{"location":"blog/vampir-circuits/#the-branching-problem","title":"The branching problem","text":"<p>With the current compilation method, any recursive function which contains two or more recursive calls to itself in its body will cause an exponential blow-up in the generated code size, and thus will most likely fail to compile. As a rule of thumb, the size of the VampIR code generated for a Juvix function is proportional to k^n where k &gt; 1 is the number of recursive calls in the function body and n is the unrolling depth; or proportional to n when k = 1.</p> <p>For example, trying to compile the fast power function</p> <pre><code>{-# unroll: 30 #-}\nterminating\npower' (acc a b : Nat) : Nat :=\n  if\n    (b == 0)\n    acc\n    (if\n      (mod b 2 == 0)\n      (power' acc (a * a) (div b 2))\n      (power' (acc * a) (a * a) (div b 2)));\n\npower : Nat \u2192 Nat \u2192 Nat := power' 1;\n</code></pre> <p>makes the Juvix compiler hang. The pragma <code>unroll: 30</code> doesn't help, because 2^30 = 1073741824 is still a large number - this is the factor by which the program size increases during compilation.</p> <p>However, the fast power function may be reformulated to use only one recusive call:</p> <pre><code>{-# unroll: 30 #-}\nterminating\npower' (acc a b : Nat) : Nat :=\n  let\n    acc' : Nat := if (mod b 2 == 0) acc (acc * a);\n  in if (b == 0) acc (power' acc' (a * a) (div b 2));\n\npower : Nat \u2192 Nat \u2192 Nat := power' 1;\n</code></pre> <p>With the reformulated definition, the program size increases only by a factor of 30. Now compiling to Vamp-IR succeeds and it is possible to generate a ZK proof that e.g. 2^30 is indeed equal to 1073741824.</p>","tags":["circuits","vampir"]},{"location":"explanations/","title":"Index","text":"<p>Welcome to the Explanations section! In this part, we will dive into various coding concepts and techniques that are essential for every developer. We will cover a wide range of topics, from basic programming principles to more advanced subjects.</p>"},{"location":"explanations/typetheory/","title":"Type theory","text":""},{"location":"explanations/totality/coverage/","title":"Coverage checking","text":""},{"location":"explanations/totality/positive/","title":"Strictly positive data types","text":""},{"location":"explanations/totality/termination/","title":"Termination","text":"<p>To prevent inconsistencies arising from function declarations, Juvix mandates that every function passes its termination checker. Nevertheless, this requirement can be challenging to meet; thus, we provide users with two distinct methods for bypassing this check:</p>"},{"location":"explanations/totality/termination/#keyword","title":"Keyword","text":"<p>Utilize the terminating keyword to annotate function type signatures as terminating. In the following example we mark the function <code>fun</code> as terminating.</p> <pre><code>terminating\nfun : A \u2192 B;\n</code></pre> <p>Note</p> <p>Annotating a function with the <code>terminating</code> keyword indicates that all of its function clauses meet the termination checker's criteria. For mutual recursive functions, to bypass the termination checker, all involved functions must be annotated as <code>terminating</code>.</p>"},{"location":"explanations/totality/termination/#cli-flag","title":"CLI flag","text":"<p>You can disable the termination checking by utilizing the global CLI flag <code>--no-termination</code>.</p> <pre><code>juvix --no-termination typecheck MyProgram.juvix\n</code></pre> <p>Note</p> <p>Please note that our termination checker has certain limitations, as it only accepts a subset of recursive functions. The algorithm used in the termination checker is a minor adaptation of the one employed for checking termination in the Foetus language.</p>"},{"location":"howto/compilation/","title":"Program Compilation","text":"","boost":5},{"location":"howto/compilation/#example-hello-world","title":"Example: Hello World","text":"<p>A Juvix file must declare a module with the same name as the file. For instance, <code>HelloWorld.juvix</code> should declare a module <code>HelloWorld</code>:</p> <pre><code>\n</code></pre> <p>The zero-argument function <code>main</code> is evaluated when running the program and must be defined in a file compiled to an executable.</p> <p>To compile <code>HelloWorld.juvix</code>, type:</p> <pre><code>\n</code></pre> <p>For all options of the <code>compile</code> command, type:</p> <pre><code>\n</code></pre>","boost":5},{"location":"howto/compilation/#compilation-targets","title":"Compilation Targets","text":"<p>Juvix supports several targets specified with the <code>-t</code> option. Continuing the example above, to compile <code>HelloWorld.juvix</code> to a WebAssembly binary, type, we type:</p> <pre><code>\n</code></pre> <p>Targets include:</p> <ol> <li><code>native</code>: Default target producing a native 64bit executable.</li> <li><code>wasm32-wasi</code>: Produces a WebAssembly binary using the WASI runtime.</li> <li><code>vampir</code>: Creates a VampIR input file.</li> <li><code>geb</code>: Generates a GEB input file.</li> <li><code>core</code>: Produces <code>.jvc</code> file.</li> <li><code>asm</code>: Produces <code>.jva</code> file.</li> </ol>","boost":5},{"location":"howto/compilation/#compilation-options","title":"Compilation Options","text":"<p>To view all compilation options, type <code>juvix compile --help</code>. Commonly used options include:</p> <ul> <li><code>-t TARGET</code>: Target specification.</li> <li><code>-g</code>: Debug information and runtime assertions generation.</li> <li><code>-O LEVEL</code>: Optimization level setting (default: 1, or 0 with <code>-g</code>).</li> <li><code>-o FILE</code>: Output file specification.</li> </ul>","boost":5},{"location":"howto/compilation/#juvix-projects","title":"Juvix Projects","text":"<p>A Juvix project is a collection of Juvix modules in one main directory containing a <code>juvix.yaml</code> metadata file. Each module's name must match its file path, relative to the project's root directory. For instance, if the file is <code>root/Data/List.juvix</code>, the module should be called <code>Data.List</code>.</p> <p>To initialize a Juvix project interactively in the current directory, use <code>juvix init</code>.</p> <p>To verify correct project root detection by Juvix, run, for instance,</p> <pre><code>\n</code></pre> <p>Refer to: Modules Reference.</p>","boost":5},{"location":"howto/compilation/#compiling-to-vampir-backend","title":"Compiling to VampIR Backend","text":"<p>For the VampIR backend, the <code>main</code> function must have type:</p> <pre><code>Ty1 -&gt; ... -&gt; Tyn -&gt; TyR\n</code></pre> <p>Here, <code>Tyi</code>,<code>TyR</code> are <code>Nat</code>, <code>Int</code> or <code>Bool</code>. The compiler adds an equation to the generated VampIR file that states the relationship between the input and output of the <code>main</code> function:</p> <pre><code>main arg1 .. argn = out\n</code></pre> <p>Here, <code>arg1</code>, ... ,<code>argn</code> are the argument names of <code>main</code> found in the source code. If <code>main</code> returns a boolean (<code>Bool</code>), the compiler uses <code>1</code> (true) instead of <code>out</code>.</p> <p>The variables <code>argi</code>,<code>out</code> in the generated file are unbound VampIR variables for which VampIR solicits witnesses during proof generation.</p> <p>For example:</p> <pre><code>main (x y : Nat) : Bool := x + y &gt; 0;\n</code></pre> <p>Generates the equation:</p> <pre><code>main x y = 1\n</code></pre> <p>The <code>main</code> input argument names in the generated VampIR file can also be specified with the <code>argnames</code> pragma:</p> <pre><code>{-# argnames: [a, b] #-}\nmain (x y : Nat) : Bool := x + y &gt; 0;\n</code></pre> <p>Generates the equation:</p> <pre><code>main a b = 1\n</code></pre>","boost":5},{"location":"howto/contributing/","title":"Contributing to Juvix","text":"<p>Thank you for considering contributing to Juvix! We welcome all contributions, big or small, of any kind. We appreciate any help/feedback we can get.</p>"},{"location":"howto/contributing/#getting-started","title":"Getting Started","text":"<p>Make sure you have followed the installation instructions and have a working Juvix installation. You can also use the web-based development environment ready to the Juvix development, Juvix Github Codespace</p> <ol> <li>Fork the repository.</li> <li>Clone your forked repository to your local machine.</li> <li>Install Stack if you haven't already.</li> <li>Build the project by running <code>stack build</code>. To build the project with    optimizations, run <code>stack build --fast</code>. To install the binaries to your    local <code>~/.local/bin</code>, run <code>stack install</code>.</li> <li>Run the tests by running <code>stack test</code>.</li> <li>Make sure to install the pre-commit binary, so you can run the    pre-commit hooks by running <code>make precommit</code> in the root directory of the    project. All the Pull Requests will be checked by the pre-commit hooks.</li> </ol>"},{"location":"howto/contributing/#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your changes: <code>git checkout -b my-branch-name</code>. In    case you are working on an issue, please name your branch after the issue    number, e.g. <code>issue-123</code>.</li> <li>Make your changes and commit them with a descriptive message.</li> <li>Push your changes to your forked repository: <code>git push origin    my-branch-name</code>.</li> <li>Submit a pull request to the main repository with a concise description of    your changes.</li> <li>Make sure that your pull request passes all the tests and pre-commit hooks.</li> </ol>"},{"location":"howto/contributing/#haskell-code-style","title":"Haskell Code Style","text":"<p>We value readability and maintainability over saving lines of code. The best source of truth for the Juvix code style is the existing codebase. We strongly encourage you to look at the existing code and follow the same style. Open an issue if you have any questions, or better yet, join our Discord and ask there!</p> <p>Some basic guidelines when writing code:</p> <ul> <li>Use clear and descriptive names for variables, functions, and types.</li> <li>Keep functions short and focused on a single task. Separate functions when   they start to get too long.</li> <li>Use comments to explain complex or non-obvious code.</li> <li>Run <code>make format</code> to format your code with <code>ormolu</code>.</li> </ul>"},{"location":"howto/contributing/#testing","title":"Testing","text":"<p>Please include tests for any new functionality or bug fixes. The tests are located in the <code>test</code> directory, the tests are written in Haskell and use the tasty framework. To run the tests, run <code>stack test</code>. If you are changing the CLI, please also update the smoke tests in the <code>tests/smoke</code> directory.</p>"},{"location":"howto/contributing/#code-review","title":"Code Review","text":"<p>All pull requests will be reviewed by at least one member of the development team. Feedback may be provided on the code itself, as well as on the tests and documentation.</p> <p>Thank you for contributing to Juvix!</p>"},{"location":"howto/installing/","title":"Installing Juvix","text":"","boost":5},{"location":"howto/installing/#prerequisites","title":"Prerequisites","text":"<p>You need Clang / LLVM version 13 or later. Note that on macOS the preinstalled clang does not support the wasm target, so use e.g. <code>brew install llvm</code> instead.</p> <p>If you want to compile to WebAssembly, you also need:</p> <ul> <li>wasmer</li> <li>wasi-sdk</li> <li>wasm-ld - the LLVM linker for WASM (NB: On   Linux you may need to install the <code>lld</code> package; on macOS this is   installed as part of <code>llvm</code>).</li> </ul> <p>See below for instructions on how to install the dependencies.</p>","boost":5},{"location":"howto/installing/#shell-script","title":"Shell script","text":"<p>We provide a shell script that installs the Juvix compiler binary for Linux and macOS using the GitHub release page.</p> <p>Copy and paste the following command into your terminal to install Juvix.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSfL https://get.juvix.org | sh\n</code></pre> <p>In VSCode, install Juvix automatically with the Juvix VSCode   extension.</p>","boost":5},{"location":"howto/installing/#macos","title":"MacOS","text":"<p>The easiest way to install Juvix on MacOS is by using Homebrew.</p> <p>To install the homebrew-juvix tap, run:</p> <pre><code>brew tap anoma/juvix\n</code></pre> <p>To install Juvix, run:</p> <pre><code>brew install juvix\n</code></pre> <p>Helpful information can also be obtained by running:</p> <pre><code>brew info juvix\n</code></pre>","boost":5},{"location":"howto/installing/#linux-x86_64","title":"Linux x86_64","text":"<p>A Juvix compiler binary executable for Linux x86_64 is available on the Juvix release page.</p> <p>To install this executable, download and unzip the linked file and move it to a directory on your shell's <code>PATH</code>.</p> <p>For example if <code>~/.local/bin</code> is on your shell's <code>PATH</code>, you can install Juvix as follows:</p> <pre><code>cd /tmp\ncurl https://api.github.com/repos/anoma/juvix/releases/latest \\\n  | grep \"browser_download_url.*linux\" \\\n  | cut -d : -f2,3 | tr -d \\\" \\\n  | xargs curl -L -o linux_release.zip\nunzip linux_release.zip\nmv juvix ~/.local/bin/juvix\n</code></pre>","boost":5},{"location":"howto/installing/#building-juvix-from-source","title":"Building Juvix from source","text":"<p>To install Juvix from source you must clone the GitHub repository. Then Juvix can be installed with the following commands. We assume you have Stack and GNU Make installed.</p> <pre><code>git clone --recursive https://github.com/anoma/juvix.git\ncd juvix\nmake install\n</code></pre> <p>The C compiler and linker paths can be specified as options to the <code>make install</code> command, e.g.</p> <pre><code>make install CC=path/to/clang LIBTOOL=path/to/llvm-ar\n</code></pre> <p>On macOS, you can alternatively run the following command for Homebrew. The flag <code>--HEAD</code> used below is optional \u2013 use it to build the latest version of Juvix in the <code>main</code> branch on GitHub.</p> <pre><code>brew install --build-from-source --HEAD juvix --verbose\n</code></pre>","boost":5},{"location":"howto/installing/#building-the-project-with-cabal","title":"Building the project with <code>cabal</code>","text":"<p>We recommend using the <code>stack</code> build tool with this project.</p> <p>If you prefer the <code>cabal</code> build tool instead, then you need to generate the <code>juvix.cabal</code> file using hpack before running <code>cabal build</code>.</p> <p>You also need to compile the runtime first:</p> <pre><code>make runtime\ncabal build\n</code></pre>","boost":5},{"location":"howto/installing/#installing-dependencies","title":"Installing dependencies","text":"<p>To install <code>wasi-sdk</code> you need to download <code>libclang_rt</code> and <code>wasi-sysroot</code> precompiled archives from the wasi-sdk release page and:</p> <ol> <li> <p>Extract the <code>libclang_rt.builtins-wasm32-wasi-*.tar.gz</code> archive in     the <code>clang</code> installation root (for example <code>/usr/lib/clang/13</code> on     Ubuntu or <code>`brew --prefix llvm`</code> on macOS).</p> <p>For example on macOS with <code>homebrew clang</code>:</p> </li> </ol> <pre><code>cd `brew --prefix llvm`\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/libclang_rt.builtins-wasm32-wasi-15.0.tar.gz -OL\ntar xf libclang_rt.builtins-wasm32-wasi-15.0.tar.gz\n</code></pre> <ol> <li> <p>Extract the <code>wasi-sysroot-*.tar.gz</code> archive on your local system and     set <code>WASI_SYSROOT_PATH</code> to its path.</p> <p>For example:</p> </li> </ol> <pre><code>cd ~\ncurl https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-15/wasi-sysroot-15.0.tar.gz -OL\ntar xf wasi-sysroot-15.0.tar.gz\nexport WASI_SYSROOT_PATH=~/wasi-sysroot\n</code></pre> <p>Checking your setup</p> <p>Run <code>juvix doctor</code> in your terminal to validate your setup.</p>","boost":5},{"location":"howto/project/","title":"How to setup a Juvix project","text":"<p>A Juvix project is a collection of Juvix modules plus some extra metadata gathered in a <code>Package.juvix</code> file. The most convenient way to create a Juvix project is to run the command:</p> <pre><code>      juvix init\n</code></pre>","boost":5},{"location":"howto/project/#packagejuvix-file","title":"Package.juvix file","text":"<p>A project is rooted in a directory. The root is set by creating a <code>Package.juvix</code>. The simplest <code>Package.juvix</code> file, which uses the default configuration, is:</p> <pre><code>module Package;\n\nimport PackageDescription.V1 open;\n\npackage : Package := defaultPackage;\n</code></pre> <p>You can override the default options by passing arguments to <code>defaultPackage</code>:</p> <pre><code>package : Package :=\n  defaultPackage\n    {name := \"my-package\";\n     version := mkVersion 0 1 0;\n     dependencies := [ defaultStdlib\n                     ; github \"anoma\" \"juvix-containers\" \"v0.7.1\"\n                     ];\n     main := just \"Main.juvix\"\n    };\n</code></pre> <p>You can check the documentation of the <code>Package</code> type or the <code>defaultPackage</code> function by using the go-to-definition feature in your IDE.</p> <p>The arguments are explained below.</p> <ul> <li>name: This is the name assigned to the project. The name must not be empty   and cannot exceed 100 characters. Lower case letters, digits and hyphen <code>-</code>   are acceptable characters. The first letter must not be a hyphen.   Summarizing, it must match the following regexp: <code>[a-z0-9][a-z0-9-]{0,99}</code>.</li> <li>version (optional): The version of the project. It must follow the   SemVer specification. If unspecified, the default version is \"0.0.0\".</li> <li>main (optional): The main module of the project used as entry point.</li> <li>dependencies (optional): The dependencies of the project is given as a   list. See below for more information. If unspecified, the default is <code>defaultStdlib</code>.</li> </ul> <p>Note</p> <p>As intuition would tell, a Juvix module belongs to a Juvix project if it is   placed in the subtree hanging from the root directory. This rule has two   exceptions:</p> <ol> <li>Modules in a hidden (or hanging from a hidden) directory are not part of the      project. E.g., if the root of a project is <code>dir</code>, then the module      <code>dir/.d/Lib.juvix</code> does not belong to the project rooted in <code>dir</code>.</li> <li>A <code>Package.juvix</code> file shadows other <code>Package.juvix</code> files in parent      directories. E.g. if the root of a project is <code>dir</code> and the files      <code>dir/Package.juvix</code> and <code>dir/nested/Package.juvix</code> exist, then the module      <code>dir/nested/Lib.juvix</code> would belong to the project in <code>dir/nested</code>.</li> </ol> <p>Note</p> <p>Any Juvix module outside of a project is considered a standalone module and lives in its own (global) project. In other words, there is no need to create a <code>Package.juvix</code> file for a standalone module.</p>","boost":5},{"location":"howto/project/#package-dependencies","title":"Package dependencies","text":"<p>In <code>Package.juvix</code>, the <code>Package</code> type includes a dependencies field, which lists the other Juvix packages required by the project, with each dependency represented as an element of the <code>Dependency</code> type.</p> <p>Your project's code can use modules from dependent packages via standard Juvix <code>import</code> statements.</p> <p>There are three types of dependencies, all illustrated in the following snippet:</p> <pre><code>package : Package :=\n  defaultPackage\n    {name := \"my-package\";\n     version := mkVersion 0 1 0;\n     dependencies := [ defaultStdlib\n                     ; github \"anoma\" \"juvix-containers\" \"v0.7.1\"\n                     ; git \"my-dependency\" \"https://my-git-repo-url\" \"my-git-ref\"\n                     ; path \"a/path/to/a/juvix/package\"\n                     ]\n    };\n</code></pre>","boost":5},{"location":"howto/project/#git-dependencies","title":"Git Dependencies","text":"<p>A <code>git</code> dependency is a Juvix package located at the root of an external git repository. You can specify such a dependency in two ways:</p> <ol> <li>By using the <code>git</code> constructor of the <code>Dependency</code> type, you can declare the dependency by providing its name (used to name the directory where the repository is cloned), the git repository URL, and the specific reference (like a version tag or branch). For example:</li> </ol> <pre><code>git \"juvix-containers\" \"https://github.com/anoma/juvix-containers\" \"v0.7.1\"\n</code></pre> <ol> <li>By using the <code>github</code> function, which is a convenient method for packages hosted on GitHub. This function requires the GitHub organization name, the repository name, and the reference you're targeting. For example:</li> </ol> <pre><code>github \"anoma\" \"juvix-containers\" \"v0.7.1\"\n</code></pre> <p>Note</p> <p>The values of the <code>name</code> fields must be unique among the git blocks in the dependencies list.</p>","boost":5},{"location":"howto/project/#path-dependencies","title":"Path Dependencies","text":"<p>A <code>path</code> dependency is a Juvix package located on your local filesystem. You can refer to such dependencies using absolute or relative paths. For example:</p> <pre><code>path \".deps/a/juvix/package\"\n</code></pre>","boost":5},{"location":"howto/project/#the-built-in-juvix-standard-library-defaultstdlib","title":"The built-in Juvix standard library - <code>defaultStdlib</code>","text":"<p>The Juvix standard library is included with the Juvix compiler, and you can depend on it by using the <code>defaultStdlib</code> constructor.</p>","boost":5},{"location":"howto/project/#behaviour-of-git-dependencies","title":"Behaviour of Git dependencies","text":"<p>When dependencies for a package are registered, at the beginning of the compiler pipeline, all remote dependencies are processed:</p> <ol> <li>If it does not already exist, the remote dependency is cloned to    <code>.juvix-build/deps/$name</code></li> <li><code>git fetch</code> is run in the clone</li> <li><code>git checkout</code> at the specified <code>ref</code> is run in the clone</li> </ol> <p>Note</p> <ul> <li>Remote dependencies of transitive dependencies are also processed.</li> <li>The <code>git fetch</code> step is required for the case where the remote is updated.</li> </ul> <p>Lock file</p> <ul> <li>A lock file, juvix.lock.yaml is generated in the same directory as <code>Package.juvix</code>. This file is used to     determine if any dependency needs to be updated. If the <code>ref</code> in the     lock file does not match the <code>ref</code> in the package file, it is considered out of date.</li> </ul>","boost":5},{"location":"howto/project/#fixing-errors","title":"Fixing errors","text":"<ul> <li>Juvix parse or typechecker errors will be reported by the Juvix compiler.</li> <li>Duplicate <code>name</code> values in the dependencies list is an error thrown when the package file is processed</li> <li>The <code>ref</code> does not exist in the clone or the clone directory is otherwise   corrupt. An error with a suggestion to <code>juvix clean</code> is given. The package   file path is used as the location in the error message.</li> <li>Other <code>git</code> command errors (command not found, etc.), a more verbose error is   given with the arguments that were passed to the git command.</li> </ul>","boost":5},{"location":"howto/quick-start/","title":"Quick Start","text":"<p>To install Juvix, follow the instructions in the installation guide.</p> <p>After installation, run <code>juvix --help</code> to see the list of commands.</p> <p>Run Juvix doctor to check your system setup:</p> <pre><code>juvix doctor\n</code></pre>","boost":5},{"location":"howto/quick-start/#cli-usage-examples","title":"CLI Usage Examples","text":"<p>Create a new package:</p> <pre><code>juvix init\n</code></pre> <p>Evaluate a source file:</p> <pre><code>juvix eval path/to/source.juvix\n</code></pre> <p>Compile a source file into a native executable:</p> <pre><code>juvix compile path/to/source.juvix\n</code></pre> <p>Compile a source file into a WebAssembly binary:</p> <pre><code>juvix compile -t wasm32-wasi path/to/source.juvix\n</code></pre> <p>Launch the REPL:</p> <pre><code>juvix repl\n</code></pre> <p>Typecheck a source file:</p> <pre><code>juvix typecheck path/to/source.juvix\n</code></pre> <p>Generate HTML representations of a source file and its imports:</p> <pre><code>juvix html --recursive path/to/source.juvix\n</code></pre>","boost":5},{"location":"howto/quick-start/#the-hello-world-example","title":"The Hello World example","text":"<p>This is the Juvix source code of the traditional Hello World program.</p> <pre><code>-- HelloWorld.juvix\nmodule HelloWorld;\n\nimport Stdlib.Prelude open;\n\nmain : IO := printStringLn \"hello world!\";\n</code></pre> <p>To compile and run a binary generated by Juvix, save the source code to a file called <code>HelloWorld.juvix</code> and run the following command from the directory containing it:</p> <pre><code>juvix compile HelloWorld.juvix\n./HelloWorld\n</code></pre> <p>You should see the output: <code>hello world!</code></p> <p>The source code can also be compiled to a WebAssembly binary. This requires some additional setup. See the Installation How-to for more information. You can also run <code>juvix doctor</code> to check your setup.</p> <pre><code>juvix compile --target wasm32-wasi HelloWorld.juvix\nwasmer HelloWorld.wasm\n</code></pre>","boost":5},{"location":"notes/lsp/","title":"LSP support","text":"<p>We provide a sample <code>hie.yaml</code> configuration file for both <code>cabal</code> and <code>stack</code>.</p> <p>If you prefer <code>stack</code>, run:</p> <pre><code>cp stack.hie.yaml hie.yaml\n</code></pre> <p>If you prefer <code>cabal</code>, run:</p> <pre><code>cp cabal.hie.yaml hie.yaml\n</code></pre>"},{"location":"notes/runtime-benchmark-results/","title":"Benchmarks of the new Juvix runtime","text":"<p>Benchmarked version: commit 148ececb4d4259eacbb980f5992073a3ac611d82 from 31.10.2022</p>"},{"location":"notes/runtime-benchmark-results/#summary","title":"Summary","text":"<p>We benchmark several programs manually compiled into the primitives of the new Juvix runtime. The code corresponds closely to the code that will be generated by the new compilation process, with basic low-level optimisations (unboxing, untagging, etc.) but without any high-level optimisations on JuvixCore (inlining, specialisation, constant folding, fusion, etc.). This corresponds to the compilation process planned for the 0.4 milestone.</p> <p>We compare the running time and memory usage with analogous programs written in Haskell, OCaml, JuvixCore (using the evaluator), current Juvix (with the \"direct\" transpilation to C) and C.</p> <p>The results suggest that for most first-order programs the new compilation process will produce code with running time comparable to the code produced by the native OCaml compiler. For higher-order programs heavy on closure manipulation, the results are acceptable but noticeably worse, especially with third-order functions (i.e. functions which take functions taking functions). This could, however, be alleviated by implementing the specialisation optimisation (see the \"specialised\" column in the <code>ackermann</code> and <code>mapfun</code> benchmarks). Besides, functional programs of order higher than two are rare.</p> <p>The comparisons with OCaml and Haskell were not entirely fair because the new Juvix runtime does not perform garbage collection. The overhead of garbage collection is particularly visible on the <code>mergesort</code> benchmark which creates many intermediate data structures that are quickly discarded. With proper memory management, the running time results on first-order programs for the new Juvix runtime are expected to become slightly worse than for the native OCaml compiler.</p> <p>For simple programs operating on integers which don't require any heap memory allocation (<code>fibonacci</code> and <code>combinations</code> benchmarks), the direct transpilation to C in the current Juvix seems to perform best (behind only C). The reason is that for very simple programs `clang` can better optimise the output of such a direct transpiler. The main problem with the transpilation to C approach is that it cannot scale to reliably work for more complex programs, as evidenced by the segfaults, longer running time and higher memory use on other benchmarks.</p> <p>In addition to the <code>fibonacci</code> and <code>combinations</code> benchmarks, the advantage of direct transpilation for very simple programs is also visible on the <code>fold</code> benchmark where a simple loop over a list dominates the running time. However, this is partly because the compilation of closures in current Juvix is incorrect allowing it to be more efficient.</p>"},{"location":"notes/runtime-benchmark-results/#benchmark-programs","title":"Benchmark programs","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci","title":"fibonacci","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)</p> <p>The Nth Fibonacci number is computed in O(N). Needs only constant stack space and no heap memory. This benchmark tests the efficiency of tail recursion and arithmetic operations.</p>"},{"location":"notes/runtime-benchmark-results/#combinations","title":"combinations","text":"<p>Count combinations of numbers 1 to N having sum N (N = 100)</p> <p>This benchmark tests the efficiency of general recursion. No heap memory needs to be allocated. Uses stack space proportional to N. The running time is exponential in N.</p>"},{"location":"notes/runtime-benchmark-results/#prime","title":"prime","text":"<p>Compute the Nth prime (N = 16384)</p> <p>The Nth prime number is computed via the Eratosthenes sieve. A list of N primes is created. No intermediate lists are discarded (garbage collection not needed). This benchmark tests the efficiency of tail recursion, arithmetic operations, list cell allocation and access.</p>"},{"location":"notes/runtime-benchmark-results/#mergesort","title":"mergesort","text":"<p>Merge sort a list of N integers (N = 2\u2019000\u2019000)</p> <p>At each level of merge sort intermediate lists are created and discarded. The running time for this benchmark largely depends on the efficiency of memory management. Here one may observe the overhead of garbage collection or the memory blow-up if no garbage collection is used.</p>"},{"location":"notes/runtime-benchmark-results/#maybe","title":"maybe","text":"<p>Optionally sum N integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)</p> <p>If a fixed number k is encountered in the tree then the result is <code>Nothing</code>, otherwise it is <code>Just sum</code>. The computation is repeated for values of k from 0 to K. This tests the efficiency of handling optional values and data structure access.</p>"},{"location":"notes/runtime-benchmark-results/#fold","title":"fold","text":"<p>Fold a list of N integers K times (N = 100\u2019000, K = 1000)</p> <p>The sum of N natural numbers is computed via fold<sub>left</sub> (tail-recursive). The computation is repeated K times. The list is created only once, so that allocation time does not dominate. This benchmark tests the efficiency of closure call and list cell access.</p>"},{"location":"notes/runtime-benchmark-results/#cps","title":"cps","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)</p> <p>The function computing the Nth Fibonacci number is written in continuation-passing style, tail-recursively calling a continuation supplied as an argument. This benchmark tests the efficiency of closure call and allocation.</p>"},{"location":"notes/runtime-benchmark-results/#mapfold","title":"mapfold","text":"<p>Map and fold a list of N integers K times (N = 10000, K = 10000)</p> <p>This benchmark tests the efficiency of standard higher-order functions on lists, closure call and memory management. The program allocates O(K) intermediate lists of length N which are quickly discarded.</p>"},{"location":"notes/runtime-benchmark-results/#ackermann","title":"ackermann","text":"<p>Compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)</p> <p>The higher-order Ackermann function definition iterates an iteration of function compositions. Hence, it uses a third-order invocation of an iteration function. This benchmark tests the efficiency of creating and calling second-order closures, and of partial application.</p>"},{"location":"notes/runtime-benchmark-results/#mapfun","title":"mapfun","text":"<p>Successively map K functions to a list of N integers (K = 100, N = 10000)</p> <p>The benchmark stores K second-order closures in a list, maps them successively to a list of K closures, and then successively maps the K closures from the result to a list of N integers. This benchmark tests the efficiency of manipulating closures and storing them in data structures.</p> <p>The benchmark programs can be found in <code>tests/benchmark</code> in the Juvix source directory.</p>"},{"location":"notes/runtime-benchmark-results/#methodology","title":"Methodology","text":"<p>For each program the total running time (elapsed real time) and memory use (maximum resident set size) were measured on an M1 iMac with no significant background activity. Averages of several runs were taken. The variance was negligible, unless indicated otherwise by providing a range.</p>"},{"location":"notes/runtime-benchmark-results/#results","title":"Results","text":""},{"location":"notes/runtime-benchmark-results/#fibonacci_1","title":"fibonacci","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> (N = 100\u2019000\u2019000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.26 0.35 0.35 0.23 13.15 10.03 0.39 0.35 0.94 0.16 0.22 Memory use (MB, max RSS) 1.5 3.8 1.3 8.8 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#combinations_1","title":"combinations","text":"<p>Count all combinations of numbers 1 to N having sum N (N = 1000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 6.67 11.25 3.22 5.1 441.71 5.48 5.48 6.53 41.08 2.69 4.80 Memory use (MB, max RSS) 1.5 3.9 1.3 8.9 22.3 9.6 9.6 1.7 1.9 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#prime_1","title":"prime","text":"<p>Compute the Nth prime (N = 16384)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.52 1.91 segfault 3.09 167.04 3.85 3.85 1.68 14.82 0.12 0.13 Memory use (MB, max RSS) 1.7 4.0 segfault 9.3 24.4 9.8 9.6 2.2 2.2 1.4 4.0"},{"location":"notes/runtime-benchmark-results/#mergesort_1","title":"mergesort","text":"<p>Merge sort a list of N integers (N = 2\u2019000\u2019000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.40 0.31 3.55 1.32 22.45 2.86 2.90 1.95 3.52 0.15 0.15 Memory use (MB, max RSS) 1973.7 720.4 5046.7 2729.8 1728.9 253.6 253.6 172.6 343.1 24.4 26.8"},{"location":"notes/runtime-benchmark-results/#maybe_1","title":"maybe","text":"<p>Optionally sum N non-zero integers from a binary tree K times (N = 2<sup>20</sup>, K = 100)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.64 3.29 1.57 22.75 5.58 0.59 0.30 3.57 0.27 0.50 Memory use (MB, max RSS) 1.6 3.8 2646.1 1320.9 22.4 5560.7 9.7 3.9 4.0 1.3 4.1"},{"location":"notes/runtime-benchmark-results/#fold_1","title":"fold","text":"<p>Fold a list of N integers K times (N = 100\u2019000, K = 1000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.45 0.54 0.35 0.23 15.27 0.58 0.58 0.36 1.80 NA NA Memory use (MB, max RSS) 3.1 4.6 4.4 10.6 43.4 12.7 12.7 5.9 5.9 NA NA"},{"location":"notes/runtime-benchmark-results/#cps_1","title":"cps","text":"<p>Compute the Nth Fibonacci number modulo 2<sup>28</sup> with CPS (N = 100\u2019000\u2019000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.43 0.52 1.56 stack overflow 20.22 10.04 0.39 0.35 1.60 0.16 0.25 Memory use (MB, max RSS) 1.5 3.9 1539.3 stack overflow 21.3 8067.7 9.7 1.7 1.8 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfold_1","title":"mapfold","text":"<p>Map and fold a list of N integers K times (N = 10000, K = 10000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.01 1.59 2.74 1.81 38.24 1.29 2.42 1.43 4.22 NA NA Memory use (MB, max RSS) 2154.5 893.0 3059.1 1542.0 26.4 10.6 10.7 7.5 10-20 NA NA"},{"location":"notes/runtime-benchmark-results/#ackermann_1","title":"ackermann","text":"<p>Compute Ack(3, N) with the higher-order Ackermann function definition (N = 11)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 0.92 1.21 0.30 0.65 segfault runtime error 11.71 0.87 0.47 0.54 1.35 0.00 0.14 Memory use (MB, max RSS) 2.6 4.1 2.3 3.9 segfault runtime error 23.3 13.6 9.6 2.0 3.6 1.3 4.0"},{"location":"notes/runtime-benchmark-results/#mapfun_1","title":"mapfun","text":"<p>Successively map K functions to a list of N integers (K = 100, N = 10000)</p> New Juvix runtime (native) New Juvix runtime (wasm32, wasmer) New Juvix runtime (specialised, native) New Juvix runtime (specialised, wasm32, wasmer) Current Juvix (native) Current Juvix (wasm32, wasmer) JuvixCore evaluator Haskell (native, ghc -O2) Haskell (native, ghc -XStrict -O2) OCaml (native, ocamlopt -O2) OCaml (bytecode) C (native, clang -O3) C (wasm32, clang -Os, wasmer) Time (seconds, real) 1.27 1.04 0.39 0.46 segfault runtime error 4.18 1.85 0.95 0.19 0.68 NA NA Memory use (MB, max RSS) 3209.8 1229.7 21.8 13.2 segfault runtime error 33.0 13.6 11.6 5.3 7.9 NA NA"},{"location":"notes/runtime-benchmark-results/#comments","title":"Comments","text":"<p>\"New Juvix runtime\" denotes C programs written using the primitives of the new Juvix runtime. These programs were \"manually\" compiled from the corresponding Juvix/JuvixCore programs, according to the new Juvix compilation concept. They correspond closely to the code that will be generated by the basic version of the new compilation process, without any high-level optimisations (inlining, specialisation, fusion, constant folding) but with basic low-level memory representation optimisations (unboxing, untagging, etc). This version of the new compilation process should be finished with the 0.4 milestone.</p> <p>The \"specialised\" column for \"New Juvix runtime\" denotes a version of the corresponding \"New Juvix runtime\" benchmark program for which specialisation of higher-order functions was manually performed (to simulate the effects of the high-level specialisation optimisation).</p> <p>\"Current Juvix\" denotes Juvix programs compiled with the current compilation process via a \"direct\" translation to C. For a fair comparison, all number operations were implemented using native binary C integers (exposed via <code>foreign</code> and <code>compile</code> blocks) without overflow check, instead of using the unary Nat from the standard library. For Haskell, we use the fixed-precision Int instead of the arbitrary-precision Integer.</p> <p>For the simplest benchmark programs without heap memory allocation (e.g. <code>fibonacci</code>, <code>combinations</code>), the performance of \"Current Juvix\" is comparable to or better than that of \"New Juvix runtime\". This is because <code>clang</code> managed to eliminate (tail) recursion and optimise the code to essentially the same or better thing. The main problem with the current \"direct\" transpilation to C approach is that it cannot scale to reliably work for more complex programs. By \"more complex\" I mean larger program size, more functions, more complex patterns of recursion and/or the use of more functional programming features (including functional data structures). I don't mean higher computational complexity or more resource use.</p> <p>The segfaults and runtime errors for \"Current Juvix\" are consequences of incorrectly generated code (current compilation of partial application is not entirely correct) or stack overflows (when <code>clang</code> didn't figure out how to eliminate tail recursion).</p> <p>The comparison with \"Current Juvix\" is not entirely fair for benchmarks that test the manipulation and calling of closures (e.g. <code>fold</code>). Current Juvix achieves good performance (when it doesn't segfault) at the expense of correctness: partial application is not compiled correctly and fixing this would require a fundamental change in closure representation.</p> <p>The comparison with Haskell and OCaml compilers is not entirely fair, because the new Juvix runtime does not perform garbage collection. With the GC overhead, I would expect the Juvix runtime results for native compilation of first-order programs to become a bit worse than the native OCaml versions. The GC overhead is particularly noticeable for the <code>mergesort</code> benchmark which creates many large intermediate lists. The memory usage of the Juvix runtime is much higher on this benchmark than the memory usage of OCaml or Haskell versions. The relatively small time difference between the OCaml native and bytecode versions of <code>mergesort</code> also indicates that GC accounts for a significant part of the running time.</p> <p>Another small overhead will be introduced by bounds checking for integer operations. Currently, the new Juvix runtime operates on unboxed 31-bit (or 63-bit) integers without checking for integer overflow.</p> <p>If we decide to default to transparent arbitrary-precision integers, then another small overhead will be introduced by the need to check the integer representation with each arithmetic operation.</p> <p>Admittedly, the programs were deliberately written in a way to make high-level optimisations unnecessary, except specialisation for higher-order functions (mostly in <code>ackermann</code> and <code>mapfun</code>). This also explains the good performance of the OCaml native compiler which doesn't do much high-level optimisation.</p> <p>In the \"Current Juvix\" and OCaml version of <code>mergesort</code>, to avoid stack overflow the <code>merge</code> function was written tail-recursively with accumulator reversal at the end. This is not necessary for the new Juvix runtime, because the stack is dynamically extended when needed.</p> <p>As evidenced by the <code>combinations</code> benchmark, for non-tail-recursive direct calls our code performs worse than the code which uses the C / WebAssembly stack and function call mechanisms. However, in general it is impossible to directly use the C / WebAssembly stack and call mechanisms for a purely functional language. Since we dynamically allocate the stack segments when needed, stack overflow is impossible. This is convenient in an eager functional language. Otherwise, one needs to rewrite all functions operating on large data to use tail recursion. We pay for this convenience with a small overhead, which is the main reason for poorer performance on <code>combinations</code> where stack manipulation cost dominates.</p> <p>Haskell's laziness seems to introduce more overhead than I expected. This would explain the comparatively better performance of the native OCaml compiler. The problem is particularly stark when Haskell's strictness analysis fails for some reason, as in the <code>fibonacci</code> benchmark. The second \"Haskell\" column with the \"-XStrict\" flag for GHC indicates the version of the benchmark compiled with strictness as the default.</p> <p>The C versions of the programs were written to take advantage of C's imperative features, e.g., using arrays instead of lists, loops instead of recursion. No C versions are provided for some benchmarks designed to test specifically functional language features.</p> <p>With the new Juvix runtime, the 32-bit WebAssembly version of <code>mergesort</code> is faster than the 64-bit native version because it needs roughly half as much memory (the word size is 4 bytes instead of 8). The difference is even starker between the WebAssembly and native versions of <code>mergesort</code> for \"Current Juvix\".</p> <p>There seems to be a memory leak in the JuvixCore evaluator. This is what happens too often when one uses a lazy language.</p> <p>Haskell also leaks memory in the Fibonacci benchmark, despite it being a simple tail-recursive program. It seems strictness analysis didn't work.</p>"},{"location":"reference/benchmarks/","title":"Benchmarks","text":""},{"location":"reference/examples/","title":"Examples of programs written in Juvix","text":"<p>The following links are clickable versions of their corresponding Juvix program. The sources can be found in the examples/milestone directory in the Juvix repository. The webpages can be generated by running the following command:</p> <pre><code>juvix html --recursive FileName.juvix\n</code></pre> <ul> <li>HelloWorld.juvix</li> <li>Fibonacci.juvix</li> <li>Hanoi.juvix</li> <li>PascalsTriangle.juvix</li> <li>Collatz.juvix</li> <li>TicTacToe.juvix</li> </ul>"},{"location":"reference/judoc/","title":"Native Documentation Tool","text":"<p>Inspired by Haddock and Agda, Juvix has its own documentation tool called Judoc.</p> <p>Judoc is used to document parts of your code. You can attach Judoc blocks to the following entities:</p> <ul> <li>A module.</li> <li>A type definition.</li> <li>A constructor definition.</li> <li>A type signature of a function.</li> <li>An axiom definition.</li> </ul> <p>In order to attach documentation to any of these entities, write blocks of documentation before them:</p> <ol> <li>For modules:</li> </ol> <pre><code>--- This module is cool\nmodule Cool;\n..\n</code></pre> <ul> <li>For type definitions:</li> </ul> <pre><code>--- Unary representation of natural numbers\ntype Nat : Type :=\n  | --- Nullary constructor representing number 0\n    zero : Nat\n  | --- Unary constructor representing the successor of a natural number\n    suc : Nat -&gt; Nat;\n</code></pre> <ul> <li>For type signatures (and likewise for axioms):</li> </ul> <pre><code>--- The polymorphic identity function\nid : {A : Type} -&gt; A -&gt; A;\n</code></pre> <p>Next we define the syntax of Judoc blocks.</p>"},{"location":"reference/judoc/#block","title":"Block","text":"<p>A block can be one of these:</p> <ol> <li>A paragraph.</li> <li>An example.</li> </ol> <p>Blocks are separated by a line with only <code>---</code>. For instance, this is a sequence of two blocks:</p> <pre><code>--- First block\n---\n--- Second block\n</code></pre> <p>Note that the following is a single block since it lacks the <code>---</code> separator:</p> <pre><code>--- First block\n\n--- Still first block\n</code></pre> <p>Alternatively, you can use block Judoc comments for that:</p> <pre><code>{-- First block\n\nSecond block\n---}\n</code></pre>"},{"location":"reference/judoc/#paragraph","title":"Paragraph","text":"<p>A paragraph is a non-empty sequence of lines.</p> <p>For instance, the following is a paragraph with two lines:</p> <pre><code>--- First line\n--- Second line\n</code></pre> <p>Note that a rendered paragraph will have have no line breaks. If you want to have line breaks, you will need to split the paragraph. Hence, the paragraph above will be rendered as</p> <pre><code>First line Second line\n</code></pre>"},{"location":"reference/judoc/#line","title":"Line","text":"<p>A line starts with <code>---</code> and is followed by a non-empty sequence of atoms.</p> <p>For instance, the following is a valid line:</p> <pre><code>--- A ;Pair Int Bool; contains an ;Int; and a ;Bool;\n</code></pre>"},{"location":"reference/judoc/#atom","title":"Atom","text":"<p>An atom is either:</p> <ol> <li>A string of text (including spaces but not line breaks).</li> <li>An inline Juvix expression surrounded by <code>;</code>.</li> </ol> <p>For instance, the following are valid atoms:</p> <ol> <li><code>I am some text.</code></li> <li><code>;Pair Int Bool;</code></li> </ol>"},{"location":"reference/judoc/#example","title":"Example","text":"<pre><code>--- &gt;&gt;&gt; someExpression ;\n</code></pre> <p>The <code>someExpression</code> can span multiple lines and it must be ended with a <code>;</code>. For instance:</p> <pre><code>--- &gt;&gt;&gt; 1\n        + 2\n        + 3;\n</code></pre>"},{"location":"reference/stdlib/","title":"Standard library","text":"<p>The Juvix standard library contains common functions that can be used in Juvix programs.</p>"},{"location":"reference/language/","title":"About","text":"<p>Juvix is designed with a focus on safety. The Juvix compiler runs several static analyses which guarantee the absence of runtime errors. Analyses performed include termination and type checking. As a result, functional programs, especially validity predicates, can be written with greater confidence in their correctness.</p> <p>Some language features in Juvix include:</p> <ul> <li>Haskell/Agda-like syntax with support for Unicode</li> <li>Type inference</li> <li>Parametric polymorphism</li> <li>User defined inductive data types</li> <li>Higher-order functions</li> <li>Referential transparency</li> </ul> <p>The Juvix module system allows developers to break down their programs into smaller, reusable modules that can be compiled separately and combined to create larger programs. These modules can be used to build libraries, which can then be documented using Juvix's built-in documentation generation tool, see for example, the Juvix standard library's website.</p>","boost":4},{"location":"reference/language/#related-internal-reports","title":"Related internal reports","text":"<p>An ongoing effort to specify the Juvix language and internal representations along its semantics is being carried out in the form of internal reports. These reports are written for our own internal use and are not intended to be read by the public, at least for now. However, we are making them available here for the sake of transparency.</p> Title Doi/url Date Juvix to VampIR Pipeline 10.5281/zenodo.8268823 Aug 14, 2023 The Core language of Juvix 10.5281/zenodo.8297159 Aug 29, 2023 Geb Pipeline 10.5281/zenodo.8262747 Aug 21, 2023 Rethinking VampIR 10.5281/zenodo.8262815 Aug 29, 2023","boost":4},{"location":"reference/language/aliases/","title":"Aliases in Juvix","text":"<p>Aliases in Juvix are a powerful feature that allows developers to create shorthand or substitute names for existing ones. This can greatly enhance readability and maintainability of the code.</p>","boost":3},{"location":"reference/language/aliases/#syntax","title":"Syntax","text":"<p>The syntax for creating an alias is as follows:</p> <pre><code>syntax alias &lt;newName&gt; := &lt;originalName&gt;;\n</code></pre> <p>Once declared, these aliases can be used interchangeably with the original name. They can be employed in various contexts such as pattern matching, qualification, and module opening.</p>","boost":3},{"location":"reference/language/aliases/#application-of-aliases","title":"Application of Aliases","text":"<p>One of the key features of aliases in Juvix is their ability to be forward referenced. This means you can use an alias before it has been officially declared in your code. This can be particularly useful when you want to use a more intuitive or shorter name for something that is defined later in the code.</p> <p>For instance, consider the following example where we define the alias <code>Boolean</code> for the <code>Bool</code> type. We also alias the named constructors <code>true</code> and <code>false</code> for the Boolean type as <code>\u22a4</code> (top) and <code>\u22a5</code> (bottom) respectively.</p> <pre><code><pre>syntax alias Boolean := Bool;syntax alias \u22a5 := false;syntax alias \u22a4 := true;type Bool :=  | false  | true;not : Boolean -&gt; Boolean  | \u22a5 := \u22a4  | \u22a4 := \u22a5;</pre></code></pre> <p>In addition to global scope, aliases can also be used in local definitions. The following <code>let</code> expression demonstrates this usage.</p> <pre><code><pre>not2 (b : Boolean) : Boolean :=  let    syntax alias yes := \u22a4;    syntax alias no := \u22a5;  in case b of {       | no := yes       | yes := no     };</pre></code></pre> <p>Just like any other name, aliases can be exported from a module to be used elsewhere. Here's how to do it:</p> <pre><code><pre>module ExportAlias;  syntax alias Binary := Bool;  syntax alias one := \u22a4;  syntax alias zero := \u22a5;end;open ExportAlias;syntax operator || logical;|| : Binary -&gt; Binary -&gt; Binary  | zero b := b  | one _ := one;</pre></code></pre> <p>The versatility of aliases extends beyond types to terms, including functions (operators). For example, the binary <code>||</code> function can be aliased as <code>or</code> as shown below:</p> <pre><code><pre>syntax alias or := ||;newor (a b c : Binary) : Binary := (a or b) or c;</pre></code></pre>","boost":3},{"location":"reference/language/axioms/","title":"Axiom","text":"<p>Axioms or postulates are used to introduce new terms or types without defining them. This is done using the <code>axiom</code> keyword.</p> <pre><code>axiom &lt;name&gt; : &lt;type&gt;;\n</code></pre>","boost":3},{"location":"reference/language/axioms/#usage","title":"Usage","text":"<p>Consider a scenario where you want to create a program that assumes A as a type, and there exists a term x that belongs to this type A. The syntax for such a program would be as follows:</p> <pre><code><pre>axiom A : Type;axiom x : A;</pre></code></pre>","boost":3},{"location":"reference/language/axioms/#important-considerations","title":"Important Considerations","text":"<p>It is crucial to understand that terms introduced by the <code>axiom</code> keyword do not contain any computational content. This implies that they are merely abstract concepts without any inherent operational value.</p> <p>Consequently, programs that include axioms (which are not marked as builtins) cannot be compiled to most targets.</p>","boost":3},{"location":"reference/language/builtins/","title":"Built-ins","text":"<p>Juvix has support for the built-in natural type and a few functions that are compiled to efficient primitives.</p>","boost":3},{"location":"reference/language/builtins/#built-in-inductive-definitions","title":"Built-in inductive definitions","text":"<pre><code><pre>builtin nattype Nat :=  | zero : Nat  | suc : Nat \u2192 Nat;</pre></code></pre>","boost":3},{"location":"reference/language/builtins/#builtin-function-definitions","title":"Builtin function definitions","text":"<pre><code><pre>syntax operator + additive;builtin nat-plus+ : Nat \u2192 Nat \u2192 Nat  | zero b := b  | (suc a) b := suc (a + b);</pre></code></pre>","boost":3},{"location":"reference/language/builtins/#builtin-axiom-definitions","title":"Builtin axiom definitions","text":"<pre><code><pre>module example-print-nat;  builtin IO  axiom IO : Type;  builtin nat-print  axiom printNat : Nat \u2192 IO;end;</pre></code></pre>","boost":3},{"location":"reference/language/comments/","title":"Commenting in Juvix","text":"<p>Comments provides a way to document code for better understanding and readability for users and future developers. In Juvix, the commenting syntax follows that of <code>Haskell</code>.</p>","boost":3},{"location":"reference/language/comments/#syntax-of-comments","title":"Syntax of Comments","text":"<p>There are several types of comments you can use in Juvix. These include inline comments, region comments, Judoc inline comments, and Judoc block comments.</p>","boost":3},{"location":"reference/language/comments/#inline-comment","title":"Inline Comment","text":"<p>Inline comments start with two hyphens (<code>--</code>). They extend to the end of the line.</p> <pre><code>-- This is an inline comment!\n</code></pre>","boost":3},{"location":"reference/language/comments/#region-comment","title":"Region Comment","text":"<p>Region comments are multi-line comments. They start with <code>{ -</code> and end with <code>- }</code>.</p> <pre><code>{-\n    This is a region comment spanning multiple lines!\n-}\n</code></pre>","boost":3},{"location":"reference/language/comments/#judoc-inline-comments","title":"Judoc Inline Comments","text":"<p>Judoc inline comments are used specifically to document functions and types. They begin with three hyphens (<code>---</code>). For more information on using Judoc comments, refer to the Judoc documentation.</p> <pre><code>--- This is a Judoc inline comment used for documenting functions or types!\n</code></pre>","boost":3},{"location":"reference/language/comments/#judoc-block-comments","title":"Judoc Block Comments","text":"<p>Similar to region comments, Judoc block comments span multiple lines. They start with <code>{ --</code> and end with <code>-- }</code>. For more information on using Judoc comments, refer to the Judoc documentation.</p> <pre><code>{--\n    This is a Judoc block comment used for documenting larger code blocks!\n--}\n</code></pre>","boost":3},{"location":"reference/language/control/","title":"Control Structures","text":"<p>Juvix utilizes control structures such as case expressions and lazy built-ins to manage the flow of execution. The following sections provide an in-depth understanding of these features.</p>","boost":3},{"location":"reference/language/control/#case-expressions","title":"Case Expressions","text":"<p>A case expression in Juvix is a powerful tool that enables the execution of different actions based on the pattern of the input expression. It provides a way to match complex patterns and perform corresponding operations, thereby enhancing code readability and maintainability.</p>","boost":3},{"location":"reference/language/control/#syntax","title":"Syntax","text":"<p>A case expression in Juvix is defined as follows:</p> <pre><code>case &lt;expression&gt; of {\n  | &lt;pattern1&gt; := &lt;branch1&gt;\n  ..\n  | &lt;patternN&gt; := &lt;branchN&gt;\n}\n</code></pre> <p>In this syntax: - <code>&lt;expression&gt;</code> is the value against which you want to match patterns. - <code>&lt;pattern1&gt;</code> through <code>&lt;patternN&gt;</code> are the patterns you're checking against the   given expression. - <code>&lt;branch1&gt;</code> through <code>&lt;branchN&gt;</code> are the respective actions or results that   will be returned when their corresponding patterns match the input expression.</p>","boost":3},{"location":"reference/language/control/#example","title":"Example","text":"<p>Consider the following case expression in Juvix:</p> <pre><code>Stdlib.Prelude&gt; case 2 of { | zero := 0 | suc x := x }\n</code></pre> <p>In this example, the input expression is <code>2</code>. The case expression checks this input against each pattern (<code>zero</code> and <code>suc x</code>) in order. Since <code>2</code> does not match the pattern <code>zero</code>, it moves on to the next pattern <code>suc x</code>. This pattern matches the input <code>2</code>, where <code>x</code> equals <code>1</code>. Therefore, the corresponding branch <code>x</code> is executed, and <code>1</code> is returned.</p> <p>Thus, when evaluated, this expression returns <code>1</code>.</p> <p>By using case expressions, you can write more expressive and flexible code in Juvix. They allow for intricate pattern matching and branching logic that can simplify complex programming tasks.</p>","boost":3},{"location":"reference/language/control/#lazy-built-in-functions","title":"Lazy Built-in Functions","text":"<p>Juvix provides several lazily evaluated built-in functions in its standard library. These functions do not evaluate their arguments until absolutely necessary, providing efficiency in computations. However, keep in mind that these functions must be fully applied to work correctly.</p> <p>Here are some examples of these functions:</p> <ul> <li> <p><code>if condition branch1 branch2</code>: This function first evaluates the <code>condition</code>.   If the condition is true, it returns <code>branch1</code>; otherwise, it returns   <code>branch2</code>.</p> </li> <li> <p><code>a || b</code>: This is a lazy disjunction operator. It first evaluates <code>a</code>. If <code>a</code>   is true, it returns true; otherwise, it evaluates and returns <code>b</code>.</p> </li> <li> <p><code>a &amp;&amp; b</code>: This is a lazy conjunction operator. It first evaluates <code>a</code>. If <code>a</code>   is false, it returns false; otherwise, it evaluates and returns <code>b</code>.</p> </li> <li> <p><code>a &gt;&gt; b</code>: This function sequences two IO actions and is lazy in the second   argument.</p> </li> </ul>","boost":3},{"location":"reference/language/datatypes/","title":"Defining Data Types in Juvix","text":"<p>A crucial aspect of any programming language is the ability to define custom data types. In Juvix, these are known as inductive types. An inductive type is a type with elements constructed from a finite set of constructors.</p> <p>Consider as a first example where we define a data type <code>Bool</code> with two constructors, <code>true</code> and <code>false</code>.</p> <pre><code><pre>type Bool :=  | true : Bool  | false : Bool;</pre></code></pre>","boost":3},{"location":"reference/language/datatypes/#syntax-of-data-type-declaration","title":"Syntax of Data Type Declaration","text":"","boost":3},{"location":"reference/language/datatypes/#general-declaration","title":"General Declaration","text":"<p>The declaration of a data type in Juvix consists of the keyword <code>type</code>, followed by a unique name, optional type parameters, and constructors.</p> <pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n    | &lt;constructor1&gt; : &lt;type1&gt;\n    | ...\n    | &lt;constructorn&gt; : &lt;typen&gt;;\n</code></pre> <p>In this syntax:</p> <ul> <li><code>&lt;name&gt;</code> represents a unique name for the declared data type.</li> <li><code>&lt;type-parameters&gt;</code> denote optional type parameters in the form <code>A B C ...</code> or   with typing information <code>(A : Type)</code>. These parameters define the return type   of the constructors, i.e., <code>&lt;name&gt; &lt;type-parameters&gt;</code>.</li> <li><code>&lt;constructor1&gt;</code> through <code>&lt;constructorn&gt;</code> are the constructors of the data   type. Each constructor has a unique name and a type, which can be the type of   the declared data type or a function type from the types of the arguments to   the type of the declared data type.</li> </ul> <p>While there are variations in the syntax for declaring a data type (see the ADT syntax and record syntax), the most general syntax is the one outlined above.</p> <p>Note</p> <p>A data type declaration implicitly declares a module with the same name as the data type, containing the symbols of the constructors, and the type of the data type itself. One can open this module to access these symbols or hide it to prevent access to them.</p>","boost":3},{"location":"reference/language/datatypes/#example-of-data-types","title":"Example of data types","text":"<p>The <code>Unit</code> type, the simplest data type, has a single constructor named <code>unit</code>.</p> <pre><code><pre>type Unit := unit : Unit;</pre></code></pre> <p>We then declare the <code>Nat</code> type, representing unary natural numbers. It introduces two constructors: <code>zero</code> and <code>suc</code>. For instance, <code>suc zero</code> represents one, while <code>suc (suc zero)</code> represents two.</p> <pre><code><pre>type Nat :=  | zero : Nat  | suc : Nat -&gt; Nat;</pre></code></pre> <p>These constructors function as regular functions or patterns in pattern matching when defining functions. Here is an example of a function adding two natural numbers:</p> <pre><code><pre>syntax operator + additive;+ : Nat -&gt; Nat -&gt; Nat  | zero b := b  | (suc a) b := suc (a + b);</pre></code></pre>","boost":3},{"location":"reference/language/datatypes/#adt-syntax","title":"ADT syntax","text":"<p>As an alternative to the above syntax, we can use a more familiar and compact syntax for declaring data types. This syntax is inspired by ADT syntax in Haskell.</p> <pre><code>type &lt;name&gt; &lt;type-parameters&gt; :=\n  | &lt;constructor1&gt; &lt;arg1-1&gt; ... &lt;arg1-n&gt;\n  | ...\n  | &lt;constructorN&gt; &lt;argn-1&gt; ... &lt;argn-n&gt;;\n</code></pre> <p>Different from the previous presentation, here the constructors do not have typing information.</p> <p>If a type constructor as above has no arguments, then its type is the type of the data type being declared. In the case the type constructor has arguments, then its type is the function type from the types of the arguments to the type of the data type being declared.</p> <p>For example, the <code>Nat</code> type can be declared as follows:</p> <pre><code><pre>module Nat-ADT;  type Nat :=    | Z    | S Nat;end;</pre></code></pre> <p>Another example is the <code>List</code> type, which is polymorphic in the type of its elements.</p> <pre><code><pre>module List-ADT;  type List A :=    | Nil    | Cons A (List A);end;</pre></code></pre>","boost":3},{"location":"reference/language/datatypes/#polymorphic-data-type","title":"Polymorphic data type","text":"<p>A data type can possess type parameters. When a data type has a type parameter <code>A</code>, it is referred to as polymorphic in <code>A</code>.</p> <p>A classic example of this concept is the <code>List</code> type, which is polymorphic in the type of its list elements.</p> <pre><code><pre>syntax operator :: cons;type List (A : Type) :=  | nil : List A  | :: : A -&gt; List A -&gt; List A;</pre></code></pre> <p>The following function determines whether an element is in a list or not.</p> <pre><code><pre>module membership;  import Stdlib.Data.Bool open using {Bool; false; ||};    elem {A} (eq : A -&gt; A -&gt; Bool) (s : A) : List A -&gt; Bool    | nil := false    | (x :: xs) := eq s x || elem eq s xs;end;</pre></code></pre> <p>For more examples of inductive types and how to use them, see the Juvix standard library.</p>","boost":3},{"location":"reference/language/fixity/","title":"Fixities","text":"<p>Fixities in Juvix refers to the precedence and associativity of operators. A fixity declaration is defined using the <code>syntax</code> keyword followed by <code>fixity</code>. It specifies how an operator should be parsed in relation to other operators.</p>","boost":3},{"location":"reference/language/fixity/#syntax-of-fixity-declaration","title":"Syntax of Fixity Declaration","text":"<p>The syntax for a fixity declaration varies based on the operator's arity, associativity, and precedence.</p>","boost":3},{"location":"reference/language/fixity/#arity-declaration","title":"Arity Declaration","text":"<p>For an operator with no specified precedence or associativity, the arity can be declared as follows:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt;;\n</code></pre> <p>In this syntax,</p> <ul> <li><code>&lt;name&gt;</code> represents the operator name, and</li> <li><code>&lt;arity&gt;</code> can either be <code>none</code>, <code>unary</code>, or <code>binary</code>.</li> </ul> <p>This declaration is equivalent to:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {};\n</code></pre>","boost":3},{"location":"reference/language/fixity/#associativity-declaration","title":"Associativity Declaration","text":"<p>For an operator with no specified precedence, its associativity can be declared as:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; { assoc := &lt;associativity&gt; };\n</code></pre> <p>Here, <code>&lt;associativity&gt;</code> can either be <code>left</code>, <code>right</code>, or <code>none</code>.</p>","boost":3},{"location":"reference/language/fixity/#precedence-declaration","title":"Precedence Declaration","text":"<p>For an operator with no specified associativity, its precedence can be declared relative to other operators.</p> <ul> <li>If it has equal precedence to another operator:</li> </ul> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; { same := otherOperatorName };\n</code></pre> <ul> <li>If it has higher precedence than other operators:</li> </ul> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {\n    above := [otherOperatorName1;...; otherOperatorNameN] };\n</code></pre> <ul> <li>If it has lower precedence than other operators:</li> </ul> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {\n    below := [otherOperatorName1;...; otherOperatorNameN] };\n</code></pre>","boost":3},{"location":"reference/language/fixity/#associativity-and-precedence-declaration","title":"Associativity and Precedence Declaration","text":"<p>For an operator with both associativity and precedence:</p> <pre><code>syntax fixity &lt;name&gt; := &lt;arity&gt; {\n    assoc := &lt;associativity&gt;;\n    above := [otherOperatorName1;...; otherOperatorNameN]\n    };\n</code></pre>","boost":3},{"location":"reference/language/fixity/#operator-alias-fixity","title":"Operator Alias Fixity","text":"<p>In Juvix, when an operator is aliased, the new alias automatically inherits the fixity of the original operator. This behavior ensures consistency and predictability when using aliases in place of their corresponding operators.</p> <p>Consider a scenario where the <code>or</code> operator is an alias of the <code>||</code> operator. The <code>or</code> operator will inherit the fixity of the <code>||</code> operator by default.</p> <pre><code><pre>module fixityInherit;  syntax alias or := ||;    newor (a b c : Bool) : Bool := (a or b) or c;end;</pre></code></pre> <p>However, if you want to override this behavior, you can declare the alias with <code>none</code> as its fixity. Make sure to import <code>Stdlib.Data.Fixity</code>.</p> <pre><code><pre>module fixityNone;  import Stdlib.Data.Fixity open;  syntax operator or none;  syntax alias or := ||;    or3 (a b c : Bool) : Bool := or (or a b) c;end;</pre></code></pre>","boost":3},{"location":"reference/language/fixity/#examples-of-fixity-declarations","title":"Examples of Fixity Declarations","text":"<p>Here are some examples of common fixity declarations for operators in Juvix's standard library.</p> <pre><code><pre>module examples-from-stdlib;  syntax fixity rapp := binary {assoc := right};  syntax fixity lapp := binary {assoc := left; same := rapp};  syntax fixity seq := binary {assoc := left; above := [lapp]};  syntax fixity functor := binary {assoc := right};  syntax fixity logical := binary {assoc := right; above := [seq]};  syntax fixity comparison := binary {assoc := none; above := [logical]};  syntax fixity pair := binary {assoc := right};  syntax fixity cons := binary {assoc := right; above := [pair]};  syntax fixity step := binary {assoc := right};  syntax fixity range := binary {assoc := right; above := [step]};  syntax fixity additive := binary {assoc := left; above := [comparison; range; cons]};  syntax fixity multiplicative := binary {assoc := left; above := [additive]};  syntax fixity composition := binary {assoc := right; above := [multiplicative]};end;</pre></code></pre>","boost":3},{"location":"reference/language/functions/","title":"Function Declarations in Juvix","text":"<p>In Juvix, a function declaration is composed of a type signature and the body of the function. The type signature specifies the types of the arguments and the return type of the function. Constants are considered as functions with no arguments. The body of a function can either be a single expression or a set of function clauses when pattern matching is employed.</p>","boost":3},{"location":"reference/language/functions/#syntax-of-function-declarations","title":"Syntax of Function Declarations","text":"<p>The syntax for a function declaration has the following form:</p> <pre><code>&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt; := &lt;body&gt;;\n</code></pre> <p>Function declarations in Juvix can have variations related to named and implicit arguments.</p>","boost":3},{"location":"reference/language/functions/#named-arguments","title":"Named Arguments","text":"<p>A named argument is an argument whose name is specified in the function type signature before the colon. This name is then available within the scope of the function's body.</p> <pre><code>&lt;funName&gt; (&lt;argName&gt; : &lt;argType&gt;) : &lt;returnType&gt; := &lt;body&gt;;\n</code></pre> <p>For example, consider the function <code>multiplyByTwo</code> which takes a <code>Nat</code> (natural number) and returns a <code>Nat</code>. The argument is named <code>n</code> and is used in the function's body to return <code>2 * n</code>.</p> <pre><code><pre>module example-multiply-by-two;  import Stdlib.Data.Nat open using {Nat; *};    multiplyByTwo (n : Nat) : Nat := 2 * n;end;</pre></code></pre>","boost":3},{"location":"reference/language/functions/#default-values","title":"Default Values","text":"<p>We can assign default values to function arguments. This feature allows a function to operate without explicit argument values by using the provided defaults.</p> <p>To specify a default value for an argument, use the <code>:=</code> operator followed by the desired value. In the following example, <code>x</code> and <code>y</code> are given default values of <code>0</code> and <code>1</code>, respectively:</p> <pre><code><pre>module default-values;  import Stdlib.Prelude open;    f {x : Nat := 0} {y : Nat := 1} : Nat := x + y;end;</pre></code></pre> <p>When calling this function without providing values for <code>x</code> and <code>y</code>, such as <code>f</code>, the function will use the default values and return <code>1</code>.</p> <p>Note</p> <p>Here are some key points to remember about using default argument values in Juvix:</p> <ol> <li> <p>No Referencing Previous Arguments: Default values cannot refer to   previous arguments. Therefore, the following code would result in a scope   error:</p> <pre><code>f {n : Nat := 0} {m : Nat := n + 1} ....\n</code></pre> </li> <li> <p>Function-Specific Feature: Only functions can have default values. Other   constructs or types do not support this feature.</p> </li> <li> <p>Left-Hand Side Limitation: Only arguments on the left-hand side (LHS) of   the <code>:</code> can have default values. The following syntax is invalid:</p> <pre><code>f : {n : Nat := 0} := ...\n</code></pre> </li> </ol>","boost":3},{"location":"reference/language/functions/#pattern-matching-in-function-declarations","title":"Pattern Matching in Function Declarations","text":"<p>A function may consist of one or more function clauses instead of a single expression. This is applicable when the function's argument is a data type and we want to pattern match on that argument.</p> <p>The syntax for a function declaration using pattern matching is as follows:</p> <pre><code>&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat1&gt; := &lt;body1&gt;\n    | ...\n    | &lt;patN&gt; := &lt;bodyN&gt;;\n</code></pre> <p>Here <code>&lt;pat1&gt;</code> through <code>&lt;patN&gt;</code> are patterns that are matched against the argument of the function. The corresponding body is evaluated when the pattern matches.</p> <p>For instance, consider the following function with two clauses:</p> <pre><code><pre>module example-negate-boolean;  import Stdlib.Data.Bool open;    neg : Bool -&gt; Bool    | true := false    | false := true;end;</pre></code></pre> <p>When <code>neg</code> is called with <code>true</code>, the first clause is used and the function returns <code>false</code>. Similarly, when <code>neg</code> is called with <code>false</code>, the second clause is used and the function returns <code>true</code>.</p> <p>Note that one may pattern match multiple arguments at once. The syntax in case of two arguments is as follows and can be extended to more arguments.</p> <pre><code>&lt;funName&gt; : &lt;argType1&gt; -&gt; &lt;argType2&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat-1-1&gt; &lt;pat-1-2&gt; := &lt;body1&gt;\n    | ...\n    | &lt;pat-n-1&gt; &lt;pat-n-2&gt; := &lt;bodyN&gt;;\n</code></pre> <p>Note</p> <p>Initial function arguments that match variables or wildcards in all clauses can be moved to the left of the colon in the function definition. For example,</p> <p><pre><code><pre>module move-to-left;  import Stdlib.Data.Nat open;    add (n : Nat) : Nat -&gt; Nat    | zero := n    | (suc m) := suc (add n m);end;</pre></code></pre></p> <p>is equivalent to</p> <p><pre><code><pre>module example-add;  import Stdlib.Data.Nat open;    add : Nat -&gt; Nat -&gt; Nat    | n zero := n    | n (suc m) := suc (add n m);end;</pre></code></pre></p> <p>If there is only one clause without any patterns, the pipe <code>|</code> must be omitted as we see earlier.</p> <p><pre><code><pre>module short-definitons;  import Stdlib.Data.Nat open;    multiplyByTwo (n : Nat) : Nat := n;end;</pre></code></pre></p>","boost":3},{"location":"reference/language/functions/#mutually-recursive-functions","title":"Mutually Recursive Functions","text":"<p>Functions in Juvix can depend on each other recursively. In the following example, a function checks if a number is <code>even</code> by calling another function that verifies if the number is <code>odd</code>.</p> <pre><code><pre>module mutually-recursive;  import Stdlib.Data.Nat open;  import Stdlib.Data.Bool open;  import Stdlib.Prelude open;    odd : Nat -&gt; Bool    | zero := false    | (suc n) := even n;    even : Nat -&gt; Bool    | zero := true    | (suc n) := odd n;end;</pre></code></pre> <p>Identifiers don't need to be defined before they are used, allowing for mutually recursive functions/types without any special syntax. However, exceptions exist. A symbol <code>f</code> cannot be forward-referenced in a statement <code>s</code> if a local module, import statement, or open statement exists between <code>s</code> and the definition of <code>f</code>.</p>","boost":3},{"location":"reference/language/functions/#anonymous-functions-lambdas","title":"Anonymous Functions (Lambdas)","text":"<p>Anonymous functions or lambdas can be defined using the following syntax:</p>","boost":3},{"location":"reference/language/functions/#syntax-of-lambda-declarations","title":"Syntax of <code>lambda</code> declarations","text":"<pre><code>\\{ | pat1 .. patN_1 := clause1\n   | ..\n   | pat1 .. patN_M := clauseM }\n</code></pre> <p>The initial pipe <code>|</code> is optional. You can use either <code>\\</code> or the Unicode alternative <code>\u03bb</code> to denote an anonymous function.</p> <p>An anonymous function lists all clauses of a function without naming it. Any function declaration can be converted to use anonymous functions:</p> <pre><code><pre>module anonymous-functions;  import Stdlib.Prelude open;    odd : Nat -&gt; Bool :=    \\ {      | zero := false      | (suc n) := even n    };    even : Nat -&gt; Bool :=    \\ {      | zero := true      | (suc n) := odd n    };end;</pre></code></pre>","boost":3},{"location":"reference/language/iterators/","title":"Iterators","text":"<p>Any identifier can be declared as an iterator. The syntax to define an iterator is the following:</p>","boost":3},{"location":"reference/language/iterators/#syntax","title":"Syntax","text":"<pre><code>syntax iterator &lt;name&gt;;\n</code></pre> <p>or</p> <pre><code>syntax iterator &lt;name&gt; {init := &lt;initVal&gt;;  range := &lt;ranges&gt;};\n</code></pre> <p>where <code>n</code> and <code>k</code> specify the number of initializers (of the form <code>acc := a</code>) and ranges (of the form <code>x in xs</code>) in iterator application. If the number of initializers or ranges is not specified, then any number is allowed in iterator application.</p> <p>An application of an iterator <code>iter</code> has the general form</p> <pre><code>iter (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}\n</code></pre> <p>where <code>acci</code>, <code>xi</code> are patterns, <code>ai</code>, <code>xsi</code> are expressions, and <code>body</code> is an expression which can refer to the variables bound by the <code>acci</code>, <code>xi</code>. The braces around <code>body</code> are optional.</p> <p>The iterator application syntax is equivalent to</p> <pre><code>iter \\{acc1 .. accn x1 .. xk := body} a1 .. an xs1 .. xsk\n</code></pre>","boost":3},{"location":"reference/language/lets/","title":"Local Definitions","text":"<p>Local definitions in Juvix are facilitated by the <code>let</code> expression. This feature is particularly beneficial for defining identifiers that are exclusive to a single scope.</p>","boost":3},{"location":"reference/language/lets/#syntax-of-let-expression","title":"Syntax of <code>let</code> Expression","text":"<p>The syntax for a <code>let</code> binding is as follows:</p> <pre><code>let &lt;name&gt; : &lt;type&gt; := &lt;term&gt;;\nin &lt;body&gt;\n</code></pre> <p>In this syntax:</p> <ul> <li><code>{name}</code> refers to the name of the variable you want to define and should be a   valid identifier of type <code>&lt;type&gt;</code>.</li> <li><code>{term}</code> is the value or computation assigned to the identifier.</li> <li><code>{body}</code> represents the section of code where this local definition is valid.</li> </ul> <p>Here's an example:</p> <pre><code><pre>sum (lst : List Nat) : Nat :=  let    go (acc : Nat) : List Nat -&gt; Nat      | nil := acc      | (x :: xs) := go (acc + x) xs;  in go 0 lst;</pre></code></pre> <p>In this case, <code>x</code> is the identifier, <code>5</code> is the expression, and <code>x * x</code> is the body. The result of this code would be <code>25</code>.</p>","boost":3},{"location":"reference/language/modules/","title":"Module System","text":"<p>Modules facilitate the division of programs into separate files. In Juvix, this is achieved through top modules and local modules. Top modules are defined at the file's top, while local modules are nested within another module. Local modules also serve to organize different scopes within a file.</p>","boost":3},{"location":"reference/language/modules/#syntax-of-module-declaration","title":"Syntax of <code>module</code> declaration","text":"<p>The syntax for defining a module is:</p> <pre><code>module &lt;name&gt;;\n  &lt;body&gt;\nend;\n</code></pre> <p>In this syntax:</p> <ul> <li> <p><code>&lt;name&gt;</code> represents the module's name.</p> </li> <li> <p><code>&lt;body&gt;</code> is a sequence of Juvix statements (traits, data types, functions,   etc.).</p> </li> <li> <p>The <code>end</code> keyword is used to close the module definition.</p> </li> </ul> <p>Note</p> <p>The <code>end</code> keyword is optional if the module definition is the last statement in the file.</p> <p>For instance, to define a module named <code>Data.List</code>, we write:</p> <pre><code>module Data.List;\n&lt;body&gt;\n</code></pre>","boost":3},{"location":"reference/language/modules/#top-module-naming-convention","title":"Top module naming convention","text":"<p>Top modules that belong to a project must follow a naming convention. That is, if <code>dir</code> is the root of a project, then the module in <code>dir/Data/List.juvix</code> must be named <code>Data.List</code>.</p>","boost":3},{"location":"reference/language/modules/#import-and-open-statements","title":"Import and open statements","text":"<p>In order to access the definitions from another modules we use an import statement. To import some module named <code>Data.List</code> we will write</p> <pre><code>import Data.List;\n</code></pre> <p>Now, we can access the definitions in the imported module using qualified names. E.g., <code>Data.List.sort</code>.</p> <p>It is possible to import modules and give them a more convenient name thus:</p> <pre><code>import Data.List as List;\n</code></pre>","boost":3},{"location":"reference/language/modules/#open-statements","title":"Open statements","text":"<p>If we want to access the contents of a module without the need to qualify the names, we use an open statement. The syntax is as follows:</p> <pre><code>open Data.List;\n</code></pre> <p>Now we can simply write <code>sort</code>.</p> <p>It is important to remember that when we open a module, that module must be in scope, i.e., it must either be imported or defined as a local module.</p> <p>Since importing and opening a module is done often, there is special syntax for that. The following statement:</p> <pre><code>import Data.List open;\n</code></pre> <p>Is equivalent to this:</p> <pre><code>import Data.List;\nopen Data.List;\n</code></pre> <p>In general, we can combine any import statement and open statement that refer to the same module. The syntax is <code>&lt;import statement&gt; &lt;open statement without module name&gt;</code>.</p> <p>When opening a module, if we want to open an explicit subset of its definitions, we must use the <code>using</code> keyword thus:</p> <pre><code>open Data.List using {List; sort; reverse};\n</code></pre> <p>We can also rename symbols in an open statement thus:</p> <pre><code>open Data.List using {List; sort as listSort; reverse as reverseList};\n</code></pre> <p>If we want to open all definitions of a module minus a subset, we use the <code>hiding</code> keyword thus:</p> <pre><code>open Data.List hiding {head; tail};\n</code></pre> <p>Sometimes you might want to open or hide the type constructors of a data type. Recall that each data type defines a module containing names linked to its type constructors. For example, if you want to hide the type constructors of a data type, you must use the <code>hiding</code> keyword and module keyword as follows:</p> <pre><code>import Stdlib.Prelude open hiding {module List};\n</code></pre>","boost":3},{"location":"reference/language/modules/#reexport-modules","title":"Reexport modules","text":"<p>All opened definitions are available under the current module, but they are not exported by default. Meaning that if another module imports the current module, it will only be able to access the definitions defined there but not those which have been opened. If we want opened definitions to be exported, we must use the <code>public</code> keyword thus:</p> <pre><code>module Prelude;\n\nimport Data.List open public;\n</code></pre> <p>Now, from another module we can access definitions in <code>Data.List</code> through the <code>Prelude</code> module.</p> <pre><code>module MyModule;\n\nimport Prelude open;\n\n-- List, sort, reverse, etc. are now in scope\n</code></pre>","boost":3},{"location":"reference/language/modules/#local-modules","title":"Local modules","text":"<p>Juvix modules have a hierarchical structure. So far we have discussed top level modules, which have a one-to-one correspondence with files in the filesystem. On the other hand, local modules are defined within another module. They can be useful to group definitions within a file.</p> <p>The syntax for local modules is as follows:</p> <pre><code>module Path.To.TopModule;\n\nmodule ModuleName;\n  &lt;body&gt;\nend;\n</code></pre> <p>Note that local module names cannot contain the <code>.</code> character.</p> <p>After the definition of a local module, we can access its definitions by using qualified names. Local modules can be opened by open statements in the same way as top modules.</p> <p>Local modules inherit the scope of the parent module. Some shadowing rules apply, and they probably follow your intuition:</p> <ol> <li>Opening or defining a symbol shadows inherited instances of that symbol.</li> <li>Opening a symbol does not shadow a defined instance of that symbol in the    current module.</li> <li>Conversely, defining a symbol in the current module does not shadow an    opened instance of that symbol.</li> </ol> <p>As a consequence of 2 and 3, using a symbol that is both defined and opened locally will result in an ambiguity error. In order to solve that, the symbol that was opened, would need to be used qualified instead.</p>","boost":3},{"location":"reference/language/operators/","title":"Operator Syntax","text":"<p>The <code>syntax</code> keyword, paired with <code>operator</code>, caters for functions serving as operators. These operators often have distinct associativity and precedence from regular functions. The pairing associates a term with one fixity, defining its arity and potentially its precedence and associativity. This syntax declaration has to precede the term declaration.</p> <pre><code>syntax operator &lt;name&gt; &lt;fixity&gt;;\n</code></pre> <p>Where <code>&lt;fixity&gt;</code> is a previously declared fixity. Note that there are already many commons of these declarations included with the standard library. See common fixities for more information.</p> <p>For instance, we can define the <code>\u00d7</code> operator as a binary operator as follows:</p> <pre><code><pre>syntax fixity product := binary;syntax operator \u00d7 product;type \u00d7 (a : Type) (b : Type) := , : a \u2192 b \u2192 a \u00d7 b;</pre></code></pre>","boost":3},{"location":"reference/language/pragmas/","title":"Pragmas in Juvix","text":"<p>Pragmas in Juvix are used to provide additional information to the compiler about how to handle specific identifiers or modules. They offer a way to control the compilation process and can be associated with identifiers by placing a pragma comment just before the identifier declaration.</p>","boost":3},{"location":"reference/language/pragmas/#syntax-of-pragma","title":"Syntax of Pragma","text":"<p>The syntax for binding a pragma to an identifier is as follows:</p> <pre><code>{-# pragma_name: pragma_value #-}\nidentifier : Type;\n</code></pre> <p>For instance, the subsequent code associates the <code>inline</code> pragma with a value of <code>true</code> to the identifier <code>f</code>.</p> <pre><code><pre>{-# inline: true #-}f : Nat -&gt; Nat  | x := x;</pre></code></pre> <p>Multiple pragmas can be linked with a single identifier, delineated by commas:</p> <pre><code><pre>{-# inline: true, unroll: 100 #-}g : Nat -&gt; Nat  | x := x;</pre></code></pre> <p>Pragmas associated with a module are inherited by all definitions within the module, unless explicitly overridden. For example,</p> <pre><code><pre>{-# inline: true #-}module M;  f : Nat -&gt; Nat := &lt;body-f&gt;;    g : Nat -&gt; Nat := &lt;body-g&gt;;  {-# inline: false #-}  h : Nat -&gt; Nat := &lt;body-h&gt;;end;</pre></code></pre> <p>In this scenario, inlining is enabled for <code>f</code>, <code>g</code> and disabled for <code>h</code>.</p> <p>Pragmas are mappings in YAML syntax, albeit the outermost braces are not mandated for the top-level mapping if it's on a single line. If the compiler encounters any unrecognized pragmas, they will be disregarded to ensure backwards compatibility. Although pragmas influence the compilation process, they don't carry any semantic significance - eliminating all pragmas should not alter the meaning of the program.</p>","boost":3},{"location":"reference/language/pragmas/#available-pragmas","title":"Available Pragmas","text":"<p>Herein, we enumerate all currently recognized pragmas in Juvix. In the descriptions below, <code>b</code> symbolizes a boolean (<code>true</code> or <code>false</code>), and <code>n</code> symbolizes a non-negative number.</p>","boost":3},{"location":"reference/language/pragmas/#inlining-functions","title":"Inlining Functions","text":"<ul> <li><code>inline: b</code></li> </ul> <p>This pragma specifies whether a function should be inlined. If set to <code>true</code>,   the function will invariably be inlined when fully applied. If set to <code>false</code>,   the function will never be inlined, which also disables automatic inlining.</p>","boost":3},{"location":"reference/language/pragmas/#inlining-partial-applications","title":"Inlining Partial Applications","text":"<ul> <li><code>inline: n</code></li> </ul> <p>This variant of the <code>inline</code> pragma specifies that a partial application of   the function with at least <code>n</code> explicit arguments should always be inlined.   For example:</p> <pre><code><pre>{-# inline: 2 #-}compose {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);</pre></code></pre> <p>In the expression <code>compose f g</code>, the function <code>compose</code> will be inlined, but   in <code>compose f</code>, it won't be.</p>","boost":3},{"location":"reference/language/pragmas/#mandatory-inlining","title":"Mandatory inlining","text":"<ul> <li><code>inline: always</code></li> </ul> <p>This pragma specifies that a function should always be inlined,   regardless of the optimization level or how many arguments it is   applied to. This pragma should be used sparingly. It is intended   mainly for (standard) library developers.</p>","boost":3},{"location":"reference/language/pragmas/#case-value-inlining","title":"Case value inlining","text":"<ul> <li><code>inline: case</code></li> </ul> <p>This pragma specifies that a function should be inline whenever it   is matched on. Using this pragma makes most sense with small   functions that directly return a constructor application.</p>","boost":3},{"location":"reference/language/pragmas/#unrolling-recursion","title":"Unrolling Recursion","text":"<ul> <li><code>unroll: n</code></li> </ul> <p>This pragma sets the maximum recursion unrolling depth to <code>n</code>. It only affects   the <code>vampir</code> and <code>geb</code> backends.</p>","boost":3},{"location":"reference/language/pragmas/#naming-function-arguments-for-generated-code","title":"Naming Function Arguments for Generated Code","text":"<ul> <li><code>argnames: [arg1, .., argn]</code></li> </ul> <p>This pragma sets the names of function arguments in the generated output to   <code>arg1</code>,..,<code>argn</code>. This is primarily useful with the <code>vampir</code> backend to name   VampIR input variables.</p>","boost":3},{"location":"reference/language/pragmas/#formatting","title":"Formatting","text":"<ul> <li><code>format: b</code></li> </ul> <p>This pragma enables or disables formatting for the specified module. Adding   the <code>format: false</code> pragma before a module makes the formatter ignore the   module and output it verbatim.</p>","boost":3},{"location":"reference/language/pragmas/#specializing-function-arguments","title":"Specializing Function Arguments","text":"<ul> <li><code>specialize: [arg1, .., argn]</code> or <code>specialize-args: [arg1, .., argn]</code></li> </ul> <p>This pragma specifies that the arguments <code>arg1</code>, ..., <code>argn</code> should   be specialized in each fully applied function occurrence. Only   explicit and instance arguments can be specialized. The arguments   can be specified by name or by their position in the argument list   (ignoring implicit arguments). For example, with the definition</p> <pre><code><pre>{-# specialize: [f] #-}map {A B} (f : A -&gt; B) : List A -&gt; List B  | nil := nil  | (x :: xs) := f x :: map f xs;</pre></code></pre> <p>any occurrence of <code>map g lst</code> with <code>g : T -&gt; T'</code> not a variable will   be replaced by an application <code>map_g lst</code> of a new function <code>map_g</code>   defined as:</p> <pre><code><pre>map_g : List T -&gt; List T'  | nil := nil  | (x :: xs) := g x :: map_g xs;</pre></code></pre> <p>The argument <code>f</code> can also be specificed as the first non-implicit argument:</p> <pre><code>{-# specialize: [1] #-}\n</code></pre> <ul> <li><code>specialize-by: [v1,..,vn]</code></li> </ul> <p>This pragma specifies that a local function should be specialized by   the values of the variables <code>v1,..,vn</code> from the surrounding   context. This is commonly used to specialize local functions by some   arguments of the enclosing function. For example, given</p> <pre><code><pre>{-# inline: true #-}funa {A} (f : A -&gt; A) (a : A) : A :=  let    {-# specialize-by: [f] #-}    go : Nat -&gt; A      | zero := a      | (suc n) := f (go n);  in go 10;</pre></code></pre> <p>whever the function <code>funa</code> gets inlined with a particular value <code>v</code>   for <code>f</code>, the function <code>go</code> will be specialized with that value <code>v</code>   substituted for <code>f</code>. Without the <code>specialize-by</code> pragma, after   inlining <code>f</code> the function <code>g</code> would have an additional argument <code>f</code>   -- the value <code>v</code> would be passed to <code>g</code> through this argument instead   of being \"pasted\" into the body of <code>g</code>.</p> <ul> <li><code>specialize: b</code></li> </ul> <p>When provided before a type or a value (zero-argument function)   definition, this pragma specifies whether values of the type or the   given value should always be used to specialize functions. For   example,</p> <pre><code><pre>{-# specialize: true #-}traittype Natural N :=  mkNatural {    + : N -&gt; N -&gt; N;    * : N -&gt; N -&gt; N;    fromNat : Nat -&gt; N  };</pre></code></pre> <p>will result in specializing any function applied to an argument of   type <code>Natural N</code> for some <code>N</code>.</p> <p>Declaring</p> <pre><code><pre>module pragma-specialise-instance;  {-# specialize: true #-}  instance  naturalNatI : Natural Nat := &lt;body&gt;;end;</pre></code></pre> <p>will result in specializing any function applied to <code>naturalNatI</code>.</p> <p>Declaring</p> <pre><code><pre>module pragma-specialise-instance-false;  {-# specialize: false #-}  naturalNatI : Natural Nat := &lt;body&gt;;end;</pre></code></pre> <p>will prevent specializing functions applied to <code>naturalNatI</code>, even   if the argument to which it is provided was declared for   specialization with <code>specialize</code> or <code>specialize-args</code>.</p>","boost":3},{"location":"reference/language/records/","title":"Records","text":"<p>Records are a special kind of data type. Each data constructor within a record has named type arguments. This feature is reminiscent of declaring a structure in languages such as C++ or Java, or akin to defining a record in a database system.</p>","boost":3},{"location":"reference/language/records/#syntax-and-semantics","title":"Syntax and Semantics","text":"<p>In the context of record types, a field is a named type argument that is intrinsically associated with a data constructor. The field's name functions as an identifier or a key, enabling access to the value that is bound to the term of the record type.</p> <p>The standard syntax for declaring a record type is as follows:</p> <pre><code>trait\ntype &lt;record name&gt; &lt;type parameters&gt; :=\n    | &lt;type-constructor1&gt; {\n        &lt;field1-1&gt; : &lt;type-1-1&gt;;\n        ...\n        &lt;field1-n&gt; : &lt;type-1-n&gt;\n        }\n    | ...\n    | &lt;type-constructor-n&gt; {\n        &lt;fieldn-1&gt; : &lt;type-n-1&gt;;\n        ...\n        &lt;fieldn-n&gt; : &lt;type-n-n&gt;\n    };\n</code></pre> <p>In this syntax:</p> <ul> <li> <p><code>&lt;record name&gt;</code> is a unique identifier for the declared record type. This name should be unique within its scope and it is case sensitive.</p> </li> <li> <p><code>&lt;type parameters&gt;</code> are optional and represent the generic parameters that the   record type may take, see data types for more information.   They allow for greater flexibility and reusability of the record type.</p> </li> <li> <p><code>&lt;type-constructor&gt;</code> represents the different constructors that the record type can have. Each constructor can have a different set of fields.</p> </li> <li> <p><code>&lt;field1-1&gt;</code>, <code>&lt;field1-n&gt;</code>, <code>&lt;fieldn-1&gt;</code>, <code>&lt;fieldn-n&gt;</code> are the names of the fields in each constructor. These names should be unique within their constructor.</p> </li> <li> <p><code>&lt;type-1-n&gt;</code>, <code>&lt;type-n-1&gt;</code>, <code>&lt;type-n-n&gt;</code> represent the type of the corresponding field.</p> </li> </ul> <p>Note<p>One thing to note is that the field names are qualified by the type name. This means that the field names are prefixed by the type name when accessing them. If this is not desired, the <code>open</code> keyword can be used to bring the field names into scope followed by the type name.</p> </p>","boost":3},{"location":"reference/language/records/#usage","title":"Usage","text":"<p>Records function similarly to other data types. They can be defined locally, exported from a module, and utilized in pattern matching.</p> <p>For example, here we declare the <code>newType</code> record type with the <code>mkNewtype</code> type constructor and one field named <code>f</code>.</p> <pre><code><pre>type T := constructT : T;type newtype := mkNewtype {f : T};</pre></code></pre> <p>Records with multiple constructors can also be defined. Consider the <code>Pair</code> record type that models pairs of values. The <code>Pair</code> type has a single <code>mkPair</code> type constructor that takes two arguments, named <code>fst</code> and <code>snd</code>, of type parameters <code>A</code> and <code>B</code>, respectively.</p> <pre><code><pre>type Pair (A B : Type) :=  mkPair {    fst : A;    snd : B  };</pre></code></pre> <p>To utilize this type, create a <code>Pair</code> type term (a pair) using the <code>mkPair</code> type constructor and provide values for each field.</p> <pre><code><pre>p1 : Pair T T := mkPair (fst := constructT; snd := constructT);</pre></code></pre> <p>Field names allow access to their corresponding values. For example, another pair equivalent to the one defined above can be declared using values retrieved via the field names.</p> <pre><code><pre>p1' : Pair T T := mkPair (fst := Pair.fst p1; snd := Pair.snd p1);</pre></code></pre> <p>One variant of the record term creation is as follows:</p> <pre><code><pre>p1'' : Pair T T :=  mkPair@{    fst := Pair.fst p1;    snd := Pair.snd p1  };</pre></code></pre> <p>By default, the fields of a record type are qualified by the type name. To access the fields without specifying the type name, use the <code>open</code> keyword to bring these names into scope.</p> <pre><code><pre>open Pair;flipP : Pair T T := mkPair (fst := snd p1; snd := fst p1);</pre></code></pre> <p>Finally, consider the declaration of a record with multiple constructors.</p> <pre><code><pre>type EnumRecord :=  | C1 {      c1a : T;      c1b : T    }  | C2 {      c2a : T;      c2b : T    };p2 : Pair EnumRecord EnumRecord :=  mkPair    (fst := C1 (c1a := constructT; c1b := constructT);    snd := C2 (c2a := constructT; c2b := constructT));</pre></code></pre>","boost":3},{"location":"reference/language/syntax/","title":"Module","text":"<pre><code>--8&lt;-- [start:module-syntax]\nmodule &lt;name&gt;;\n  &lt;body&gt;\nend;\n--8&lt;-- [end:module-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#alias","title":"Alias","text":"<pre><code>--8&lt;-- [start:alias-syntax]\nsyntax alias &lt;newName&gt; := &lt;originalName&gt;;\n--8&lt;-- [end:alias-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#fixity","title":"Fixity","text":"<pre><code>--8&lt;-- [start:fixity-arity-syntax]\nsyntax fixity &lt;name&gt; := &lt;arity&gt;;\n--8&lt;-- [end:fixity-arity-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#axiom","title":"Axiom","text":"<pre><code>--8&lt;-- [start:axiom-syntax]\naxiom &lt;name&gt; : &lt;type&gt;;\n--8&lt;-- [end:axiom-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#function","title":"Function","text":"<pre><code>--8&lt;-- [start:function-syntax]\n&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt; := &lt;body&gt;;\n--8&lt;-- [end:function-syntax]\n</code></pre> <pre><code>--8&lt;-- [start:function-named-arguments]\n&lt;funName&gt; (&lt;argName&gt; : &lt;argType&gt;) : &lt;returnType&gt; := &lt;body&gt;;\n--8&lt;-- [end:function-named-arguments]\n</code></pre> <pre><code>--8&lt;-- [start:function-pattern-matching]\n&lt;funName&gt; : &lt;argType&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat1&gt; := &lt;body1&gt;\n    | ...\n    | &lt;patN&gt; := &lt;bodyN&gt;;\n--8&lt;-- [end:function-pattern-matching]\n</code></pre> <p>It may have multiple patters:</p> <pre><code>--8&lt;-- [start:function-pattern-matching-multiple-arguments]\n&lt;funName&gt; : &lt;argType1&gt; -&gt; &lt;argType2&gt; -&gt; &lt;returnType&gt;\n    | &lt;pat-1-1&gt; &lt;pat-1-2&gt; := &lt;body1&gt;\n    | ...\n    | &lt;pat-n-1&gt; &lt;pat-n-2&gt; := &lt;bodyN&gt;;\n--8&lt;-- [end:function-pattern-matching-multiple-arguments]\n</code></pre> <p>Lambdas</p> <pre><code>--8&lt;-- [start:function-lambda]\n\\{ | pat1 .. patN_1 := clause1\n   | ..\n   | pat1 .. patN_M := clauseM }\n--8&lt;-- [end:function-lambda]\n</code></pre>"},{"location":"reference/language/syntax/#data-types","title":"Data Types","text":"<pre><code>--8&lt;-- [start:datatype-syntax]\ntype &lt;name&gt; &lt;type-parameters&gt; :=\n    | &lt;constructor1&gt; : &lt;type1&gt;\n    | ...\n    | &lt;constructorn&gt; : &lt;typen&gt;;\n--8&lt;-- [end:datatype-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#traits-and-records","title":"Traits and Records","text":"<pre><code>[trait]\n--8&lt;-- [start:record-syntax]\ntype &lt;record name&gt; &lt;type parameters&gt; :=\n    | &lt;type-constructor1&gt; {\n        &lt;field1-1&gt; : &lt;type-1-1&gt;;\n        ...\n        &lt;field1-n&gt; : &lt;type-1-n&gt;\n        }\n    | ...\n    | &lt;type-constructor-n&gt; {\n        &lt;fieldn-1&gt; : &lt;type-n-1&gt;;\n        ...\n        &lt;fieldn-n&gt; : &lt;type-n-n&gt;\n    };\n--8&lt;-- [end:record-syntax]\n</code></pre> <p>Instances:</p> <pre><code>--8&lt;-- [start:instance-syntax]\ninstance\n&lt;term&gt; : {{&lt;trait&gt;}} := &lt;trait constructor&gt; (\n    field1 := &lt;term1&gt;;\n    ...\n    fieldn := &lt;termn&gt;;\n);\n--8&lt;-- [end:instance-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#let","title":"Let","text":"<pre><code>--8&lt;-- [start:let-syntax]\nlet &lt;name&gt; : &lt;type&gt; := &lt;term&gt;;\nin &lt;body&gt;\n--8&lt;-- [end:let-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#iterator","title":"Iterator","text":"<pre><code>--8&lt;-- [start:iterator-syntax-simple]\nsyntax iterator &lt;name&gt;;\n--8&lt;-- [end:iterator-syntax-simple]\n</code></pre> <pre><code>--8&lt;-- [start:iterator-syntax-simple-with-arguments]\nsyntax iterator &lt;name&gt; {init := &lt;initVal&gt;;  range := &lt;ranges&gt;};\n--8&lt;-- [end:iterator-syntax-simple-with-arguments]\n</code></pre> <pre><code>--8&lt;-- [start:iterator-application-syntax]\niter (acc1 := a1; ..; accn := an) (x1 in xs1; ..; xk in xsk) {body}\n--8&lt;-- [end:iterator-application-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#pragmas","title":"Pragmas","text":"<pre><code>--8&lt;-- [start:pragma-id-syntax]\n{-# pragma_name: pragma_value #-}\nidentifier : Type;\n--8&lt;-- [end:pragma-id-syntax]\n</code></pre>"},{"location":"reference/language/syntax/#control","title":"Control","text":""},{"location":"reference/language/syntax/#case","title":"Case","text":"<pre><code>--8&lt;-- [start:case-syntax]\ncase &lt;expression&gt; of {\n  | &lt;pattern1&gt; := &lt;branch1&gt;\n  ..\n  | &lt;patternN&gt; := &lt;branchN&gt;\n}\n--8&lt;-- [end:case-syntax]\n</code></pre>"},{"location":"reference/language/traits/","title":"Traits","text":"<p>A trait is a special type of record that can be used to define a set of functions that must be implemented for a given type.</p>","boost":3},{"location":"reference/language/traits/#syntax-of-traits","title":"Syntax of Traits","text":"","boost":3},{"location":"reference/language/traits/#trait-declarations","title":"Trait declarations","text":"<p>Traits are declared using the <code>trait</code> keyword, followed by a record type declaration.</p> <pre><code>trait\ntype &lt;record name&gt; &lt;type parameters&gt; :=\n    | &lt;type-constructor1&gt; {\n        &lt;field1-1&gt; : &lt;type-1-1&gt;;\n        ...\n        &lt;field1-n&gt; : &lt;type-1-n&gt;\n        }\n    | ...\n    | &lt;type-constructor-n&gt; {\n        &lt;fieldn-1&gt; : &lt;type-n-1&gt;;\n        ...\n        &lt;fieldn-n&gt; : &lt;type-n-n&gt;\n    };\n</code></pre> <p>For example, the following defines a trait <code>Show</code>. Any type <code>A</code> that implements <code>Show</code> must provide a function <code>show</code> that takes an <code>A</code> and returns a <code>String</code>.</p> <pre><code><pre>traittype Show A := mkShow {show : A \u2192 String};</pre></code></pre>","boost":3},{"location":"reference/language/traits/#instance-declarations","title":"Instance declarations","text":"<p>An instance of a trait refers to a term of the corresponding record type, which must implement all methods stipulated by the trait.</p>","boost":3},{"location":"reference/language/traits/#syntax-of-instance-declarations","title":"Syntax of instance declarations","text":"<p>To declare a given term is an instance of a trait, we use the <code>instance</code> keyword. To define an instance of a trait, we use the trait constructor of the corresponding record type.</p> <pre><code>instance\n&lt;term&gt; : {{&lt;trait&gt;}} := &lt;trait constructor&gt; (\n    field1 := &lt;term1&gt;;\n    ...\n    fieldn := &lt;termn&gt;;\n);\n</code></pre> <p>For example, we could define three instances of <code>Show</code> for <code>String</code>, <code>Bool</code>, and <code>Nat</code> as follows:</p> <pre><code><pre>instanceshowStringI : Show String := mkShow (show := id);instanceshowBoolI : Show Bool := mkShow (show := \u03bb {x := if x \"true\" \"false\"});instanceshowNatI : Show Nat := mkShow (show := natToString);</pre></code></pre> <p>One more involved example is the following, which defines an instance of <code>Show</code> for the type of lists:</p> <pre><code><pre>instanceshowListI {A} {{Show A}} : Show (List A) :=  let    showList {A} : {{Show A}} \u2192 List A \u2192 String      | nil := \"nil\"      | (h :: t) := Show.show h ++str \" :: \" ++str showList t;  in mkShow (show := showList);</pre></code></pre>","boost":3},{"location":"reference/language/traits/#usage","title":"Usage","text":"<p>Using the <code>Show</code> trait defined above, we can define a function <code>showNat</code> that takes a <code>Nat</code> and returns a <code>String</code>. One possible implementation is the following:</p> <pre><code><pre>module usage-example;  type Nat :=    | Z    | S Nat;  trait  type Show A := mkShow {show : A \u2192 String};    NatToString : Nat -&gt; String    | Z := \"Z\"    | (S n) := \"S \" ++str NatToString n;  instance  showNat : Show Nat := mkShow (show := NatToString);end;</pre></code></pre> <p>To prevent looping during instance search, we ensure a structural decrease in the trait parameters of instance types. Therefore, the following is rejected:</p> <pre><code><pre>type Box A := box A;traittype T A := mkT {pp : A \u2192 A};</pre></code></pre> <p>We check whether each parameter is a strict subterm of some trait parameter in the target. This ordering is included in the finite multiset extension of the subterm ordering, hence terminating.</p> <ul> <li>Matching on implicit instances</li> </ul> <p>It is possible to manually provide an instance and to match on implicit instances, as shown below:</p> <pre><code><pre>f {A} {{Show A}} : A \u2192 String  | x := Show.show x;f' {A} : {{Show A}} \u2192 A \u2192 String  | {{mkShow s}} x := s x;f'' {A} : {{Show A}} \u2192 A \u2192 String  | {{M}} x := Show.show {{M}} x;</pre></code></pre> <p>Finally, using the <code>Show</code> trait and the function <code>printStringLn</code> and <code>IO</code> from the standard library, we could use the instances of <code>Show</code> as follows:</p> <pre><code><pre>main : IO :=  printStringLn (Show.show true)    &gt;&gt; printStringLn (f false)    &gt;&gt; printStringLn (Show.show 3)    &gt;&gt; printStringLn (Show.show [true; false])    &gt;&gt; printStringLn (Show.show [1; 2; 3])    &gt;&gt; printStringLn (f' [1; 2])    &gt;&gt; printStringLn (f'' [true; false])    &gt;&gt; printStringLn (Show.show [\"a\"; \"b\"; \"c\"; \"d\"]);</pre></code></pre>","boost":3},{"location":"reference/tooling/CLI/","title":"CLI","text":""},{"location":"reference/tooling/CLI/#usage","title":"Usage","text":"<pre><code>juvix [Global options] ((-v|--version) | (-h|--help) | COMPILER_CMD | UTILITY_CMD)\n</code></pre>"},{"location":"reference/tooling/CLI/#informative-options","title":"Informative options","text":"<ul> <li><code>-v,--version</code> Print the version and exit</li> <li><code>--numeric-version</code> Show only the version number</li> <li><code>-h,--help</code> Show this help text</li> </ul>"},{"location":"reference/tooling/CLI/#global-command-flags","title":"Global Command flags","text":"<ul> <li><code>--no-colors</code> Disable globally ANSI formatting</li> <li><code>--show-name-ids</code> Show the unique number of each identifier when   pretty printing</li> <li><code>--only-errors</code> Only print errors in a uniform format (used by   juvix-mode)</li> <li><code>--no-termination</code> Disable termination checking</li> <li><code>--no-positivity</code> Disable positivity checking for inductive types</li> <li><code>--no-coverage</code> Disable coverage checking for patterns</li> <li><code>--no-stdlib</code> Do not use the standard library</li> <li><code>--internal-build-dir BUILD_DIR</code> Directory for compiler internal output</li> <li><code>--stdin</code> Read from Stdin</li> <li><code>--unroll ARG</code> Recursion unrolling limit (default: 140)</li> </ul>"},{"location":"reference/tooling/CLI/#main-commands","title":"Main Commands","text":"<ul> <li><code>html</code> Generate HTML output from a Juvix file</li> <li><code>typecheck</code> Typecheck a Juvix file</li> <li><code>compile</code> Compile a Juvix file</li> <li><code>eval</code> Evaluate a Juvix file</li> </ul>"},{"location":"reference/tooling/CLI/#utility-commands","title":"Utility Commands","text":"<ul> <li><code>doctor</code> Perform checks on your Juvix development environment</li> <li><code>init</code> Interactively initialize a Juvix project in the current   directory</li> <li><code>repl</code> Run the Juvix REPL</li> <li><code>format</code> Format a Juvix file or Juvix project</li> <li><code>clean</code> Delete build artifacts</li> </ul>"},{"location":"reference/tooling/CLI/#dev-commands","title":"Dev Commands","text":"<pre><code>juvix dev COMMAND\n</code></pre> <ul> <li><code>parse</code> Parse a Juvix file</li> <li><code>scope</code> Parse and scope a Juvix file</li> <li><code>highlight</code> Highlight a Juvix file</li> <li><code>core</code> Subcommands related to JuvixCore</li> <li><code>asm</code> Subcommands related to JuvixAsm</li> <li><code>root</code> Show the root path for a Juvix project</li> <li><code>termination</code> Subcommands related to termination checking</li> <li><code>internal</code> Subcommands related to Internal</li> <li><code>minic</code> Translate a Juvix file to a subset of C</li> <li><code>geb</code> Subcommands related to JuvixGeb</li> <li><code>runtime</code> Subcommands related to the Juvix runtime</li> <li><code>repl</code> Run the Juvix dev REPL</li> </ul>"},{"location":"reference/tooling/CLI/#cli-auto-completion-scripts","title":"CLI Auto-completion Scripts","text":"<p>The Juvix CLI can generate auto-completion scripts. Follow the instructions below for your shell.</p> <p>Note</p> <p>NB: You may need to restart your shell after installing the completion script.</p>"},{"location":"reference/tooling/CLI/#bash","title":"Bash","text":"<p>Add the following line to your bash init script (for example <code>~/.bashrc</code>).</p> <pre><code>eval \"$(juvix --bash-completion-script juvix)\"\n</code></pre>"},{"location":"reference/tooling/CLI/#fish","title":"Fish","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --fish-completion-script juvix\n  &gt; ~/.config/fish/completions/juvix.fish\n</code></pre>"},{"location":"reference/tooling/CLI/#zsh","title":"ZSH","text":"<p>Run the following command in your shell:</p> <pre><code>juvix --zsh-completion-script juvix &gt; $DIR_IN_FPATH/_juvix\n</code></pre> <p>where <code>$DIR_IN_FPATH</code> is a directory that is present on the ZSH FPATH variable (which you can inspect by running <code>echo $FPATH</code> in the shell).</p>"},{"location":"reference/tooling/doctor/","title":"Doctor","text":""},{"location":"reference/tooling/doctor/#juvix-doctor","title":"Juvix Doctor","text":"<p>The <code>juvix doctor</code> command can help you to troubleshoot problems with your development environment. For each problem the doctor finds they'll be a link to a section on this page to help you fix it.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-clang-command","title":"Could not find the clang command","text":"<p>The Juvix compiler uses the Clang compiler version 13 or later to generate binaries. You need to have Clang available on your system <code>$PATH</code>.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos","title":"MacOS","text":"<p>Use Homebrew:</p> <pre><code>brew install llvm\n</code></pre> <p>NB: The distribution of Clang that comes with XCode does not support the <code>Wasm</code> target so you must install the standard Clang distribution.</p>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install clang lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S llvm lld\n</code></pre>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasm-ld-command","title":"Could not find the wasm-ld command","text":"<p>The Juvix compiler required <code>wasm-ld</code> (the Wasm linker) to produce <code>Wasm</code> binaries.</p> <p>Recommended installation method:</p>"},{"location":"reference/tooling/doctor/#macos_1","title":"MacOS","text":"<p><code>wasm-ld</code> is included in the Homebrew llvm distribution:</p> <pre><code>brew install llvm\n</code></pre>"},{"location":"reference/tooling/doctor/#debian-ubuntu-linux_1","title":"Debian / Ubuntu Linux","text":"<pre><code>sudo apt install lldb lld\n</code></pre>"},{"location":"reference/tooling/doctor/#arch-linux_1","title":"Arch Linux","text":"<pre><code>sudo pacman -S lld\n</code></pre>"},{"location":"reference/tooling/doctor/#newer-clang-version-required","title":"Newer Clang version required","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-target","title":"Clang does not support the wasm32 target","text":"<p>Juvix requires Clang version 13 or above. See the documentation on installing Clang.</p>"},{"location":"reference/tooling/doctor/#clang-does-not-support-the-wasm32-wasi-target","title":"Clang does not support the wasm32-wasi target","text":"<p>Juvix uses WASI - The Wasm System Interface to produce binaries that can be executed using a Wasm runtime. The files necessary to setup Clang with <code>wasm32-wasi</code> support are available at wasi-sdk.</p> <p>To install the <code>wasm32-wasi</code> target for Clang you need to do two things:</p>"},{"location":"reference/tooling/doctor/#install-libclang_rtbuiltins-wasm32a-into-your-clang-distribution","title":"Install <code>libclang_rt.builtins-wasm32.a</code> into your Clang distribution","text":"<ol> <li> <p>Obtain <code>libclang_rt.builtins-wasm32-wasi-16.0.tar.gz</code> from the     wasi-sdk     releases page.</p> </li> <li> <p>Untar the file and place the file     <code>lib/wasi/libclang_rt.builtins-wasm32.a</code> into your Clang     distribution directory.</p> <p>On MacOS, if you installed llvm using homebrew you can find the Clang distribution directory using <code>brew --prefix llvm</code>. You should then place the builtins file at <code>`brew --prefix llvm`/lib/wasi/libclang_rt.builtins-wasm32.a</code>.</p> <p>On Linux the Clang distribution directory will be something like <code>/usr/lib/clang/13.0.1</code> where <code>13.0.1</code> is the version of Clang that you have installed. You should then place the builtins file at <code>/usr/lib/clang/13.0.1/lib/wasi/libclang_rt.builtins-wasm32</code>.</p> </li> </ol>"},{"location":"reference/tooling/doctor/#download-the-wasi-sysroot-and-set-wasi_sysroot_path","title":"Download the WASI sysroot and set <code>WASI_SYSROOT_PATH</code>","text":"<ol> <li>Obtain <code>wasi-sysroot-16.0.tar.gz</code> from the wasi-sdk     releases page.</li> <li>Untar the file and set the environment variable <code>WASI_SYSROOT_PATH</code>     to that location.</li> </ol>"},{"location":"reference/tooling/doctor/#environment-variable-wasi_sysroot_path-is-not-set","title":"Environment variable <code>WASI_SYSROOT_PATH</code> is not set","text":"<p>Set the <code>WASI_SYSROOT_PATH</code> to the directory where you installed the <code>wasi-sdk</code> sysroot files. See installing the WASI sysroot.</p>"},{"location":"reference/tooling/doctor/#could-not-find-the-wasmer-command","title":"Could not find the wasmer command","text":"<p>The Juvix test suite uses Wasmer as a Wasm runtime to execute compiled Wasm binaries. See the Wasmer documentation to see how to install it.</p>"},{"location":"reference/tooling/emacs/","title":"Emacs mode","text":""},{"location":"reference/tooling/emacs/#emacs-mode","title":"Emacs Mode","text":"<p>There is an Emacs mode available for Juvix. Currently, it supports syntax highlighting for well-scoped modules.</p> <p>To get started, clone the Juvix Emacs mode repository:</p> <pre><code>git clone https://github.com/anoma/juvix-mode.git\n</code></pre> <p>To install it add the following lines to your Emacs configuration file:</p> <pre><code>(push \"/path/to/juvix-mode/\" load-path)\n(require 'juvix-mode)\n</code></pre> <p>Make sure that Juvix is installed in your <code>PATH</code>.</p> <p>The Juvix major mode will be activated automatically for <code>.juvix</code> files.</p>"},{"location":"reference/tooling/emacs/#keybindings","title":"Keybindings","text":"Key Function Name Description <code>C-c C-l</code> <code>juvix-load</code> Runs the scoper and adds semantic syntax highlighting <code>M-.</code> <code>juvix-goto-definition</code> Go to the definition of symbol at point <code>C-c C-f</code> <code>juvix-format-buffer</code> Format the current buffer"},{"location":"reference/tooling/emacs/#emacs-installation","title":"Emacs installation","text":"<p>Most Linux distributions contain an Emacs package which can be installed with your package manager (<code>sudo apt install emacs</code> on Ubuntu). On macOS, it is recommended to install Emacs Plus via Homebrew: <code>brew install emacs-plus</code>. Using the Emacs Homebrew casks is not recommended.</p>"},{"location":"reference/tooling/emacs/#common-problems","title":"Common problems","text":"<ul> <li>Error \"Symbol's value as variable is void: sh:1:\"</li> </ul> <p>Make sure the juvix executable is on the Emacs' <code>exec-path</code>. Note   that <code>exec-path</code> may be different from your shell's <code>PATH</code>. This is   particularly common on macOS with Emacs launched from GUI instead of   the terminal.</p> <p>The easiest way to resolve this issue is to install the   exec-path-from-shell   package (available on MELPA). Alternatively, one may set <code>exec-path</code>   to match shell <code>PATH</code> by following the instructions from   EmacsWiki.</p>"},{"location":"reference/tooling/testing/","title":"Testing","text":""},{"location":"reference/tooling/testing/#dependencies","title":"Dependencies","text":"<p>See Installing dependencies for instructions on how to set up the testing environment for the WASM compiler tests.</p>"},{"location":"reference/tooling/testing/#running","title":"Running","text":"<p>Run tests using:</p> <pre><code>make test\n</code></pre> <p>Or using <code>Stack</code>:</p> <pre><code>stack test\n</code></pre> <p>To run tests, ignoring all the WASM tests:</p> <pre><code>stack test --ta '-p \"! /slow tests/\"'\n</code></pre>"},{"location":"tutorials/emacs/","title":"Juvix Emacs mode tutorial","text":"<p>First, follow the instructions in the Emacs Mode Reference to install the Juvix Emacs mode. Once you've successfully set it up, create a file <code>Hello.juvix</code> with the following content.</p> <pre><code>\n</code></pre> <p>Type Ctrl+C+Ctrl+L to run the scoper and highlight the syntax.</p> <p>If you make a mistake in your program, it is automatically underlined in red with the error message popping up when you hover the mouse pointer over the underlined part.</p> <p>For example, in the following program the identifier <code>printStringLna</code> should be underlined with the error message \"Symbol not in scope\".</p> <pre><code>module Hello;\n\nopen import Stdlib.Prelude;\n\nmain : IO;\nmain := printStringLna \"Hello world!\";\n\nend;\n</code></pre> <p>If error underlining doesn't work, make sure you have the <code>flycheck</code> mode turned on. It should be turned on automatically when loading <code>juvix-mode</code>, but in case this doesn't work you can enable it with <code>M-x flycheck-mode</code>.</p> <p>Let's extend our program with another definition.</p> <pre><code>module Hello;\n  import Stdlib.Prelude open;\n\n  main : IO := printStringLn \"Hello world!\";\nend;\n</code></pre> <p>Place the cursor on the <code>print</code> call in the function clause of <code>main</code> and press <code>M-.</code>. The cursor will jump to the definition of <code>print</code> above. This also works across files and for definitions from the standard library. You can try using <code>M-.</code> to jump to the definition of <code>printStringLn</code>.</p> <p>One more feature of the Juvix Emacs mode is code formatting. To format the content of the current buffer, type Ctrl+C+Ctrl+F.</p>"},{"location":"tutorials/learn/","title":"Juvix tutorial","text":"<p>Welcome to the Juvix tutorial! This concise guide will introduce you to essential language features, while also serving as an introduction to functional programming. By the end of this tutorial, you'll have a strong foundation in Juvix's core concepts, ready to explore its advanced capabilities. Let's get started on your Juvix journey!</p>","boost":2},{"location":"tutorials/learn/#juvix-repl","title":"Juvix REPL","text":"<p>After installing Juvix, launch the Juvix REPL:</p> <pre><code>juvix repl\n</code></pre> <p>The response should be similar to:</p> <pre><code>Juvix REPL version 0.3: https://juvix.org. Run :help for help\nOK loaded: ./.juvix-build/stdlib/Stdlib/Prelude.juvix\nStdlib.Prelude&gt;\n</code></pre> <p>Currently, the REPL supports evaluating expressions but it does not yet support adding new definitions. To see the list of available REPL commands type <code>:help</code>.</p>","boost":2},{"location":"tutorials/learn/#basic-expressions","title":"Basic expressions","text":"<p>You can try evaluating simple arithmetic expressions in the REPL:</p> <pre><code>Stdlib.Prelude&gt; 3 + 4\n7\nStdlib.Prelude&gt; 1 + 3 * 7\n22\nStdlib.Prelude&gt; div 35 4\n8\nStdlib.Prelude&gt; mod 35 4\n3\nStdlib.Prelude&gt; sub 35 4\n31\nStdlib.Prelude&gt; sub 4 35\n0\n</code></pre> <p>By default, Juvix operates on non-negative natural numbers. Natural number subtraction is implemented by the function <code>sub</code>. Subtracting a bigger natural number from a smaller one yields <code>0</code>.</p> <p>You can also try boolean expressions</p> <pre><code>Stdlib.Prelude&gt; true\ntrue\nStdlib.Prelude&gt; not true\nfalse\nStdlib.Prelude&gt; true &amp;&amp; false\nfalse\nStdlib.Prelude&gt; true || false\ntrue\nStdlib.Prelude&gt; if true 1 0\n1\n</code></pre> <p>and strings, pairs and lists:</p> <pre><code>Stdlib.Prelude&gt; \"Hello world!\"\n\"Hello world!\"\nStdlib.Prelude&gt; (1, 2)\n(1, 2)\nStdlib.Prelude&gt; 1 :: 2 :: nil\n1 :: 2 :: nil\n</code></pre> <p>In fact, you can use all functions and types from the Stdlib.Prelude module of the standard library, which is preloaded by default.</p> <pre><code>Stdlib.Prelude&gt; length (1 :: 2 :: nil)\n3\nStdlib.Prelude&gt; null (1 :: 2 :: nil)\nfalse\nStdlib.Prelude&gt; swap (1, 2)\n(2, 1)\n</code></pre>","boost":2},{"location":"tutorials/learn/#files-modules-and-compilation","title":"Files, modules and compilation","text":"<p>Currently, the REPL does not support adding new definitions. To define new functions or data types, you need to put them in a separate file and either load the file in the REPL with <code>:load file.juvix</code>, evaluate it with the shell command <code>juvix eval file.juvix</code>, or compile it to a binary executable with <code>juvix compile file.juvix</code>.</p> <p>To conveniently edit Juvix files, an Emacs mode and a VSCode extension are available.</p> <p>A Juvix file must declare a module whose name corresponds exactly to the name of the file. For example, a file <code>Hello.juvix</code> must declare a module <code>Hello</code>:</p> <pre><code><pre>module Hello;  import Stdlib.Prelude open;    main : String := \"Hello world!\";end;</pre></code></pre> <p>A file compiled to an executable must define the zero-argument function <code>main</code> which is evaluated when running the program. The definition of <code>main</code> can have any non-function type, e.g., <code>String</code>, <code>Bool</code> or <code>Nat</code>. The generated executable prints the result of evaluating <code>main</code>.</p> <p>All the examples we will showcase will be located in separate modules to showcase all dependencies used explicitly. Note that all the formatted Juvix code one sees in the tutorial is contained in one Juvix file with no imports. Hence when we <code>open</code> a module without importing, this is due to the fact that the opened module is already contained in the file.</p>","boost":2},{"location":"tutorials/learn/#data-types-and-functions","title":"Data types and functions","text":"<p>To see the type of an expression, use the <code>:type</code> REPL command:</p> <pre><code>Stdlib.Prelude&gt; :type 1\nNat\nStdlib.Prelude&gt; :type true\nBool\n</code></pre> <p>The types <code>Nat</code> and <code>Bool</code> are defined in the standard library.</p> <p>The type <code>Bool</code> has two constructors <code>true</code> and <code>false</code>.</p> <pre><code><pre>module Bool;  type Bool :=    | true    | false;end;</pre></code></pre> <p>The constructors of a data type can be used to build elements of the type. They can also appear as patterns in function definitions. For example, the <code>not</code> function is defined in the standard library by:</p> <pre><code><pre>module Bool-Not;  open Bool;    not : Bool -&gt; Bool    | true := false    | false := true;end;</pre></code></pre> <p>The type of the definition is specified after the colon. In this case, <code>not</code> is a function from <code>Bool</code> to <code>Bool</code>. The type is followed by two function clauses which specify the function result depending on the shape of the arguments. When a function call is evaluated, the first clause that matches the arguments is used.</p> <p>In contrast to languages like Python, Java or C/C++, Juvix doesn't require parentheses for function calls. All the arguments are just listed after the function. The general pattern for function application is: <code>func arg1 arg2 arg3 ...</code></p> <p>Initial arguments that are matched against variables or wildcards in all clauses can be moved to the left of the colon. For example,</p> <pre><code><pre>module Bool-Or;  open Bool;    or (x : Bool) : Bool -&gt; Bool    | true := true    | _ := x;end;</pre></code></pre> <p>is equivalent to</p> <pre><code><pre>module Bool-Or-Altl;  open Bool;    or : Bool -&gt; Bool -&gt; Bool    | _ true := true    | x _ := x;end;</pre></code></pre> <p>If there is only one clause and all arguments are to the left of the colon, the pipe <code>|</code> should be omitted:</p> <pre><code><pre>module Bool-Id;  open Bool;    id (x : Bool) : Bool := x;end;</pre></code></pre> <p>A more complex example of a data type is the <code>Nat</code> type from the standard library:</p> <pre><code><pre>module Nat;  type Nat :=    | zero : Nat    | suc : Nat -&gt; Nat;end;</pre></code></pre> <p>The constructor <code>zero</code> represents <code>0</code> and <code>suc</code> represents the successor function \u2013 <code>suc n</code> is the successor of <code>n</code>, i.e., <code>n+1</code>. For example, <code>suc zero</code> represents <code>1</code>. The number literals <code>0</code>, <code>1</code>, <code>2</code>, etc., are just shorthands for appropriate expressions built using <code>suc</code> and <code>zero</code>.</p> <p>The constructors of a data type specify how the elements of the type can be constructed. For instance, the above definition specifies that an element of <code>Nat</code> is either:</p> <ul> <li><code>zero</code>, or</li> <li><code>suc n</code> where <code>n</code> is an element of <code>Nat</code>, i.e., it is constructed by applying   <code>suc</code> to appropriate arguments (in this case the argument of <code>suc</code> has type   <code>Nat</code>).</li> </ul> <p>Any element of <code>Nat</code> can be built with the constructors in this way \u2013 there are no other elements. Mathematically, this is an inductive definition, which is why the data type is called inductive.</p> <p>Constructors can either by specified by listing their types after colons like in the above definition of <code>Nat</code>, or with a shorter ADT syntax like in the definition of <code>Bool</code>. The ADT syntax is similar to data type definition syntax in functional languages like Haskell or OCaml: one lists the types of constructor arguments separated by spaces. In this syntax, the <code>Nat</code> type could be defined by</p> <pre><code><pre>module Nat-Alt;  type Nat :=    | zero    | suc Nat;end;</pre></code></pre> <p>If implemented directly, the above unary representation of natural numbers would be extremely inefficient. The Juvix compiler uses a binary number representation under the hood and implements arithmetic operations using corresponding machine instructions, so the performance of natural number arithmetic is similar to other programming languages. The <code>Nat</code> type is a high-level presentation of natural numbers as seen by the user who does not need to worry about low-level arithmetic implementation details.</p> <p>One can use <code>zero</code> and <code>suc</code> in pattern matching, like any other constructors:</p> <pre><code><pre>module Nat-Add;  import Stdlib.Data.Fixity open;  open Nat;  syntax operator + additive;  + : Nat -&gt; Nat -&gt; Nat    | zero b := b    | (suc a) b := suc (a + b);end;</pre></code></pre> <p>The <code>syntax operator + additive</code> declares <code>+</code> to be an operator with the <code>additive</code> fixity. The <code>+</code> is an ordinary function, except that function application for <code>+</code> is written in infix notation. The definitions of the clauses of <code>+</code> still need the prefix notation on the left-hand sides. Note that to use this definition in the code one needs to import and open <code>Stdlib.Data.Fixity</code>.</p> <p>The <code>a</code> and <code>b</code> in the patterns on the left-hand sides of the clauses are variables which match arbitrary values of the corresponding type. They can be used on the right-hand side to refer to the values matched. For example, when evaluating</p> <pre><code>(suc (suc zero)) + zero\n</code></pre> <p>the second clause of <code>+</code> matches, assigning <code>suc zero</code> to <code>a</code> and <code>zero</code> to <code>b</code>. Then the right-hand side of the clause is evaluated with <code>a</code> and <code>b</code> substituted by these values:</p> <pre><code>suc (suc zero + zero)\n</code></pre> <p>Again, the second clause matches, now with both <code>a</code> and <code>b</code> being <code>zero</code>. After replacing with the right-hand side, we obtain:</p> <pre><code>suc (suc (zero + zero))\n</code></pre> <p>Now the first clause matches and finally we obtain the result</p> <pre><code>suc (suc zero)\n</code></pre> <p>which is just <code>2</code>.</p> <p>The function <code>+</code> is defined like above in the standard library, but the Juvix compiler treats it specially and generates efficient code using appropriate CPU instructions.</p>","boost":2},{"location":"tutorials/learn/#pattern-matching","title":"Pattern matching","text":"<p>The patterns in function clauses do not have to match on a single constructor \u2013 they may be arbitrarily deep. For example, here is an (inefficient) implementation of a function which checks whether a natural number is even:</p> <pre><code><pre>module Even;  open Nat;  open Bool;    even : Nat -&gt; Bool    | zero := true    | (suc zero) := false    | (suc (suc n)) := even n;end;</pre></code></pre> <p>This definition states that a natural number <code>n</code> is even if either <code>n</code> is <code>zero</code> or, recursively, <code>n-2</code> is even.</p> <p>If a subpattern is to be ignored, then one can use a wildcard <code>_</code> instead of naming the subpattern.</p> <pre><code><pre>module Positive;  open Nat;  open Bool;    isPositive : Nat -&gt; Bool    | zero := false    | (suc _) := true;end;</pre></code></pre> <p>The above function could also be written as:</p> <pre><code><pre>module Positive-Alt;  open Nat;  open Bool;    isPositive : Nat -&gt; Bool    | zero := false    | _ := true;end;</pre></code></pre> <p>It is not necessary to define a separate function to perform pattern matching. One can use the <code>case</code> syntax to pattern match an expression directly.</p> <pre><code>Stdlib.Prelude&gt; case (1, 2) | (suc _, zero) := 0 | (suc _, suc x) := x | _ := 19\n1\n</code></pre> <p>It is possible to name subpatterns with <code>@</code>.</p> <pre><code>Stdlib.Prelude&gt; case 3 | suc n@(suc _) := n | _ := 0\n2\n</code></pre>","boost":2},{"location":"tutorials/learn/#comparisons-and-conditionals","title":"Comparisons and conditionals","text":"<p>The standard library includes all the expected comparison operators: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>==</code>, <code>/=</code>, <code>min</code>, <code>max</code>. Similarly to arithmetic operations, the comparisons are in fact defined generically for different datatypes using traits, which are out of the scope of this tutorial. For basic usage, one can assume that the comparisons operate on natural numbers.</p> <p>For example, one may define the function <code>max3</code> by using the type Nat, functions <code>&gt;</code> ,and <code>max</code> provided in the Standard Library:</p> <pre><code><pre>module max3-example;  import Stdlib.Prelude open;    max3 (x y z : Nat) : Nat := if (x &gt; y) (max x z) (max y z);end;</pre></code></pre> <p>The conditional <code>if</code> is a special function which is evaluated lazily, i.e., first the condition (the first argument) is evaluated, and then depending on its truth-value one of the branches (the second or the third argument) is evaluated and returned.</p> <p>By default, evaluation in Juvix is eager (or strict), meaning that the arguments to a function are fully evaluated before applying the function. Only <code>if</code>, <code>||</code> and <code>&amp;&amp;</code> are treated specially and evaluated lazily. These special functions cannot be partially applied (see Partial application and higher-order functions below).</p>","boost":2},{"location":"tutorials/learn/#local-definitions","title":"Local definitions","text":"<p>Juvix supports local definitions with let-expressions.</p> <pre><code><pre>module Let-Mult;  import Stdlib.Prelude open;    f (a : Nat) : Nat :=    let      x : Nat := a + 5;      y : Nat := a * 7 + x;    in x * y;end;</pre></code></pre> <p>The variables <code>x</code> and <code>y</code> are not visible outside <code>f</code>.</p> <p>One can also use multi-clause definitions in <code>let</code>-expressions, with the same syntax as definitions inside a module. For example:</p> <pre><code><pre>module Let-Even;  open Nat;  open Bool;    even : Nat -&gt; Bool :=    let      even' : Nat -&gt; Bool        | zero := true        | (suc n) := odd' n;      odd' : Nat -&gt; Bool        | zero := false        | (suc n) := even' n;    in even';end;</pre></code></pre> <p>The functions <code>even'</code> and <code>odd'</code> are not visible outside <code>even</code>.</p>","boost":2},{"location":"tutorials/learn/#recursion","title":"Recursion","text":"<p>Juvix is a purely functional language, which means that functions have no side effects and all variables are immutable. An advantage of functional programming is that all expressions are referentially transparent \u2013 any expression can be replaced by its value without changing the meaning of the program. This makes it easier to reason about programs, in particular to prove their correctness. No errors involving implicit state are possible, because the state is always explicit.</p> <p>In a functional language, there are no imperative loops. Repetition is expressed using recursion. In many cases, the recursive definition of a function follows the inductive definition of a data structure the function analyses. For example, consider the following inductive type of lists of natural numbers:</p> <pre><code><pre>module NList;  import Stdlib.Prelude open;  type NList :=    | nnil : NList    | ncons : Nat -&gt; NList -&gt; NList;end;</pre></code></pre> <p>An element of <code>NList</code> is either <code>nnil</code> (empty) or <code>ncons x xs</code> where <code>x : Nat</code> and <code>xs : NList</code> (a list with head <code>x</code> and tail <code>xs</code>).</p> <p>A function computing the length of a list may be defined by:</p> <pre><code><pre>module NLength;  import Stdlib.Prelude open;  open NList;    nlength : NList -&gt; Nat    | nnil := 0    | (ncons _ xs) := nlength xs + 1;end;</pre></code></pre> <p>The definition follows the inductive definition of <code>NList</code>. There are two function clauses for the two constructors. The case for <code>nnil</code> is easy \u2013 the constructor has no arguments and the length of the empty list is <code>0</code>. For a constructor with some arguments, one typically needs to express the result of the function in terms of the constructor arguments, usually calling the function recursively on the constructor's inductive arguments (for <code>ncons</code> this is the second argument). In the case of <code>ncons _ xs</code>, we recursively call <code>nlength</code> on <code>xs</code> and add <code>1</code> to the result.</p> <p>Let's consider another example \u2013 a function which returns the maximum of the numbers in a list or 0 for the empty list.</p> <pre><code><pre>module NMaximum;  import Stdlib.Prelude open;  open NList;    nmaximum : NList -&gt; Nat    | nnil := 0    | (ncons x xs) := max x (nmaximum xs);end;</pre></code></pre> <p>Again, there is a clause for each constructor. In the case for <code>ncons</code>, we recursively call the function on the list tail and take the maximum of the result and the list head.</p> <p>For an example of a constructor with more than one inductive argument, consider binary trees with natural numbers in nodes.</p> <pre><code><pre>module Tree;  open Nat;  type Tree :=    | leaf : Nat -&gt; Tree    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;end;</pre></code></pre> <p>The constructor <code>node</code> has two inductive arguments (the second and the third) which represent the left and the right subtree.</p> <p>A function which produces the mirror image of a tree may be defined by:</p> <pre><code><pre>module Mirror;  open Tree;    mirror : Tree -&gt; Tree    | (leaf x) := leaf x    | (node x l r) := node x (mirror r) (mirror l);end;</pre></code></pre> <p>The definition of <code>mirror</code> follows the definition of <code>Tree</code>. There are two recursive calls for the two inductive constructors of <code>node</code> (the subtrees).</p>","boost":2},{"location":"tutorials/learn/#partial-application-and-higher-order-functions","title":"Partial application and higher-order functions","text":"<p>Strictly speaking, all Juvix functions have only one argument. Multi-argument functions are really functions which return a function which takes the next argument and returns a function taking another argument, and so on for all arguments. The function type former <code>-&gt;</code> (the arrow) is right-associative. Hence, the type, e.g., <code>Nat -&gt; Nat -&gt; Nat</code> when fully parenthesised becomes <code>Nat -&gt; (Nat -&gt; Nat)</code>. It is the type of functions which given an argument of type <code>Nat</code> return a function of type <code>Nat -&gt; Nat</code> which itself takes an argument of type <code>Nat</code> and produces a result of type <code>Nat</code>. Function application is left-associative. For example, <code>f a b</code> when fully parenthesised becomes <code>(f a) b</code>. So it is an application to <code>b</code> of the function obtained by applying <code>f</code> to <code>a</code>.</p> <p>Since a multi-argument function is just a one-argument function returning a function, it can be partially applied to a smaller number of arguments than specified in its definition. The result is an appropriate function. For example, <code>sub 10</code> is a function which subtracts its argument from <code>10</code>, and <code>(+) 1</code> is a function which adds <code>1</code> to its argument. If the function has been declared as an infix operator (like <code>+</code>), then for partial application one needs to enclose it in parentheses.</p> <p>A function which takes a function as an argument is a higher-order function. An example is the <code>nmap</code> function which applies a given function to each element in a list of natural numbers.</p> <pre><code><pre>module NMap;  import Stdlib.Prelude open;  open NList;    nmap (f : Nat -&gt; Nat) : NList -&gt; NList    | nnil := nnil    | (ncons x xs) := ncons (f x) (nmap f xs);end;</pre></code></pre> <p>The application</p> <pre><code>nmap \\{ x := div x 2 } lst\n</code></pre> <p>divides every element of <code>lst</code> by <code>2</code>, rounding down the result. The expression</p> <pre><code>\\{ x := div x 2 }\n</code></pre> <p>is an unnamed function, or a lambda, which divides its argument by <code>2</code>.</p>","boost":2},{"location":"tutorials/learn/#polymorphism","title":"Polymorphism","text":"<p>The type <code>NList</code> we have been working with above requires the list elements to be natural numbers. It is possible to define lists polymorphically, parameterising them by the element type. This is similar to generics in languages like Java, C++ or Rust. Here is the polymorphic definition of lists from the standard library:</p> <pre><code><pre>module List;  import Stdlib.Data.Fixity open;  syntax operator :: cons;  type List A :=    | nil : List A    | :: : A -&gt; List A -&gt; List A;end;</pre></code></pre> <p>The constructor <code>::</code> is declared as a right-associative infix operator. The definition has a parameter <code>A</code> which is the element type. Then <code>List Ty</code> is the type of lists with elements of type <code>Ty</code>. For example, <code>List Nat</code> is the type of lists of natural numbers, isomorphic to the type <code>NList</code> defined above.</p> <p>Now one can define the <code>map</code> function polymorphically:</p> <pre><code><pre>module Map;  open List;    map {A B} (f : A -&gt; B) : List A -&gt; List B    | nil := nil    | (h :: hs) := f h :: map f hs;end;</pre></code></pre> <p>This function has two implicit type arguments <code>A</code> and <code>B</code>. These arguments are normally omitted in function application \u2013 they are inferred automatically during type checking. The curly braces indicate that the argument is implicit and should be inferred.</p> <p>In fact, the constructors <code>nil</code> and <code>::</code> also have an implicit argument: the type of list elements. All type parameters of a data type definition become implicit arguments of the constructors.</p> <p>Usually, the implicit arguments in a function application can be inferred. However, sometimes this is not possible and then the implicit arguments need to be provided explicitly by enclosing them in braces:</p> <pre><code>f {implArg1} .. {implArgK} arg1 .. argN\n</code></pre> For example, <code>nil {Nat}</code> has type <code>List Nat</code> while <code>nil</code> by itself has type `{A Type} -&gt; List A`.","boost":2},{"location":"tutorials/learn/#tail-recursion","title":"Tail recursion","text":"<p>Any recursive call whose result is further processed by the calling function needs to create a new stack frame to save the calling function environment. This means that each such call will use a constant amount of memory. For example, a function <code>sum</code> implemented as follows will use an additional amount of memory proportional to the length of the processed list:</p> <pre><code><pre>module List-Sum;  import Stdlib.Prelude open;    sum : List Nat -&gt; Nat    | nil := 0    | (x :: xs) := x + sum xs;end;</pre></code></pre> <p>This is not acceptable if you care about performance. In an imperative language, one would use a simple loop going over the list without any memory allocation. In pseudocode:</p> <pre><code>var sum : Nat := 0;\n\nwhile (lst /= nil) do\nbegin\n  sum := sum + head lst;\n  lst := tail lst;\nend;\n\nresult := sum;\n</code></pre> <p>Fortunately, it is possible to rewrite this function to use tail recursion. A recursive call is tail recursive if its result is also the result of the calling function, i.e., the calling function returns immediately after it without further processing. The Juvix compiler guarantees that all tail calls will be eliminated, i.e., that they will be compiled to simple jumps without extra memory allocation. In a tail recursive call, instead of creating a new stack frame, the old one is reused.</p> <p>The following implementation of <code>sum</code> uses tail recursion.</p> <pre><code><pre>module List-Sum-Tail;  import Stdlib.Prelude open;    sum (lst : List Nat) : Nat :=    let      go (acc : Nat) : List Nat -&gt; Nat        | nil := acc        | (x :: xs) := go (acc + x) xs;    in go 0 lst;end;</pre></code></pre> <p>The first argument of <code>go</code> is an accumulator which holds the sum computed so far. It is analogous to the <code>sum</code> variable in the imperative loop above. The initial value of the accumulator is 0. The function <code>go</code> uses only constant additional memory overall. The code generated for it by the Juvix compiler is equivalent to an imperative loop.</p> <p>Most imperative loops may be translated into tail recursive functional programs by converting the locally modified variables into accumulators and the loop condition into pattern matching. For example, here is an imperative pseudocode for computing the nth Fibonacci number in linear time. The variables <code>cur</code> and <code>next</code> hold the last two computed Fibonacci numbers.</p> <pre><code>var cur : Nat := 0;\nvar next : Nat := 1;\n\nwhile (n /= 0) do\nbegin\n  tmp := next;\n  next := cur + next;\n  cur := tmp;\n  n := n - 1;\nend;\n\nresult := cur;\n</code></pre> <p>An equivalent functional program is:</p> <pre><code><pre>module Fibonacci-tail;  import Stdlib.Prelude open;    fib : Nat -&gt; Nat :=    let      go (cur next : Nat) : Nat -&gt; Nat        | zero := cur        | (suc n) := go next (cur + next) n;    in go 0 1;end;</pre></code></pre> <p>A naive definition of the Fibonacci function runs in exponential time:</p> <pre><code><pre>module Fibonacci-Pattern;  import Stdlib.Prelude open;    fib : Nat -&gt; Nat    | zero := 0    | (suc zero) := 1    | (suc (suc n)) := fib n + fib (suc n);end;</pre></code></pre> <p>Tail recursion is less useful when the function needs to allocate memory anyway. For example, one could make the <code>map</code> function from the previous section tail recursive, but the time and memory use would still be proportional to the length of the input because of the need to allocate the result list. In fact, a tail recursive <code>map</code> needs to allocate and discard an intermediate list which is reversed in the end to preserve the original element order:</p> <pre><code><pre>module List-Map-Tail;  import Stdlib.Prelude open hiding {map};    map {A B} (f : A -&gt; B) : List A -&gt; List B :=    let      go (acc : List B) : List A -&gt; List B        | nil := reverse acc        | (x :: xs) := go (f x :: acc) xs;    in go nil;end;</pre></code></pre> <p>So we have replaced stack allocation with heap allocation. This actually decreases performance.</p> <p>As a side-note, notice that we used the <code>hiding</code> option while declaring the use of <code>Stdlib.Prelude</code>. This is due to the fact that the standard library already has a function named <code>map</code>. Since names are absolute, we need to hide the name in the standard library in order to define it in our module.</p>","boost":2},{"location":"tutorials/learn/#conclusion","title":"Conclusion","text":"<ul> <li>Use tail recursion to eliminate stack allocation.</li> <li>Do not use tail recursion to replace stack allocation with heap allocation.</li> </ul>","boost":2},{"location":"tutorials/learn/#iteration-over-data-structures","title":"Iteration over data structures","text":"<p>A common use of recursion is to traverse a data structure in a specified order accumulating some values. For example, the tail recursive <code>sum</code> function fits this pattern.</p> <p>Juvix provides special support for data structure traversals with the iterator syntax. The standard library defines several list iterators, among them <code>for</code> and <code>rfor</code>. We can implement the <code>sum</code> function using <code>for</code>:</p> <pre><code><pre>module List-Sum-For;  import Stdlib.Prelude open;    sum (l : List Nat) : Nat := for (acc := 0) (x in l) {x + acc};end;</pre></code></pre> <p>The braces around the body (in <code>{x + acc}</code>) are optional. A recommended style is to use braces if the body is on the same line.</p> <p>The above <code>for</code> iteration starts with the accumulator <code>acc</code> equal to <code>0</code> and goes through the list <code>l</code> from left to right (from beginning to end), at each step updating the accumulator to <code>x + acc</code> where <code>x</code> is the current list element and <code>acc</code> is the previous accumulator value. The final value of the iteration is the final value of the accumulator. The `for`` iterator is tail recursive, i.e., no stack memory is allocated and the whole iteration is compiled to a loop.</p> <p>The <code>rfor</code> iterator is analogous to <code>for</code> except that it goes through the list from right to left (from end to beginning) and is not tail recursive. For example, one can implement <code>map</code> using <code>rfor</code>:</p> <pre><code><pre>module List-Map-rfor;  import Stdlib.Prelude open hiding {map};    map {A B} (f : A -&gt; B) (l : List A) : List B :=    rfor (acc := nil) (x in l) {f x :: acc};end;</pre></code></pre> <p>The iterators are just ordinary higher-order Juvix functions which can be used with the iterator syntax. In fact, the <code>map</code> function from the standard library can also be used with the iterator syntax. The expression</p> <pre><code>map (x in l) {body}\n</code></pre> <p>is equivalent to</p> <pre><code>map \\{x := body} l\n</code></pre> <p>Whenever possible, it is advised to use the standard library iterators instead of manually writing recursive functions. When reasonable, <code>for</code> should be preferred to <code>rfor</code>. The iterators provide a readable syntax and the compiler might be able to optimize them better than manually written recursion.</p>","boost":2},{"location":"tutorials/learn/#totality-checking","title":"Totality checking","text":"<p>By default, the Juvix compiler requires all functions to be total. Totality consists of:</p> <ul> <li>termination and   coverage for function declarations,   and</li> <li>strict positivity for user-defined   data types.</li> </ul> <p>The termination check ensures that all functions are structurally recursive, i.e., all recursive calls are on structurally smaller values \u2013 subpatterns of the matched pattern.</p> <p>However, we can still make Juvix accept a non-terminating function via the <code>terminating</code> keyword, skipping the termination check.</p> <pre><code><pre>module Non-Terminating-Log;  import Stdlib.Prelude open;  terminating  log2 (n : Nat) : Nat := if (n &lt;= 1) 0 (suc (log2 (div n 2)));end;</pre></code></pre> <p>Let us look at other examples. The termination checker rejects the exponent definition</p> <pre><code><pre>module Fact-Non-Terminating;  import Stdlib.Prelude open;  terminating  fact (x : Nat) : Nat := if (x == 0) 1 (x * fact (sub x 1));end;</pre></code></pre> <p>without the 'terminating' keyword because the recursive call is not on a subpattern of a pattern matched on in the clause. One can reformulate this definition so that it is accepted by the termination checker:</p> <pre><code><pre>module Fact-Terminating;  import Stdlib.Prelude open;    fact : Nat -&gt; Nat    | zero := 1    | x@(suc n) := x * fact n;end;</pre></code></pre> <p>Coverage checking ensures that there are no unhandled patterns in function clauses or <code>case</code> expressions. For example, the following definition is rejected because the case <code>suc zero</code> is not handled:</p> <pre><code><pre>module Even-Not-Pass-Coverage;  import Stdlib.Prelude open;    even : Nat -&gt; Bool    | zero := true    | (suc (suc n)) := even n;end;</pre></code></pre> <p>Since coverage checking forces the user to specify the function for all input values, it may be unclear how to implement functions which are typically partial. For example, the <code>tail</code> function on lists is often left undefined for the empty list. One solution is to return a default value. In the Juvix standard library, <code>tail</code> is implemented as follows, returning the empty list when the argument is empty.</p> <pre><code><pre>module List-Tail;  open List;    tail {A} : List A -&gt; List A    | (_ :: xs) := xs    | nil := nil;end;</pre></code></pre> <p>Another solution is to wrap the result in the <code>Maybe</code> type from the standard library, which allows representing optional values. An element of <code>Maybe A</code> is either <code>nothing</code> or <code>just x</code> with <code>x : A</code>.</p> <pre><code><pre>module Maybe;  type Maybe A :=    | nothing : Maybe A    | just : A -&gt; Maybe A;end;</pre></code></pre> <p>For example, one could define the tail function as:</p> <pre><code><pre>module Maybe-List-Tail;  open List;  open Maybe;    tail {A} : List A -&gt; Maybe (List A)    | (_ :: xs) := just xs    | nil := nothing;end;</pre></code></pre> <p>Then the user needs to explicitly check if the result of the function contains a value or not:</p> <pre><code>case (tail' lst)\n| just x := ...\n| nothing := ...\n</code></pre>","boost":2},{"location":"tutorials/learn/#exercises","title":"Exercises","text":"<p>You have now learnt the very basics of Juvix. To consolidate your understanding of Juvix and functional programming, try doing some of the following exercises. To learn how to write more complex Juvix programs, see the advanced tutorial and the Juvix program examples.</p>","boost":2},{"location":"tutorials/learn/#warm-up-exercises","title":"Warm-up exercises","text":"","boost":2},{"location":"tutorials/learn/#boolean-operators","title":"Boolean operators","text":"<p>Let's start by defining some functions on booleans.</p> <p>The type for booleans is defined in the standard library like this:</p> <pre><code><pre>module Bool-Ex;  type Bool :=    | true : Bool    | false : Bool;end;</pre></code></pre> <p>Remember that you can import this definition by adding <code>import Stdlib.Prelude open</code> at the beginning of your module.</p> <p>Now, define the logical function <code>not</code> by using pattern matching.</p> <p>Tip</p> <p>The type of your function should be:</p> <pre><code>        not : Bool -&gt; Bool;\n</code></pre> <p>Now, define the logical functions <code>and</code>, <code>or</code> by using pattern matching as well. Feel free to experiment and see what happens if your patterns are not exhaustive, i.e., if not all the cases are covered.</p> <p>Next, let's define the logical function <code>xor</code>, which should return <code>true</code> if and only if exactly one of its arguments is <code>true</code>. This time, instead of using pattern matching, use the previously defined logical functions.</p> <p>Tip</p> <p>Be wary of using the standard library here as it may cause name conflicts.</p> Solution <p><pre><code><pre>module SolBool;  type Bool :=    | true : Bool    | false : Bool;    not : Bool -&gt; Bool    | false := true    | true := false;    or : Bool -&gt; Bool -&gt; Bool    | false b := b    | true  := true;    and : Bool -&gt; Bool -&gt; Bool    | true b := b    | false  := false;    xor (a b : Bool) : Bool := and (not (and a b)) (or a b);end;","boost":2},{"location":"tutorials/learn/#the-maybe-type","title":"The <code>Maybe</code> type","text":"<p>The <code>NMaybe</code> type encapsulates an optional natural number (the preceding <code>N</code>\nstands for <code>Nat</code>). The <code>nnothing</code> constructor is used when the value is missing.\nOn the other hand, the <code>njust</code> constructor is used when the value is present.</p>\n<pre><code><pre>module NMaybe;  import Stdlib.Prelude open;  type NMaybe :=    | nnothing : NMaybe    | njust : Nat \u2192 NMaybe;end;</pre></code></pre>\n\n<p>Let's define a function <code>isJust : NMaybe -&gt; Bool</code> that returns <code>true</code> when the\nvalue is present.</p>\n\nSolution\n<p><pre><code><pre>module SolNMaybe-Just;  import Stdlib.Prelude open;  type NMaybe :=    | nnothing : NMaybe    | njust : Nat \u2192 NMaybe;    isJust : NMaybe -&gt; Bool    | (njust _) := true    | nnothing := false;end;</pre></code></pre></p>\n\n<p>Now let's define a function <code>fromMaybe : Nat -&gt; NMaybe -&gt; Nat</code> that given a\n<code>NMaybe</code>, returns its value if present and otherwise returns the first argument\nas a default value.</p>\n\nSolution\n<p><pre><code><pre>module SolNMaybe-From;  import Stdlib.Prelude open;  type NMaybe :=    | nnothing : NMaybe    | njust : Nat \u2192 NMaybe;    fromMaybe (d : Nat) : NMaybe -&gt; Nat    | (njust n) := n    | nnothing := d;end;</pre></code></pre></p>\n\n<p>It would be useful to have a type that represents optional values of any type.\nIn Juvix, we can define the polymorphic version of <code>NMaybe</code> like this:</p>\n<pre><code><pre>module NMaybe-Poly;  type Maybe A :=    | nothing : Maybe A    | just : A \u2192 Maybe A;end;</pre></code></pre>\n\n<p>In this definition, we parameterize the type <code>Maybe</code> with a generic type <code>A</code>.</p>\n<p>Implement again the <code>fromMaybe</code> function, but now, for the polymorphic <code>Maybe</code>\ntype. Note that in function definitions we must specify the type variables. The\ndefinition of <code>fromMaybe</code> begin with:</p>\n<pre><code>fromMaybe {A} (d : A) : Maybe A -&gt; A\n</code></pre>\n<p>Give the implementation.</p>\n\nSolution\n<p><pre><code><pre>module SolNMaybe-Poly-From;  import Stdlib.Prelude open;    fromMaybe {A} (d : A) : Maybe A -&gt; A    | (just n) := n    | nothing := d;end;</pre></code></pre></p>\n\n<p>Neat! It is indeed very easy to define polymorphic functions in Juvix.</p>\n<p>To get some more practice, give an implementation for <code>maybe</code> which begins with:</p>\n<pre><code>maybe {A B} (d : B) (f : A -&gt; B) : Maybe A -&gt; B\n</code></pre>\n<p>This should return the value (if present) applied to the function <code>f</code>. Otherwise\nit should return the default value <code>d</code>.</p>\n\nSolution\n<p><pre><code><pre>module SolMaybe-Maybe;  import Stdlib.Prelude open;    maybe {A B} (d : B) (f : A -&gt; B) : Maybe A -&gt; B    | (just n) := f n    | nothing := d;end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#list-exercises","title":"List exercises","text":"<p>We can define polymorphic lists as follows:</p>\n<pre><code><pre>module List-Ex;  import Stdlib.Data.Fixity open;  syntax operator :: cons;  type List A :=    | nil : List A    | :: : A -&gt; List A -&gt; List A;end;</pre></code></pre>\n\n<p>Let's define a function that returns the first element of a <code>List</code> if it exists.</p>\n<p>Is beginning the definition as follows appropriate? If not, why?</p>\n<pre><code>head {A} : List A -&gt; A\n</code></pre>\n<p>Try to give an implementation for it.</p>\n\nSolution\n<p>As we know, Juvix guarantees that all functions are total.\nBut we cannot return anything when the list is empty.\nTherefore it makes sense to use the <code>Maybe</code> type that we defined in the previous section.\nThe proper definition of <code>head</code> should be:</p>\n<p><pre><code><pre>module Sol-Head;  import Stdlib.Prelude open;    head {A} : List A -&gt; Maybe A    | nil := nothing    | (h :: _) := just h;end;</pre></code></pre></p>\n\n<p>So far we have defined only functions that do not involve looping, but any\nnon-trivial program will require some sort of repetition, so let's tackle that.</p>\n<p>As stated previously, the only way to express repetition in Juivx is by using\nrecursion. We say that a function is recursive if it is defined in terms of\nitself, i.e., the name of the function appears in its body.</p>\n<p>The next exercise is to define a function which returns the last element of a\nlist. This function will need to call itself until it reaches the last element\nof the list.</p>\n<pre><code>last {A} : List A -&gt; Maybe A;\n</code></pre>\n\nSolution\n<p><pre><code><pre>module Sol-Last;  import Stdlib.Prelude open;    last {A} : List A -&gt; Maybe A    | nil := nothing    | (x :: nil) := just x    | (_ :: xs) := last xs;end;</pre></code></pre></p>\n\n<p>Next, implement a function that concatenates two lists:</p>\n<pre><code>  concat {A} : List A -&gt; List A -&gt; List A\n</code></pre>\n\n<p>Tip</p>\n<p>It is enough to pattern match the first list.</p>\n\n\nSolution\n<p><pre><code><pre>module Sol-Concat;  import Stdlib.Prelude open;    concat {A} : List A -&gt; List A -&gt; List A    | nil b := b    | (a :: as) b := a :: concat as b;end;</pre></code></pre></p>\n\n<p>Now write a function that concatenates a list of lists.</p>\n<pre><code>  concatMany {A} : List (List A) -&gt; List A\n</code></pre>\n\n<p>Tip</p>\n<p><code>concat</code> may be helpful.</p>\n\n\nSolution\n<p><pre><code><pre>module Sol-Concat-Many;  import Stdlib.Prelude open;    concat {A} : List A -&gt; List A -&gt; List A    | nil b := b    | (a :: as) b := a :: concat as b;    concatMany {A} : List (List A) -&gt; List A    | nil := nil    | (a :: as) := concat a (concatMany as);end;</pre></code></pre></p>\n\n<p>Can you give an alternative implementation that uses the <code>rfor</code> iterator? What\nwould happen if you used <code>for</code> instead of <code>rfor</code>?</p>\n\nSolution\n<p><pre><code><pre>module Sol-Concat-rfor;  import Stdlib.Prelude open;  import Stdlib.Data.Fixity open;    concat {A} : List A -&gt; List A -&gt; List A    | nil b := b    | (a :: as) b := a :: concat as b;    concatMany-iter {A} (m : List (List A)) : List A :=    rfor (acc := nil) (l in m)      concat l acc;end;</pre></code></pre></p>\n\n<p>In the previous solution, if you replace <code>rfor</code> by <code>for</code>, the resulting list\nwill be as if the original list was reversed, but each of the nested lists keep\ntheir original order.</p>\n<p>Write a function that reverses a list:</p>\n<ul>\n<li>using the <code>for</code> iterator,</li>\n<li>using tail recursion.</li>\n</ul>\n\nSolution\n<p>Using the <code>for</code> iterator:</p>\n<p><pre><code><pre>module Sol-Reverse-For;  import Stdlib.Prelude open;    reverse {A} (xs : List A) : List A := for (acc := nil) (x in xs) {x :: acc};end;</pre></code></pre></p>\n<p>Using tail recursion:</p>\n<p><pre><code><pre>module Sol-Reverse-Tail;  import Stdlib.Prelude open;    reverse {A} : List A -&gt; List A :=    let      go (acc : List A) : List A -&gt; List A        | nil := acc        | (x :: xs) := go (x :: acc) xs;    in go nil;end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#function-composition","title":"Function composition","text":"<p>Let's try a different exercise. Define a function <code>compose</code> that composes two\nfunctions <code>f</code> and <code>g</code>. It should take three arguments <code>f</code>, <code>g</code>, <code>x</code> and its only\nclause's body should be <code>f (g x)</code>.</p>\n<p>Can you make the <code>compose</code> function polymorphic and as general as possible?</p>\n\nHint\n<p>The definition should start like this:</p>\n<pre><code>    compose {A B C} ...\n</code></pre>\n\n\nSolution\n<p><pre><code><pre>module Sol-Compose;  compose {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);end;</pre></code></pre></p>\n\n<p>Congratulations! your warm-up is complete!</p>","boost":2},{"location":"tutorials/learn/#more-exercises","title":"More exercises","text":"","boost":2},{"location":"tutorials/learn/#prime-numbers","title":"Prime numbers","text":"<p>Define a function <code>prime : Nat -&gt; Bool</code> which checks if a given natural number\nis prime.</p>\n\n<p>Tip</p>\n<p>A number is prime if it is greater than 1 and has no divisors\nother than 1 and itself.</p>\n\n\nSolution\n<p><pre><code><pre>module Sol-Prime;  import Stdlib.Prelude open;    prime (x : Nat) : Bool :=    let      go : Nat -&gt; Bool        | zero := true        | (suc zero) := true        | n@(suc k) := if (mod x k == 0) false (go k);    in case x of {         | zero := false         | suc zero := false         | suc k := go k       };end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#half","title":"Half","text":"<p>Does Juvix accept the following definition?</p>\n<pre><code>half : Nat -&gt; Nat := if (n &lt; 2) 0 (half (sub n 2) + 1);\n</code></pre>\n<p>If not, how can you reformulate this definition so that it is accepted by Juvix?</p>\n\nSolution\n<p>The definition doesn't pass the termination checker.\nOne way to reformulate it is as follows:</p>\n<p><pre><code><pre>module Sol-Half;  import Stdlib.Prelude open;    half : Nat -&gt; Nat    | zero := 0    | (suc zero) := 0    | (suc (suc n)) := half n + 1;end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#suffixes","title":"Suffixes","text":"<p>A suffix of a list <code>l</code> is any list which can be obtained from <code>l</code> by removing\nsome initial elements. For example, the suffixes of <code>1 :: 2 :: 3 :: nil</code> are:</p>\n<ul>\n<li><code>1 :: 2 :: 3 :: nil</code>,</li>\n<li><code>2 :: 3 :: nil</code>,</li>\n<li><code>3 :: nil</code>, and</li>\n<li><code>nil</code>.</li>\n</ul>\n<p>Define a function which computes the list of all suffixes of a given list,\narranged in descending order of their lengths.</p>\n\nSolution\n<p><pre><code><pre>module Sol-Suffixes;  import Stdlib.Prelude open;    suffixes {A} : List A -&gt; List (List A)    | nil := nil :: nil    | xs@(_ :: xs') := xs :: suffixes xs';end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#tree-map","title":"Tree map","text":"<p>Recall the <code>Tree</code> type from above.</p>\n<pre><code><pre>module Tree-Ex;  import Stdlib.Prelude open;  type Tree :=    | leaf : Nat -&gt; Tree    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;end;</pre></code></pre>\n\n<p>Analogously to the <code>map</code> function for lists, define a function</p>\n<pre><code>tmap : (Nat -&gt; Nat) -&gt; Tree -&gt; Tree;\n</code></pre>\n<p>which applies a function to all natural numbers stored in a tree.</p>\n\nSolution\n<p><pre><code><pre>module Sol-Tree;  import Stdlib.Prelude open;  type Tree :=    | leaf : Nat -&gt; Tree    | node : Nat -&gt; Tree -&gt; Tree -&gt; Tree;    tmap (f : Nat -&gt; Nat) : Tree -&gt; Tree    | (leaf x) := leaf (f x)    | (node x l r) := node (f x) (tmap f l) (tmap f r);end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#polymorphic-tree","title":"Polymorphic tree","text":"<p>Modify the <code>Tree</code> type from Exercise 5 to be polymorphic in the\nelement type, and then repeat the previous exercise.</p>\n\nSolution\n<p>Only the types need to be changed.</p>\n<p><pre><code><pre>module Sol-Tree-Poly;  type Tree A :=    | leaf : A -&gt; Tree A    | node : A -&gt; Tree A -&gt; Tree A -&gt; Tree A;end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#factorial","title":"Factorial","text":"<p>Write a tail recursive function which computes the factorial of a natural\nnumber.</p>\n\nSolution\n<p><pre><code><pre>module Sol-Factorial;  import Stdlib.Prelude open;    fact : Nat -&gt; Nat :=    let      go (acc : Nat) : Nat -&gt; Nat        | zero := acc        | n@(suc n') := go (acc * n) n';    in go 1;end;</pre></code></pre></p>","boost":2},{"location":"tutorials/learn/#list-function-compose","title":"List function compose","text":"<p>Define a function</p>\n<pre><code>comp {A} : List (A -&gt; A) -&gt; A -&gt; A\n</code></pre>\n<p>which composes all functions in a list. For example,</p>\n<pre><code>comp (suc :: (*) 2 :: \\{x := sub x 1} :: nil)\n</code></pre>\n<p>should be a function which given <code>x</code> computes <code>2(x - 1) + 1</code>.</p>\n\nSolution\n<p><pre><code><pre>module Sol-Comp;  import Stdlib.Prelude open;    comp {A} (fs : List (A -&gt; A)) : A -&gt; A := for (acc := id) (f in fs) {acc \u2218 f};end;</pre></code></pre></p>\n<p>where <code>\u2218</code> is a composition function from the standard library:</p>\n<p><pre><code><pre>module Comp-Syntax;  import Stdlib.Data.Fixity open;  syntax operator \u2218 composition;  \u2218 {A B C} (f : B -&gt; C) (g : A -&gt; B) (x : A) : C := f (g x);end;</pre></code></pre></p>\n<p>The <code>\u2218</code> can be typed in Emacs or VSCode with <code>\\o</code>.</p>","boost":2},{"location":"tutorials/vscode/","title":"Juvix VSCode extension tutorial","text":"<p>To install the Juvix VSCode extension, click on the \"Extensions\" button in the left panel and search for the \"Juvix\" extension by Heliax.</p> <p>Once you've installed the Juvix extension, you can open a Juvix file. For example, create a <code>Hello.juvix</code> file with the following content.</p> <pre><code>\n</code></pre> <p>Syntax should be automatically highlighted for any file with <code>.juvix</code> extension. You can jump to the definition of an identifier by pressing F12 or control-clicking it. To apply the Juvix code formatter to the current file, use Shift+Ctrl+I.</p> <p>In the top right-hand corner of the editor window you should see several buttons. Hover the mouse pointer over a button to see its description. The functions of the buttons are as follows.</p> <ul> <li>Load file in REPL (Shift+Alt+R). Launches the Juvix REPL in a   separate window and loads the current file into it. You can then   evaluate any definition from the loaded file.</li> <li>Typecheck (Shift+Alt+T). Type-checks the current file.</li> <li>Compile (Shift+Alt+C). Compiles the current file. The resulting   native executable will be left in the directory of the file.</li> <li>Run (Shift+Alt+X). Compiles and runs the current file. The output of   the executable run is displayed in a separate window.</li> <li>Html preview. Generates HTML documentation for the current file and   displays it in a separate window.</li> </ul>","boost":2},{"location":"tutorials/workshop/","title":"Juvix Workshop ZKSummit10 version","text":"","boost":2},{"location":"tutorials/workshop/#introduction","title":"Introduction","text":"<p>In this part of the workshop, we will walk you through the process of installing Juvix, writing a simple program, and executing it. We will also introduce you to the command-line interface (CLI) and how to evaluate Juvix expressions.</p>","boost":2},{"location":"tutorials/workshop/#step-1-install-juvix-compiler","title":"Step 1: Install Juvix Compiler","text":"<p>The first step is to obtain a copy of the Juvix compiler. We have several installations listed here. Choose the one that suits you best.</p> <p>For convenience, we will use the Juvix extension in Visual Studio Code which will install Juvix for us.</p>","boost":2},{"location":"tutorials/workshop/#step-2-clone-the-repository","title":"Step 2: Clone the Repository","text":"<p>First, clone the following repository:</p> <pre><code>git clone https://github.com/anoma/juvix-workshop\n</code></pre> <p>Next, open the cloned repository in Visual Studio Code.</p>","boost":2},{"location":"tutorials/workshop/#step-3-install-the-juvix-extension","title":"Step 3: Install the Juvix Extension","text":"<p>In the extension tab, search for \"juvix\" and install the extension that features the Tara logo.</p>","boost":2},{"location":"tutorials/workshop/#step-4-open-helloworldjuvix-file","title":"Step 4: Open HelloWorld.juvix File","text":"<p>Open the <code>HelloWorld.juvix</code> file. You should get a prompt to install Juvix - click on the prompt and wait for Juvix to install. After reloading the page, full semantic highlighting should appear in the Juvix file.</p> <p>Here's a quick rundown of what you'll see in the file:</p> <ul> <li>The <code>module</code> declaration opens a file, it must have the same name as the file.</li> <li>We import the Juvix standard library; the <code>open</code> keyword at the end means that all the symbols in the imported module are added to the scope of the module unqualified.</li> <li>There is a function called <code>main</code>, which serves as the entry point to the program. It has type <code>IO</code>. The line below defines the body of the function. In this case, it simply calls the <code>printStringLn</code> function from the standard library with a single string argument.</li> </ul> <p>You can see the type of symbols in the code by hovering over them and navigate to the definitions of symbols in the code by CMD+clicking on them. You can also open a REPL session from within the editor itself.</p>","boost":2},{"location":"tutorials/workshop/#step-5-use-the-cli","title":"Step 5: Use the CLI","text":"<p>The Juvix compiler can also be driven from the command line. Let's see that in action.</p> <p>In the clone of the repository we made before, change directory to the <code>hello-world</code> project and compile the <code>HelloWorld.juvix</code> source file.</p> <pre><code>cd juvix-workshop\ncd hello-world\njuvix compile HelloWorld.juvix\n./HelloWorld\n</code></pre> <p>Juvix also has a read-eval-print-loop (REPL) program that can be used to evaluate Juvix expressions. We invoke this by running <code>juvix repl</code> in the terminal.</p> <pre><code>juvix repl\n</code></pre> <p>Let's evaluate some Juvix expressions to try it out.</p> <pre><code>1 + 1\nprintStringLn \"Hello\"\n</code></pre> <p>We'll explore more examples in the REPL later. Stay tuned!</p>","boost":2},{"location":"tutorials/workshop/#juvix-programming-and-basic-concepts","title":"Juvix Programming and Basic Concepts","text":"<p>In this tutorial, we will introduce you to the basic concepts of Juvix programming language. We'll cover functions, types, pattern matching, recursion, polymorphism, and iterators.</p>","boost":2},{"location":"tutorials/workshop/#step-1-create-a-new-file","title":"Step 1: Create a New File","text":"<p>Let's start by creating a new file named <code>Example.juvix</code>. Import and open the standard library. Also, initiate a REPL (Read-Eval-Print Loop) session for this file. The REPL will provide feedback from the compiler as we write the program.</p>","boost":2},{"location":"tutorials/workshop/#step-2-functions-in-juvix","title":"Step 2: Functions in Juvix","text":"<p>Juvix is a functional language, which means we can define functions. Unlike languages like Python that use a <code>def</code> keyword to define functions, Juvix doesn't require a keyword.</p> <p>Here's how to define a function:</p> <pre><code>add1 (n : Nat) : Nat;\n</code></pre> <p>If you see an error in the REPL, it's because we're missing a function clause. The symbol <code>:=</code> separates the arguments from the body of the clause.</p> <pre><code>add1 (n : Nat) : Nat := n + 1;\n</code></pre> <p>You can evaluate this function in the REPL. In Juvix, we apply a function to its arguments by writing the function next to its arguments, without parentheses.</p> <p>Let's define another function, <code>maximum</code>, which takes two arguments:</p> <pre><code>maximum (n : Nat) (k : Nat) : Nat := if (n &lt; k) k n;\n</code></pre> <p>Note that calling the function with an argument of the wrong type will result in a type error:</p> <pre><code>maximum 1 true\n</code></pre> <p>In Juvix, all functions expect precisely one argument. A function that appears to take two arguments actually takes a single argument and returns a new function.</p> <pre><code>maximum3 : Nat -&gt; Nat := maximum 3;\n</code></pre>","boost":2},{"location":"tutorials/workshop/#step-3-types-in-juvix","title":"Step 3: Types in Juvix","text":"<p>Juvix is a typed functional language, allowing you to define types. We've already seen some types like <code>Nat</code>, <code>Int</code>, and <code>Bool</code> that are defined in the standard library.</p> <p>You can inspect their definition by using <code>:def</code> in the REPL:</p> <pre><code>:def Bool\n</code></pre> <p>Or navigate to their definition using CMD+click.</p> <p>Every type is defined by a number of constructors. For <code>Bool</code>, there are two constructors <code>true</code> and <code>false</code>. Constructors in Juvix simply gather the data of the type together.</p> <p>For instance, let's look at the type <code>Nat</code>, which represents non-negative integers. The <code>zero</code> constructor represents 0, while the <code>suc</code> constructor takes one argument and represents the successor of some other number. This is a recursive datatype because the <code>suc</code> constructor takes another <code>Nat</code>.</p> <pre><code>suc (suc (suc zero))\n</code></pre>","boost":2},{"location":"tutorials/workshop/#step-4-pattern-matching","title":"Step 4: Pattern Matching","text":"<p>We can define functions by pattern matching on the constructors of a type:</p> <pre><code>isZero : Nat -&gt; Bool\n | zero := true;\n | (suc k) := false;\n</code></pre>","boost":2},{"location":"tutorials/workshop/#step-5-recursive-functions","title":"Step 5: Recursive Functions","text":"<p>Recursive types are useful when defining recursive functions. Consider the function <code>even</code>:</p> <pre><code>even : Nat -&gt; Bool\n  | zero := true;\n  | (suc k) := not (even k);\n</code></pre> <p>Juvix will check that recursive functions will eventually terminate.</p> <pre><code>even : Nat -&gt; Bool\n  | zero := true;\n  | (suc k) := not (even (suc k));\n</code></pre>","boost":2},{"location":"tutorials/workshop/#step-6-polymorphism","title":"Step 6: Polymorphism","text":"<p>Types in Juvix can take arguments, leading to polymorphic types like <code>List Nat</code>, <code>List String</code>, and <code>List (List Bool)</code>.</p> <p>Let's examine the definition of <code>List</code>:</p> <pre><code>:def List\n[1]\n</code></pre> <p>We can define polymorphic functions by defining a function that takes a type as an argument:</p> <pre><code>length' {A} : List A -&gt; Nat\n  |  nil := 0;\n  | (x :: xs) := suc (length' xs);\n</code></pre> <p>The type argument can be determined from the other arguments. So Juvix allows you to omit the type arguments by marking them as implicit by wrapping them in curly braces.</p>","boost":2},{"location":"tutorials/workshop/#step-7-iterators","title":"Step 7: Iterators","text":"<p>Finally, let's look at iterator syntax in Juvix. This allows us to write folds from functional programming in a more readable and imperative style.</p> <pre><code>sum (xs : List Nat) : Nat := for (acc := 0) (x in xs) x + acc;\n</code></pre> <p>In this code, we're iterating over a list. Before the iteration begins, <code>acc</code> is set to <code>0</code>. The list is then traversed from beginning to end, and at each step, <code>acc</code> is updated with the value of the body <code>x + acc</code>.</p> <p>There are also iterator syntaxes for <code>map</code> where we apply a function to each element.</p> <pre><code>mult2  (xs : List Nat) : List Nat := map (x in xs) x * 2;\n</code></pre> <p>And filters</p> <pre><code>filterLarge (xs : List Nat) : List Nat := filter (x in xs) x &lt; 10;\n</code></pre> <p>You can find more examples of iterators in the standard library, and it's possible to define your own.</p>","boost":2},{"location":"tutorials/workshop/#step-8-exercises","title":"Step 8: Exercises","text":"<p>The exercises for this section are in https://github.com/anoma/juvix-workshop/blob/main/exercises/Exercises.juvix. You will find the following content, and your task is to replace the <code>add-solution-here</code> with your solution.</p> Exercises.juvixSolutions.juvix <pre><code>-- See https://docs.juvix.org/dev/tutorials/learn/#exercises for more exercises\nmodule Exercises;\n\nimport Stdlib.Prelude open;\n\n-- Delete this function when you have completed the exercises\naxiom add-solution-here : {A : Type} -&gt; A;\n\n--- Write a function that computes the exponentation n^m\nexp : Nat -&gt; Nat -&gt; Nat := add-solution-here;\n\n--- Write a function that returns the last element in a list\nlast {A} : List A -&gt; Maybe A := add-solution-here;\n\n--- Write a function that reverses a list\nrev {A} : List A -&gt; List A := add-solution-here;\n\n--- Write a function that computes the maximum element in a list of natural numbers\nmaximum : List Nat -&gt; Nat := add-solution-here;\n\n--- Write a function that computes the list of partial sums of a list of natural numbers\nsums : List Nat -&gt; List Nat := add-solution-here;\n\n--- Write a function that return the first element in a list that satisfies a predicate\nfindFirst {A} : (A -&gt; Bool) -&gt; List A -&gt; Maybe A :=\nadd-solution-here;\n\n--- Write a function that returns the longest initial sublist of elements that satisfy a predicate\ntakeWhile {A} : (A -&gt; Bool) -&gt; List A -&gt; List A :=\nadd-solution-here;\n\n--- Write a function which computes the length of a longest continuous sublist of elements satisfying a predicate\nlongest {A} : (A -&gt; Bool) -&gt; List A -&gt; Nat :=\nadd-solution-here;\n\ntype Tree (A : Type) :=\n| leaf A\n| node (Tree A) (Tree A);\n\n--- Write a function that counts the total number of leaves in a tree\ncountLeaves {A} : Tree A -&gt; Nat := add-solution-here;\n\n--- Write a function which checks if a ;Tree; is balanced.\n--- A ;Tree; is balanced if the number of leaves in the left and right subtree of every\n--- node differ by at most 1.\nisBalanced {A} : Tree A -&gt; Bool := add-solution-here;\n</code></pre> <pre><code>module Solutions;\n\nimport Stdlib.Prelude open public;\n\n--- Write a function that computes the exponentation n^m\nexp (x : Nat) : Nat -&gt; Nat\n| zero := 1\n| (suc n) := x * exp x n;\n\n--- Write a function that checks if a ;Nat; is prime\nisPrime (n : Nat) : Bool :=\nlet\n    go : Nat -&gt; Bool\n    | zero := true\n    | (suc zero) := true\n    | k@(suc k') := if (mod n k == 0) false (go k');\nin case n of {\n    | zero := false\n    | suc zero := false\n    | suc k := go k\n};\n\n--- Write a function that returns the last element in a list\nlast {A} : List A -&gt; Maybe A\n| nil := nothing\n| (x :: nil) := just x\n| (_ :: xs) := last xs;\n\n--- Write a function that reverses a list\nrev {A : Type} (xs : List A) : List A :=\nfor (acc := nil) (x in xs)\n    x :: acc;\n\n--- Write a function that computes the maximum element in a list of natural numbers\nmaximum (xs : List Nat) : Nat :=\nfor (acc := 0) (x in xs)\n    if (x &gt; acc) x acc;\n\n--- Write a function that computes the list of partial sums of a list of natural numbers\nsums (xs : List Nat) : List Nat :=\nreverse\n    $ fst\n    $ for (acc, s := nil, 0) (x in xs)\n        x + s :: acc, x + s;\n\n--- Write a function that computes the first element in a list that satisfies a predicate\nfindFirst {A} (p : A -&gt; Bool) : List A -&gt; Maybe A\n| nil := nothing\n| (x :: xs) := if (p x) (just x) (findFirst p xs);\n\n--- Write a function that returns the longest initial sublist of elements that satisfy a predicate\ntakeWhile {A} (p : A -&gt; Bool) : List A -&gt; List A\n| nil := nil\n| (x :: xs) := if (p x) (x :: takeWhile p xs) nil;\n\n--- Write a function which computes the length of a longest continuous sublist of elements satisfying a predicate\nlongest {A : Type} (p : A -&gt; Bool) (xs : List A) : Nat :=\n-- `len` is the length of the longest sublist found so far\n-- `len'` is the length of the longest sublist ending at the current element\ncase for (len, len' := 0, 0) (x in xs)\n        if (p x)\n            (len, len' + 1)\n            (max len len', 0) of\n{  len, len' := max len len'};\n\ntype Tree (A : Type) :=\n| leaf A\n| node (Tree A) (Tree A);\n\n--- Write a function that counts the total number of leaves in a tree\ncountLeaves {A} : Tree A -&gt; Nat\n| (leaf _) := 1\n| (node l r) := countLeaves l + countLeaves r;\n\n--- Write a function which checks if a ;Tree; is balanced.\n--- A ;Tree; is balanced if the number of leaves in the left and right subtree of every\n--- node differ by at most 1.\nisBalanced {A} : Tree A -&gt; Bool :=\nlet\n    go : Tree A -&gt;\n    Bool -- returns the value if the given tree is balanced\n    \u00d7 Nat -- returns the number of leaves in the given tree\n    | (leaf _) := true, 1\n    | (node l r) :=\n        case go l, go r of\n        { (isLeftBalance, nl), (isRightBalance, nr) :=\n                (isLeftBalance &amp;&amp; isRightBalance &amp;&amp;\n                    sub nr nl &lt;= 1\n                &amp;&amp; sub nl nr &lt;= 1),\n            nl + nr};\nin fst \u2218 go;\n</code></pre>","boost":2},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/archive/2022/","title":"2022","text":""},{"location":"blog/category/geb/","title":"geb","text":""},{"location":"blog/category/vampir/","title":"vampir","text":""},{"location":"blog/category/language/","title":"language","text":""},{"location":"blog/category/conference/","title":"conference","text":""},{"location":"blog/category/type-system/","title":"type-system","text":""}]}